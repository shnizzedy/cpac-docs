[
  {
    "name": "calc_motion_stats",
    "file": "CPAC/func_preproc/func_motion.py",
    "line_number": 45,
    "decorator_args": {
      "name": "calc_motion_stats",
      "switch": [
        [
          "functional_preproc",
          "run"
        ],
        [
          "functional_preproc",
          "motion_estimates_and_correction",
          "run"
        ]
      ],
      "inputs": [
        [
          "desc-preproc_bold",
          "space-bold_desc-brain_mask",
          "desc-movementParameters_motion",
          "max-displacement",
          "rels-displacement",
          "filtered-coordinate-transformation",
          "coordinate-transformation"
        ],
        "subject",
        "scan"
      ],
      "outputs": [
        "dvars",
        "framewise-displacement-power",
        "framewise-displacement-jenkinson",
        "power-params",
        "motion-params",
        "motion",
        "desc-summary_motion"
      ]
    },
    "docstring": "Calculate motion statistics for motion parameters.",
    "source_code": "def calc_motion_stats(wf, cfg, strat_pool, pipe_num, opt=None):\n    '''Calculate motion statistics for motion parameters.'''\n    motion_prov = strat_pool.get_cpac_provenance(\n        'desc-movementParameters_motion')\n    motion_correct_tool = check_prov_for_motion_tool(motion_prov)\n    coordinate_transformation = ['filtered-coordinate-transformation',\n                                 'coordinate-transformation']\n    gen_motion_stats = motion_power_statistics(\n        name=f'gen_motion_stats_{pipe_num}',\n        motion_correct_tool=motion_correct_tool,\n        filtered=strat_pool.filtered_movement)\n\n    # Special case where the workflow is not getting outputs from\n    # resource pool but is connected to functional datasource\n    wf.connect(*strat_pool.get_data('desc-preproc_bold'),\n               gen_motion_stats, 'inputspec.motion_correct')\n    wf.connect(*strat_pool.get_data('space-bold_desc-brain_mask'),\n               gen_motion_stats, 'inputspec.mask')\n    wf.connect(*strat_pool.get_data('desc-movementParameters_motion'),\n               gen_motion_stats, 'inputspec.movement_parameters')\n    wf.connect(*strat_pool.get_data('max-displacement'),\n               gen_motion_stats, 'inputspec.max_displacement')\n\n    if strat_pool.check_rpool('rels-displacement'):\n        wf.connect(*strat_pool.get_data('rels-displacement'),\n                   gen_motion_stats, 'inputspec.rels_displacement')\n    if strat_pool.check_rpool(coordinate_transformation):\n        wf.connect(*strat_pool.get_data(coordinate_transformation),\n                   gen_motion_stats, 'inputspec.transformations')\n\n    outputs = {\n        'framewise-displacement-power':\n            (gen_motion_stats, 'outputspec.FDP_1D'),\n        'framewise-displacement-jenkinson':\n            (gen_motion_stats, 'outputspec.FDJ_1D'),\n        'dvars': (gen_motion_stats, 'outputspec.DVARS_1D'),\n        'power-params': (gen_motion_stats, 'outputspec.power_params'),\n        'motion-params': (gen_motion_stats, 'outputspec.motion_params'),\n        'motion': (gen_motion_stats, 'outputspec.motion'),\n        'desc-summary_motion': (gen_motion_stats,\n                                'outputspec.desc-summary_motion')}\n\n    return wf, outputs"
  },
  {
    "name": "func_motion_correct",
    "file": "CPAC/func_preproc/func_motion.py",
    "line_number": 172,
    "decorator_args": {
      "name": "motion_correction",
      "switch": [
        "functional_preproc",
        "motion_estimates_and_correction",
        "run"
      ],
      "option_key": [
        "functional_preproc",
        "motion_estimates_and_correction",
        "motion_correction",
        "using"
      ],
      "option_val": [
        "3dvolreg",
        "mcflirt"
      ],
      "inputs": [
        [
          "desc-preproc_bold",
          "motion-basefile"
        ]
      ],
      "outputs": "!UNSUPPORTED_TYPE:Dict!"
    },
    "docstring": null,
    "source_code": "def func_motion_correct(wf, cfg, strat_pool, pipe_num, opt=None):\n    wf, outputs = motion_correct_connections(wf, cfg, strat_pool, pipe_num,\n                                             opt)\n\n    return wf, outputs"
  },
  {
    "name": "func_motion_correct_only",
    "file": "CPAC/func_preproc/func_motion.py",
    "line_number": 187,
    "decorator_args": {
      "name": "motion_correction_only",
      "switch": [
        "functional_preproc",
        "motion_estimates_and_correction",
        "run"
      ],
      "option_key": [
        "functional_preproc",
        "motion_estimates_and_correction",
        "motion_correction",
        "using"
      ],
      "option_val": [
        "3dvolreg",
        "mcflirt"
      ],
      "inputs": [
        [
          "desc-preproc_bold",
          "motion-basefile"
        ]
      ],
      "outputs": "@_MOTION_CORRECTED_OUTPUTS"
    },
    "docstring": null,
    "source_code": "def func_motion_correct_only(wf, cfg, strat_pool, pipe_num, opt=None):\n    wf, wf_outputs = motion_correct_connections(wf, cfg, strat_pool, pipe_num,\n                                                opt)\n\n    outputs = {\n        'desc-preproc_bold': wf_outputs['desc-motion_bold'],\n        'desc-motion_bold': wf_outputs['desc-motion_bold']\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "func_motion_estimates",
    "file": "CPAC/func_preproc/func_motion.py",
    "line_number": 207,
    "decorator_args": {
      "name": "motion_estimates",
      "switch": [
        "functional_preproc",
        "motion_estimates_and_correction",
        "run"
      ],
      "option_key": [
        "functional_preproc",
        "motion_estimates_and_correction",
        "motion_correction",
        "using"
      ],
      "option_val": [
        "3dvolreg",
        "mcflirt"
      ],
      "inputs": [
        [
          "desc-preproc_bold",
          "motion-basefile"
        ]
      ],
      "outputs": "@_MOTION_PARAM_OUTPUTS"
    },
    "docstring": "Calculate motion estimates using 3dVolReg or MCFLIRT.",
    "source_code": "def func_motion_estimates(wf, cfg, strat_pool, pipe_num, opt=None):\n    '''Calculate motion estimates using 3dVolReg or MCFLIRT.'''\n    from CPAC.pipeline.utils import present_outputs\n    wf, wf_outputs = motion_correct_connections(wf, cfg, strat_pool, pipe_num,\n                                                opt)\n    return (wf, present_outputs(wf_outputs,\n                                ['coordinate-transformation',\n                                 'filtered-coordinate-transformation',\n                                 'max-displacement',\n                                 'desc-movementParameters_motion',\n                                 'rels-displacement']))"
  },
  {
    "name": "get_motion_ref",
    "file": "CPAC/func_preproc/func_motion.py",
    "line_number": 238,
    "decorator_args": {
      "name": "get_motion_ref",
      "switch": [
        "functional_preproc",
        "motion_estimates_and_correction",
        "run"
      ],
      "option_key": [
        "functional_preproc",
        "motion_estimates_and_correction",
        "motion_correction",
        "motion_correction_reference"
      ],
      "option_val": [
        "mean",
        "median",
        "selected_volume",
        "fmriprep_reference"
      ],
      "inputs": [
        "desc-preproc_bold",
        "desc-reorient_bold"
      ],
      "outputs": [
        "motion-basefile"
      ]
    },
    "docstring": null,
    "source_code": "def get_motion_ref(wf, cfg, strat_pool, pipe_num, opt=None):\n    if opt not in get_motion_ref.option_val:\n        raise ValueError('\\n\\n[!] Error: The \\'motion_correction_reference\\' '\n                         'parameter of the \\'motion_correction\\' workflow '\n                         'must be one of:\\n\\t{0}.\\n\\nTool input: \\'{1}\\''\n                         '\\n\\n'.format(\n                             ' or '.join([f\"'{val}'\" for val in\n                                          get_motion_ref.option_val]),\n                             opt))\n\n    if opt == 'mean':\n        func_get_RPI = pe.Node(interface=afni_utils.TStat(),\n                               name=f'func_get_mean_RPI_{pipe_num}',\n                               mem_gb=0.48,\n                               mem_x=(1435097126797993 /\n                                      302231454903657293676544,\n                                      'in_file'))\n\n        func_get_RPI.inputs.options = '-mean'\n        func_get_RPI.inputs.outputtype = 'NIFTI_GZ'\n\n        node, out = strat_pool.get_data('desc-preproc_bold')\n        wf.connect(node, out, func_get_RPI, 'in_file')\n\n    elif opt == 'median':\n        func_get_RPI = pe.Node(interface=afni_utils.TStat(),\n                               name=f'func_get_median_RPI_{pipe_num}')\n\n        func_get_RPI.inputs.options = '-median'\n        func_get_RPI.inputs.outputtype = 'NIFTI_GZ'\n\n        node, out = strat_pool.get_data('desc-preproc_bold')\n        wf.connect(node, out, func_get_RPI, 'in_file')\n\n    elif opt == 'selected_volume':\n        func_get_RPI = pe.Node(interface=afni.Calc(),\n                               name=f'func_get_selected_RPI_{pipe_num}')\n\n        func_get_RPI.inputs.set(\n            expr='a',\n            single_idx=cfg.functional_preproc[\n                'motion_estimates_and_correction'][\n                'motion_correction']['motion_correction_reference_volume'],\n            outputtype='NIFTI_GZ'\n        )\n\n        node, out = strat_pool.get_data('desc-preproc_bold')\n        wf.connect(node, out, func_get_RPI, 'in_file_a')\n\n    elif opt == 'fmriprep_reference':\n        func_get_RPI = pe.Node(util.Function(input_names=['in_file'],\n                                             output_names=['out_file'],\n                                             function=estimate_reference_image\n                                             ),\n                           name=f'func_get_fmriprep_ref_{pipe_num}')\n\n        node, out = strat_pool.get_data('desc-reorient_bold')\n        wf.connect(node, out, func_get_RPI, 'in_file')\n\n    outputs = {\n        'motion-basefile': (func_get_RPI, 'out_file')\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "motion_estimate_filter",
    "file": "CPAC/func_preproc/func_motion.py",
    "line_number": 609,
    "decorator_args": {
      "name": "motion_estimate_filter",
      "config": [
        "functional_preproc",
        "motion_estimates_and_correction",
        "motion_estimate_filter"
      ],
      "switch": [
        "run"
      ],
      "option_key": "filters",
      "option_val": "USER-DEFINED",
      "inputs": [
        [
          "desc-preproc_bold",
          "space-bold_desc-brain_mask",
          "max-displacement",
          "rels-displacement",
          "coordinate-transformation",
          "desc-movementParameters_motion"
        ],
        "TR"
      ],
      "outputs": "!UNSUPPORTED_TYPE:Dict!"
    },
    "docstring": "Filter motion parameters.\n\n.. versionchanged:: 1.8.6\n   Beginning with version 1.8.6, C-PAC outputs both the unfiltered\n   and the filtered motion parameters and uses the unfiltered\n   parameters in QC. Previous versions only reported the filtered\n   parameters and used the filtered parameters for QC.",
    "source_code": "def motion_estimate_filter(wf, cfg, strat_pool, pipe_num, opt=None):\n    '''Filter motion parameters.\n\n    .. versionchanged:: 1.8.6\n       Beginning with version 1.8.6, C-PAC outputs both the unfiltered\n       and the filtered motion parameters and uses the unfiltered\n       parameters in QC. Previous versions only reported the filtered\n       parameters and used the filtered parameters for QC.\n    '''\n    notch_imports = ['import os', 'import numpy as np',\n                     'from scipy.signal import iirnotch, filtfilt, firwin, '\n                     'freqz',\n                     'from matplotlib import pyplot as plt',\n                     'from CPAC.func_preproc.utils import degrees_to_mm, '\n                     'mm_to_degrees']\n    notch = pe.Node(Function(input_names=['motion_params',\n                                          'filter_type',\n                                          'TR',\n                                          'fc_RR_min',\n                                          'fc_RR_max',\n                                          'center_freq',\n                                          'freq_bw',\n                                          'lowpass_cutoff',\n                                          'filter_order'],\n                             output_names=[\n                                 'filtered_motion_params',\n                                 'filter_info',\n                                 'filter_plot'],\n                             function=notch_filter_motion,\n                             imports=notch_imports),\n                    name=f'filter_motion_params_{opt[\"Name\"]}_{pipe_num}')\n\n    notch.inputs.filter_type = opt.get('filter_type')\n    notch.inputs.fc_RR_min = opt.get('breathing_rate_min')\n    notch.inputs.fc_RR_max = opt.get('breathing_rate_max')\n    notch.inputs.center_freq = opt.get('center_frequency')\n    notch.inputs.freq_bw = opt.get('filter_bandwidth')\n    notch.inputs.lowpass_cutoff = opt.get('lowpass_cutoff')\n    notch.inputs.filter_order = opt.get('filter_order')\n\n    movement_parameters = strat_pool.node_data(\n        'desc-movementParameters_motion')\n    wf.connect(movement_parameters.node, movement_parameters.out,\n               notch, 'motion_params')\n\n    node, out = strat_pool.get_data('TR')\n    wf.connect(node, out, notch, 'TR')\n\n    affine = pe.Node(Function(input_names=['params_file'],\n                              output_names=['affine_file'],\n                              function=affine_file_from_params_file),\n                     name='affine_from_filtered_params_'\n                          f'{opt[\"Name\"]}_{pipe_num}')\n    wf.connect(notch, 'filtered_motion_params', affine, 'params_file')\n\n    outputs = {\n        'filtered-coordinate-transformation': (affine, 'affine_file'),\n        'motion-filter-info': (notch, 'filter_info'),\n        'motion-filter-plot': (notch, 'filter_plot'),\n        'desc-movementParameters_motion': (notch, 'filtered_motion_params')\n    }\n\n    if not cfg.switch_is_off([\"functional_preproc\",\n                              \"motion_estimates_and_correction\",\n                              \"motion_estimate_filter\", \"run\"]):\n        outputs['desc-movementParametersUnfiltered_motion'] = (\n            movement_parameters.node, movement_parameters.out)\n\n    return (wf, outputs)"
  },
  {
    "name": "func_reorient",
    "file": "CPAC/func_preproc/func_preproc.py",
    "line_number": 524,
    "decorator_args": {
      "name": "func_reorient",
      "config": [
        "functional_preproc",
        "update_header"
      ],
      "switch": [
        "run"
      ],
      "inputs": [
        "bold"
      ],
      "outputs": [
        "desc-preproc_bold",
        "desc-reorient_bold"
      ]
    },
    "docstring": null,
    "source_code": "def func_reorient(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    func_deoblique = pe.Node(interface=afni_utils.Refit(),\n                             name=f'func_deoblique_{pipe_num}',\n                             mem_gb=0.68,\n                             mem_x=(4664065662093477 /\n                                    1208925819614629174706176,\n                                    'in_file'))\n    func_deoblique.inputs.deoblique = True\n\n    node, out = strat_pool.get_data('bold')\n    wf.connect(node, out, func_deoblique, 'in_file')\n\n    func_reorient = pe.Node(interface=afni_utils.Resample(),\n                            name=f'func_reorient_{pipe_num}',\n                            mem_gb=0,\n                            mem_x=(0.0115, 'in_file', 't'))\n\n    func_reorient.inputs.orientation = 'RPI'\n    func_reorient.inputs.outputtype = 'NIFTI_GZ'\n\n    wf.connect(func_deoblique, 'out_file', func_reorient, 'in_file')\n\n    outputs = {\n        'desc-preproc_bold': (func_reorient, 'out_file'),\n        'desc-reorient_bold': (func_reorient, 'out_file')\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "func_scaling",
    "file": "CPAC/func_preproc/func_preproc.py",
    "line_number": 562,
    "decorator_args": {
      "name": "func_scaling",
      "config": [
        "functional_preproc",
        "scaling"
      ],
      "switch": [
        "run"
      ],
      "inputs": [
        "desc-preproc_bold"
      ],
      "outputs": [
        "desc-preproc_bold"
      ]
    },
    "docstring": null,
    "source_code": "def func_scaling(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    scale_func_wf = create_scale_func_wf(\n        scaling_factor=cfg.scaling_factor,\n        wf_name=f\"scale_func_{pipe_num}\"\n    )\n\n    node, out = strat_pool.get_data(\"desc-preproc_bold\")\n    wf.connect(node, out, scale_func_wf, 'inputspec.func')\n\n    outputs = {\n        'desc-preproc_bold': (scale_func_wf, 'outputspec.scaled_func')\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "func_truncate",
    "file": "CPAC/func_preproc/func_preproc.py",
    "line_number": 586,
    "decorator_args": {
      "name": "func_truncate",
      "config": [
        "functional_preproc",
        "truncation"
      ],
      "inputs": [
        "desc-preproc_bold"
      ],
      "outputs": "!UNSUPPORTED_TYPE:Dict!"
    },
    "docstring": null,
    "source_code": "def func_truncate(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    # if cfg.functional_preproc['truncation']['start_tr'] == 0 and \\\n    #                cfg.functional_preproc['truncation']['stop_tr'] == None:\n    #    data, key = strat_pool.get_data(\"desc-preproc_bold\",\n    #                                           True)\n    #    outputs = {key: data}\n    #    return (wf, outputs)\n\n    trunc_wf = create_wf_edit_func(\n        wf_name=f\"edit_func_{pipe_num}\"\n    )\n    trunc_wf.inputs.inputspec.start_idx = cfg.functional_preproc[\n        'truncation']['start_tr']\n    trunc_wf.inputs.inputspec.stop_idx = cfg.functional_preproc['truncation'][\n        'stop_tr']\n\n    node, out = strat_pool.get_data(\"desc-preproc_bold\")\n    wf.connect(node, out, trunc_wf, 'inputspec.func')\n\n    outputs = {\n        'desc-preproc_bold': (trunc_wf, 'outputspec.edited_func')\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "func_despike",
    "file": "CPAC/func_preproc/func_preproc.py",
    "line_number": 623,
    "decorator_args": {
      "name": "func_despike",
      "config": [
        "functional_preproc",
        "despiking"
      ],
      "switch": [
        "run"
      ],
      "option_key": [
        "space"
      ],
      "option_val": [
        "native"
      ],
      "inputs": [
        "desc-preproc_bold"
      ],
      "outputs": "!UNSUPPORTED_TYPE:Dict!"
    },
    "docstring": null,
    "source_code": "def func_despike(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    despike = pe.Node(interface=preprocess.Despike(),\n                      name=f'func_despiked_{pipe_num}',\n                      mem_gb=0.66,\n                      mem_x=(8251808479088459 / 1208925819614629174706176,\n                             'in_file'))\n    despike.inputs.outputtype = 'NIFTI_GZ'\n\n    node, out = strat_pool.get_data(\"desc-preproc_bold\")\n    wf.connect(node, out, despike, 'in_file')\n\n    outputs = {\n        'desc-preproc_bold': (despike, 'out_file')\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "func_despike_template",
    "file": "CPAC/func_preproc/func_preproc.py",
    "line_number": 658,
    "decorator_args": {
      "name": "func_despike_template",
      "config": [
        "functional_preproc",
        "despiking"
      ],
      "switch": [
        "run"
      ],
      "option_key": [
        "space"
      ],
      "option_val": [
        "template"
      ],
      "inputs": [
        [
          "space-template_desc-preproc_bold",
          "space-template_res-derivative_desc-preproc_bold"
        ],
        "T1w-template-funcreg",
        "T1w-template-deriv"
      ],
      "outputs": "!UNSUPPORTED_TYPE:Dict!"
    },
    "docstring": null,
    "source_code": "def func_despike_template(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    despike = pe.Node(interface=preprocess.Despike(),\n                      name=f'func_despiked_template_{pipe_num}',\n                      mem_gb=0.66,\n                      mem_x=(8251808479088459 / 1208925819614629174706176,\n                             'in_file'))\n    despike.inputs.outputtype = 'NIFTI_GZ'\n\n    node, out = strat_pool.get_data(\"space-template_desc-preproc_bold\")\n    wf.connect(node, out, despike, 'in_file')\n\n    outputs = {\n        'space-template_desc-preproc_bold': (despike, 'out_file')\n    }\n    \n    if strat_pool.get_data(\"space-template_res-derivative_desc-preproc_bold\"):\n        despike_funcderiv = pe.Node(interface=preprocess.Despike(),\n                                    name=f'func_deriv_despiked_template_{pipe_num}',\n                                    mem_gb=0.66,\n                                    mem_x=(8251808479088459 / 1208925819614629174706176,\n                                    'in_file'))\n        despike_funcderiv.inputs.outputtype = 'NIFTI_GZ'\n\n        node, out = strat_pool.get_data(\"space-template_res-derivative_desc-preproc_bold\")\n        wf.connect(node, out, despike_funcderiv, 'in_file')\n\n        outputs.update({\n            'space-template_res-derivative_desc-preproc_bold':\n                (despike_funcderiv, 'out_file')})\n\n    return (wf, outputs)"
  },
  {
    "name": "func_slice_time",
    "file": "CPAC/func_preproc/func_preproc.py",
    "line_number": 702,
    "decorator_args": {
      "name": "func_slice_time",
      "config": [
        "functional_preproc",
        "slice_timing_correction"
      ],
      "switch": [
        "run"
      ],
      "inputs": [
        "desc-preproc_bold",
        "TR",
        "tpattern"
      ],
      "outputs": "!UNSUPPORTED_TYPE:Dict!"
    },
    "docstring": null,
    "source_code": "def func_slice_time(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    slice_time = slice_timing_wf(name='func_slice_timing_correction_'\n                                      f'{pipe_num}',\n                                 tpattern=cfg.functional_preproc[\n                                     'slice_timing_correction']['tpattern'],\n                                 tzero=cfg.functional_preproc[\n                                     'slice_timing_correction']['tzero'])\n\n    node, out = strat_pool.get_data(\"desc-preproc_bold\")\n    wf.connect(node, out, slice_time, 'inputspec.func_ts')\n\n    node, out = strat_pool.get_data('TR')\n    wf.connect(node, out, slice_time, 'inputspec.tr')\n\n    node, out = strat_pool.get_data('tpattern')\n    wf.connect(node, out, slice_time, 'inputspec.tpattern')\n\n    outputs = {\n        'desc-preproc_bold': (slice_time, 'outputspec.slice_time_corrected'),\n        'desc-stc_bold': (slice_time, 'outputspec.slice_time_corrected')\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "bold_mask_afni",
    "file": "CPAC/func_preproc/func_preproc.py",
    "line_number": 738,
    "decorator_args": {
      "name": "bold_mask_afni",
      "switch": [
        [
          "functional_preproc",
          "run"
        ],
        [
          "functional_preproc",
          "func_masking",
          "run"
        ]
      ],
      "option_key": [
        "functional_preproc",
        "func_masking",
        "using"
      ],
      "option_val": "AFNI",
      "inputs": [
        "desc-preproc_bold"
      ],
      "outputs": "!UNSUPPORTED_TYPE:Dict!"
    },
    "docstring": null,
    "source_code": "def bold_mask_afni(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    func_get_brain_mask = pe.Node(interface=preprocess.Automask(),\n                                  name=f'func_get_brain_mask_AFNI_{pipe_num}')\n    func_get_brain_mask.inputs.outputtype = 'NIFTI_GZ'\n\n    node, out = strat_pool.get_data(\"desc-preproc_bold\")\n    wf.connect(node, out, func_get_brain_mask, 'in_file')\n\n    outputs = {\n        'space-bold_desc-brain_mask': (func_get_brain_mask, 'out_file')\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "bold_mask_fsl",
    "file": "CPAC/func_preproc/func_preproc.py",
    "line_number": 763,
    "decorator_args": {
      "name": "bold_mask_fsl",
      "switch": [
        [
          "functional_preproc",
          "run"
        ],
        [
          "functional_preproc",
          "func_masking",
          "run"
        ]
      ],
      "option_key": [
        "functional_preproc",
        "func_masking",
        "using"
      ],
      "option_val": "FSL",
      "inputs": [
        "desc-preproc_bold"
      ],
      "outputs": [
        "space-bold_desc-brain_mask"
      ]
    },
    "docstring": null,
    "source_code": "def bold_mask_fsl(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    inputnode_bet = pe.Node(\n        util.IdentityInterface(fields=['frac',\n                                       'mesh_boolean',\n                                       'outline',\n                                       'padding',\n                                       'radius',\n                                       'reduce_bias',\n                                       'remove_eyes',\n                                       'robust',\n                                       'skull',\n                                       'surfaces',\n                                       'threshold',\n                                       'vertical_gradient']),\n        name=f'BET_options_{pipe_num}')\n\n    func_get_brain_mask = pe.Node(interface=fsl.BET(),\n                                  name=f'func_get_brain_mask_BET_{pipe_num}')\n    func_get_brain_mask.inputs.output_type = 'NIFTI_GZ'\n    func_get_brain_mask.inputs.mask = True\n\n    inputnode_bet.inputs.set(\n        frac=cfg.functional_preproc['func_masking']['FSL-BET']['frac'],\n        mesh_boolean=cfg.functional_preproc['func_masking']['FSL-BET'][\n            'mesh_boolean'],\n        outline=cfg.functional_preproc['func_masking']['FSL-BET'][\n            'outline'],\n        padding=cfg.functional_preproc['func_masking']['FSL-BET'][\n            'padding'],\n        radius=cfg.functional_preproc['func_masking']['FSL-BET']['radius'],\n        reduce_bias=cfg.functional_preproc['func_masking']['FSL-BET'][\n            'reduce_bias'],\n        remove_eyes=cfg.functional_preproc['func_masking']['FSL-BET'][\n            'remove_eyes'],\n        robust=cfg.functional_preproc['func_masking']['FSL-BET']['robust'],\n        skull=cfg.functional_preproc['func_masking']['FSL-BET']['skull'],\n        surfaces=cfg.functional_preproc['func_masking']['FSL-BET'][\n            'surfaces'],\n        threshold=cfg.functional_preproc['func_masking']['FSL-BET'][\n            'threshold'],\n        vertical_gradient=\n        cfg.functional_preproc['func_masking']['FSL-BET'][\n            'vertical_gradient'],\n    )\n\n    wf.connect([\n        (inputnode_bet, func_get_brain_mask, [\n            ('frac', 'frac'),\n            ('mesh_boolean', 'mesh'),\n            ('outline', 'outline'),\n            ('padding', 'padding'),\n            ('radius', 'radius'),\n            ('reduce_bias', 'reduce_bias'),\n            ('remove_eyes', 'remove_eyes'),\n            ('robust', 'robust'),\n            ('skull', 'skull'),\n            ('surfaces', 'surfaces'),\n            ('threshold', 'threshold'),\n            ('vertical_gradient', 'vertical_gradient'),\n        ])\n    ])\n\n    if cfg.functional_preproc['func_masking']['FSL-BET'][\n        'functional_mean_boolean']:\n        func_skull_mean = pe.Node(interface=afni_utils.TStat(),\n                                  name=f'func_mean_skull_{pipe_num}')\n        func_skull_mean.inputs.options = '-mean'\n        func_skull_mean.inputs.outputtype = 'NIFTI_GZ'\n\n        node, out = strat_pool.get_data(\"desc-preproc_bold\")\n        wf.connect(node, out, func_skull_mean, 'in_file')\n\n        out_node, out_file = (func_skull_mean, 'out_file')\n\n        if cfg.functional_preproc['func_masking']['FSL-BET'][\n            'functional_mean_thr']['run']:\n            # T=$(fslstats ${subject}_tmean.nii.gz -p 98)\n            threshold_T = pe.Node(interface=fsl.ImageStats(),\n                                    name=f'func_mean_skull_thr_value_{pipe_num}',\n                                    iterfield=['in_file'])\n            threshold_T.inputs.op_string = \"-p %f \" % (cfg.functional_preproc['func_masking']['FSL-BET']['functional_mean_thr']['threshold_value'])\n\n            wf.connect(func_skull_mean, 'out_file', threshold_T, 'in_file')\n\n            # z=$(echo \"$T / 10\" | bc -l)\n            def form_thr_string(thr):\n                threshold_z = str(float(thr/10))\n                return '-thr %s' % (threshold_z)\n\n            form_thr_string = pe.Node(util.Function(input_names=['thr'],\n                                            output_names=['out_str'],\n                                            function=form_thr_string),\n                                            name=f'form_thr_string_{pipe_num}')\n\n            wf.connect(threshold_T, 'out_stat', form_thr_string, 'thr')\n\n            # fslmaths ${subject}_tmean.nii.gz -thr ${z} ${subject}_tmean_thr.nii.gz\n            func_skull_mean_thr = pe.Node(interface=fsl.ImageMaths(),\n                                            name=f'func_mean_skull_thr_{pipe_num}')\n\n            wf.connect(func_skull_mean, 'out_file', func_skull_mean_thr, 'in_file')\n            wf.connect(form_thr_string, 'out_str', func_skull_mean_thr, 'op_string')\n\n            out_node, out_file = (func_skull_mean_thr, 'out_file')\n\n        if cfg.functional_preproc['func_masking']['FSL-BET'][\n            'functional_mean_bias_correction']:\n\n            # fast --nopve -B ${subject}_tmean_thr.nii.gz\n            func_mean_skull_fast = pe.Node(interface=fsl.FAST(),\n                                                    name=f'func_mean_skull_fast_{pipe_num}')\n            func_mean_skull_fast.inputs.no_pve = True\n            func_mean_skull_fast.inputs.output_biascorrected = True\n\n            wf.connect(out_node, out_file, func_mean_skull_fast, 'in_files')\n\n            out_node, out_file = (func_mean_skull_fast, 'restored_image')\n\n        wf.connect(out_node, out_file, func_get_brain_mask, 'in_file')\n\n    else:\n        func_get_brain_mask.inputs.functional = True\n\n        node, out = strat_pool.get_data(\"desc-preproc_bold\")\n        wf.connect(node, out, func_get_brain_mask, 'in_file')\n\n    # erode one voxel of functional brian mask\n    erode_one_voxel = pe.Node(interface=fsl.ErodeImage(),\n                              name=f'erode_one_voxel_{pipe_num}')\n\n    erode_one_voxel.inputs.kernel_shape = 'box'\n    erode_one_voxel.inputs.kernel_size = 1.0\n\n    wf.connect(func_get_brain_mask, 'mask_file',\n               erode_one_voxel, 'in_file')\n\n    outputs = {\n        'space-bold_desc-brain_mask': (erode_one_voxel, 'out_file')\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "bold_mask_fsl_afni",
    "file": "CPAC/func_preproc/func_preproc.py",
    "line_number": 917,
    "decorator_args": {
      "name": "bold_mask_fsl_afni",
      "switch": [
        [
          "functional_preproc",
          "run"
        ],
        [
          "functional_preproc",
          "func_masking",
          "run"
        ]
      ],
      "option_key": [
        "functional_preproc",
        "func_masking",
        "using"
      ],
      "option_val": "FSL_AFNI",
      "inputs": [
        [
          "motion-basefile",
          "desc-preproc_bold"
        ],
        "FSL-AFNI-bold-ref",
        "FSL-AFNI-brain-mask",
        "FSL-AFNI-brain-probseg"
      ],
      "outputs": [
        "space-bold_desc-brain_mask",
        "desc-ref_bold"
      ]
    },
    "docstring": "fMRIPrep-style BOLD mask\n`Ref <https://github.com/nipreps/niworkflows/blob/maint/1.3.x/niworkflows/func/util.py#L246-L514>`_",
    "source_code": "def bold_mask_fsl_afni(wf, cfg, strat_pool, pipe_num, opt=None):\n    \"\"\"fMRIPrep-style BOLD mask\n    `Ref <https://github.com/nipreps/niworkflows/blob/maint/1.3.x/niworkflows/func/util.py#L246-L514>`_\n    \"\"\"\n\n    # Initialize transforms with antsAI\n    init_aff = pe.Node(\n        AI(\n            metric=(\"Mattes\", 32, \"Regular\", 0.2),\n            transform=(\"Affine\", 0.1),\n            search_factor=(20, 0.12),\n            principal_axes=False,\n            convergence=(10, 1e-6, 10),\n            verbose=True,\n        ),\n        name=f\"init_aff_{pipe_num}\",\n        n_procs=cfg.pipeline_setup['system_config']['num_OMP_threads'],\n    )\n    node, out = strat_pool.get_data('FSL-AFNI-bold-ref')\n    wf.connect(node, out, init_aff, 'fixed_image')\n\n    node, out = strat_pool.get_data('FSL-AFNI-brain-mask')\n    wf.connect(node, out, init_aff, 'fixed_image_mask')\n\n    init_aff.inputs.search_grid = (40, (0, 40, 40))\n\n    # Set up spatial normalization\n    norm = pe.Node(\n        ants.Registration(\n            winsorize_upper_quantile=0.98,\n            winsorize_lower_quantile=0.05,\n            float=True,\n            metric=['Mattes'],\n            metric_weight=[1],\n            radius_or_number_of_bins=[64],\n            transforms=['Affine'],\n            transform_parameters=[[0.1]],\n            number_of_iterations=[[200]],\n            convergence_window_size=[10],\n            convergence_threshold=[1.e-9],\n            sampling_strategy=['Random', 'Random'],\n            smoothing_sigmas=[[2]],\n            sigma_units=['mm', 'mm', 'mm'],\n            shrink_factors=[[2]],\n            sampling_percentage=[0.2],\n            use_histogram_matching=[True]\n        ),\n        name=f\"norm_{pipe_num}\",\n        n_procs=cfg.pipeline_setup['system_config']['num_OMP_threads'],\n    )\n\n    node, out = strat_pool.get_data('FSL-AFNI-bold-ref')\n    wf.connect(node, out, norm, 'fixed_image')\n\n    map_brainmask = pe.Node(\n        ants.ApplyTransforms(\n            interpolation=\"BSpline\",\n            float=True,\n        ),\n        name=f\"map_brainmask_{pipe_num}\",\n    )\n\n    # Use the higher resolution and probseg for numerical stability in rounding\n    node, out = strat_pool.get_data('FSL-AFNI-brain-probseg')\n    wf.connect(node, out, map_brainmask, 'input_image')\n\n    binarize_mask = pe.Node(interface=fsl.maths.MathsCommand(),\n                            name=f'binarize_mask_{pipe_num}')\n    binarize_mask.inputs.args = '-thr 0.85 -bin'\n\n    # Dilate pre_mask\n    pre_dilate = pe.Node(\n        fsl.DilateImage(\n            operation=\"max\",\n            kernel_shape=\"sphere\",\n            kernel_size=3.0,\n            internal_datatype=\"char\",\n        ),\n        name=f\"pre_mask_dilate_{pipe_num}\",\n    )\n\n    # Fix precision errors\n    # https://github.com/ANTsX/ANTs/wiki/Inputs-do-not-occupy-the-same-physical-space#fixing-precision-errors\n    print_header = pe.Node(PrintHeader(what_information=4),\n                           name=f'print_header_{pipe_num}')\n    set_direction = pe.Node(SetDirectionByMatrix(),\n                            name=f'set_direction_{pipe_num}')\n\n    # Run N4 normally, force num_threads=1 for stability (images are\n    # small, no need for >1)\n    n4_correct = pe.Node(\n        ants.N4BiasFieldCorrection(\n            dimension=3, copy_header=True, bspline_fitting_distance=200\n        ),\n        shrink_factor=2,\n        rescale_intensities = True,\n        name=f\"n4_correct_{pipe_num}\",\n        n_procs=1,\n    )\n\n    skullstrip_first_pass = pe.Node(\n        fsl.BET(frac=0.2, mask=True, functional=False),\n        name=f'skullstrip_first_pass_{pipe_num}')\n\n    bet_dilate = pe.Node(\n        fsl.DilateImage(operation='max', kernel_shape='sphere',\n                        kernel_size=6.0, internal_datatype='char'),\n        name=f'skullstrip_first_dilate_{pipe_num}')\n\n    bet_mask = pe.Node(fsl.ApplyMask(), name=f'skullstrip_first_mask_'\n                                             f'{pipe_num}')\n\n    unifize = pe.Node(afni_utils.Unifize(t2=True, outputtype='NIFTI_GZ',\n                                         args='-clfrac 0.2 -rbt 18.3 65.0 90.0',\n                                         out_file=\"uni.nii.gz\"),\n                      name=f'unifize_{pipe_num}')\n\n    skullstrip_second_pass = pe.Node(\n        preprocess.Automask(dilate=1, outputtype='NIFTI_GZ'),\n        name=f'skullstrip_second_pass_{pipe_num}')\n\n    combine_masks = pe.Node(fsl.BinaryMaths(operation='mul'),\n                            name=f'combine_masks_{pipe_num}')\n\n    apply_mask = pe.Node(fsl.ApplyMask(),\n                         name=f'extract_ref_brain_bold_{pipe_num}')\n\n    node, out = strat_pool.get_data([\"motion-basefile\"])\n\n    wf.connect([(node, init_aff, [(out, \"moving_image\")]),\n                (node, map_brainmask, [(out, \"reference_image\")]),\n                (node, norm, [(out, \"moving_image\")]),\n                (init_aff, norm, [\n                    (\"output_transform\", \"initial_moving_transform\")]),\n                (norm, map_brainmask, [\n                    (\"reverse_invert_flags\", \"invert_transform_flags\"),\n                    (\"reverse_transforms\", \"transforms\"),\n                ]),\n                (map_brainmask, binarize_mask, [(\"output_image\", \"in_file\")]),\n                (binarize_mask, pre_dilate, [(\"out_file\", \"in_file\")]),\n                (pre_dilate, print_header, [(\"out_file\", \"image\")]),\n                (print_header, set_direction, [(\"header\", \"direction\")]),\n                (node, set_direction, [(out, \"infile\"), (out, \"outfile\")]),\n                (set_direction, n4_correct, [(\"outfile\", \"mask_image\")]),\n                (node, n4_correct, [(out, \"input_image\")]),\n                (n4_correct, skullstrip_first_pass,\n                 [('output_image', 'in_file')]),\n                (skullstrip_first_pass, bet_dilate,\n                 [('mask_file', 'in_file')]),\n                (bet_dilate, bet_mask, [('out_file', 'mask_file')]),\n                (skullstrip_first_pass, bet_mask, [('out_file', 'in_file')]),\n                (bet_mask, unifize, [('out_file', 'in_file')]),\n                (unifize, skullstrip_second_pass, [('out_file', 'in_file')]),\n                (skullstrip_first_pass, combine_masks,\n                 [('mask_file', 'in_file')]),\n                (skullstrip_second_pass, combine_masks,\n                 [('out_file', 'operand_file')]),\n                (unifize, apply_mask, [('out_file', 'in_file')]),\n                (combine_masks, apply_mask, [('out_file', 'mask_file')]),\n                ])\n\n    outputs = {\n        'space-bold_desc-brain_mask': (combine_masks, 'out_file'),\n        'desc-ref_bold': (apply_mask, 'out_file')\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "bold_mask_anatomical_refined",
    "file": "CPAC/func_preproc/func_preproc.py",
    "line_number": 1096,
    "decorator_args": {
      "name": "bold_mask_anatomical_refined",
      "switch": [
        [
          "functional_preproc",
          "run"
        ],
        [
          "functional_preproc",
          "func_masking",
          "run"
        ]
      ],
      "option_key": [
        "functional_preproc",
        "func_masking",
        "using"
      ],
      "option_val": "Anatomical_Refined",
      "inputs": [
        [
          "bold",
          "desc-preproc_bold"
        ],
        [
          "desc-brain_T1w",
          [
            "space-T1w_desc-brain_mask",
            "space-T1w_desc-acpcbrain_mask"
          ]
        ]
      ],
      "outputs": [
        "space-bold_desc-brain_mask"
      ]
    },
    "docstring": null,
    "source_code": "def bold_mask_anatomical_refined(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    # binarize anat mask, in case it is not a binary mask.\n    anat_brain_mask_bin = pe.Node(interface=fsl.ImageMaths(),\n                                  name=f'anat_brain_mask_bin_{pipe_num}')\n    anat_brain_mask_bin.inputs.op_string = '-bin'\n\n    node, out = strat_pool.get_data(['space-T1w_desc-brain_mask',\n                                     'space-T1w_desc-acpcbrain_mask'])\n    wf.connect(node, out, anat_brain_mask_bin, 'in_file')\n\n    # fill holes of anat mask\n    anat_mask_filled = pe.Node(interface=afni.MaskTool(),\n                               name=f'anat_brain_mask_filled_{pipe_num}')\n    anat_mask_filled.inputs.fill_holes = True\n    anat_mask_filled.inputs.outputtype = 'NIFTI_GZ'\n\n    wf.connect(anat_brain_mask_bin, 'out_file',\n               anat_mask_filled, 'in_file')\n\n    # init_bold_mask : input raw func\n    init_bold_mask = anat_refined_mask(init_bold_mask=True,\n                                       wf_name=f'init_bold_mask_{pipe_num}')\n\n    func_deoblique = pe.Node(interface=afni_utils.Refit(),\n                             name=f'raw_func_deoblique_{pipe_num}')\n    func_deoblique.inputs.deoblique = True\n\n    node, out = strat_pool.get_data('bold')\n    wf.connect(node, out, func_deoblique, 'in_file')\n\n    func_reorient = pe.Node(interface=afni_utils.Resample(),\n                            name=f'raw_func_reorient_{pipe_num}',\n                            mem_gb=0,\n                            mem_x=(0.0115, 'in_file', 't'))\n\n    func_reorient.inputs.orientation = 'RPI'\n    func_reorient.inputs.outputtype = 'NIFTI_GZ'\n\n    wf.connect(func_deoblique, 'out_file',\n               func_reorient, 'in_file')\n\n    wf.connect(func_reorient, 'out_file',\n               init_bold_mask, 'inputspec.func')\n\n    wf.connect(anat_mask_filled, 'out_file',\n               init_bold_mask, 'inputspec.anatomical_brain_mask')\n\n    node, out = strat_pool.get_data('desc-brain_T1w')\n    wf.connect(node, out, init_bold_mask, 'inputspec.anat_brain')\n\n    # dilate init func brain mask\n    func_tmp_brain_mask = pe.Node(interface=fsl.ImageMaths(),\n                                  name=f'func_tmp_brain_mask_dil_{pipe_num}')\n    func_tmp_brain_mask.inputs.op_string = '-dilM'\n\n    wf.connect(init_bold_mask, 'outputspec.func_brain_mask',\n               func_tmp_brain_mask, 'in_file')\n\n    # refined_bold_mask : input motion corrected func\n    refined_bold_mask = anat_refined_mask(init_bold_mask=False,\n                                          wf_name='refined_bold_mask'\n                                                  f'_{pipe_num}')\n\n    node, out = strat_pool.get_data([\"desc-preproc_bold\",\n                                     \"bold\"])\n    wf.connect(node, out, refined_bold_mask, 'inputspec.func')\n\n    node, out = strat_pool.get_data('desc-brain_T1w')\n    wf.connect(node, out, refined_bold_mask, 'inputspec.anat_brain')\n\n    wf.connect(func_tmp_brain_mask, 'out_file',\n               refined_bold_mask, 'inputspec.init_func_brain_mask')\n\n    # dilate anatomical mask\n    if cfg.functional_preproc['func_masking']['Anatomical_Refined'][\n        'anatomical_mask_dilation']:\n        anat_mask_dilate = pe.Node(interface=afni.MaskTool(),\n                                   name=f'anat_mask_dilate_{pipe_num}')\n        anat_mask_dilate.inputs.dilate_inputs = '1'\n        anat_mask_dilate.inputs.outputtype = 'NIFTI_GZ'\n\n        wf.connect(anat_mask_filled, 'out_file',\n                   anat_mask_dilate, 'in_file')\n        wf.connect(anat_mask_dilate, 'out_file',\n                   refined_bold_mask, 'inputspec.anatomical_brain_mask')\n\n    else:\n        wf.connect(anat_mask_filled, 'out_file',\n                   refined_bold_mask, 'inputspec.anatomical_brain_mask')\n\n    # get final func mask\n    func_mask_final = pe.Node(interface=fsl.MultiImageMaths(),\n                              name=f'func_mask_final_{pipe_num}')\n    func_mask_final.inputs.op_string = \"-mul %s\"\n\n    wf.connect(func_tmp_brain_mask, 'out_file',\n               func_mask_final, 'in_file')\n\n    wf.connect(refined_bold_mask, 'outputspec.func_brain_mask',\n               func_mask_final, 'operand_files')\n\n    outputs = {\n        'space-bold_desc-brain_mask': (func_mask_final, 'out_file')\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "bold_mask_anatomical_based",
    "file": "CPAC/func_preproc/func_preproc.py",
    "line_number": 1214,
    "decorator_args": {
      "name": "bold_mask_anatomical_based",
      "switch": [
        [
          "functional_preproc",
          "run"
        ],
        [
          "functional_preproc",
          "func_masking",
          "run"
        ]
      ],
      "option_key": [
        "functional_preproc",
        "func_masking",
        "using"
      ],
      "option_val": "Anatomical_Based",
      "inputs": [
        "desc-preproc_bold",
        [
          "desc-brain_T1w",
          [
            "desc-preproc_T1w",
            "desc-reorient_T1w",
            "T1w"
          ]
        ]
      ],
      "outputs": [
        "space-bold_desc-brain_mask"
      ]
    },
    "docstring": "Generate the BOLD mask by basing it off of the anatomical brain mask.\nAdapted from `DCAN Lab's BOLD mask method from the ABCD pipeline <https://github.com/DCAN-Labs/DCAN-HCP/blob/master/fMRIVolume/scripts/DistortionCorrectionAndEPIToT1wReg_FLIRTBBRAndFreeSurferBBRbased.sh>`_.",
    "source_code": "def bold_mask_anatomical_based(wf, cfg, strat_pool, pipe_num, opt=None):\n    '''Generate the BOLD mask by basing it off of the anatomical brain mask.\n    Adapted from `DCAN Lab's BOLD mask method from the ABCD pipeline <https://github.com/DCAN-Labs/DCAN-HCP/blob/master/fMRIVolume/scripts/DistortionCorrectionAndEPIToT1wReg_FLIRTBBRAndFreeSurferBBRbased.sh>`_.\n    '''\n\n    # 0. Take single volume of func\n    func_single_volume = pe.Node(interface=afni.Calc(),\n                                 name='func_single_volume')\n\n    func_single_volume.inputs.set(\n        expr='a',\n        single_idx=1,\n        outputtype='NIFTI_GZ'\n    )\n\n    node, out = strat_pool.get_data(\"desc-preproc_bold\")\n    wf.connect(node, out, func_single_volume, 'in_file_a')\n\n    # 1. Register func head to anat head to get func2anat matrix\n    linear_reg_func_to_anat = pe.Node(interface=fsl.FLIRT(),\n                                      name='func_to_anat_linear_reg')\n    linear_reg_func_to_anat.inputs.dof = 6\n    linear_reg_func_to_anat.inputs.interp = 'spline'\n    linear_reg_func_to_anat.inputs.searchr_x = [30, 30]\n    linear_reg_func_to_anat.inputs.searchr_y = [30, 30]\n    linear_reg_func_to_anat.inputs.searchr_z = [30, 30]\n\n    wf.connect(func_single_volume, 'out_file',\n               linear_reg_func_to_anat, 'in_file')\n\n    node, out = strat_pool.get_data([\"desc-preproc_T1w\", \"desc-reorient_T1w\",\n                                     \"T1w\"])\n    wf.connect(node, out, linear_reg_func_to_anat, 'reference')\n\n    # 2. Inverse func to anat affine, to get anat-to-func transform\n    inv_func_to_anat_affine = pe.Node(interface=fsl.ConvertXFM(),\n                                      name='inv_func2anat_affine')\n    inv_func_to_anat_affine.inputs.invert_xfm = True\n\n    wf.connect(linear_reg_func_to_anat, 'out_matrix_file',\n               inv_func_to_anat_affine, 'in_file')\n\n    # 3. get BOLD mask\n    # 3.1 Apply anat-to-func transform to transfer anatomical brain to functional space\n    reg_anat_brain_to_func = pe.Node(interface=fsl.ApplyWarp(),\n                                     name='reg_anat_brain_to_func')\n    reg_anat_brain_to_func.inputs.interp = 'nn'\n    reg_anat_brain_to_func.inputs.relwarp = True\n\n    node, out = strat_pool.get_data(\"desc-brain_T1w\")\n    wf.connect(node, out, reg_anat_brain_to_func, 'in_file')\n\n    node, out = strat_pool.get_data(\"desc-preproc_bold\")\n    wf.connect(node, out, reg_anat_brain_to_func, 'ref_file')\n\n    wf.connect(inv_func_to_anat_affine, 'out_file',\n               reg_anat_brain_to_func, 'premat')\n\n    # 3.2 Binarize transfered image\n    func_mask_bin = pe.Node(interface=fsl.ImageMaths(),\n                            name='func_mask_bin')\n    func_mask_bin.inputs.op_string = '-abs -bin'\n\n    wf.connect(reg_anat_brain_to_func, 'out_file',\n               func_mask_bin, 'in_file')\n\n    # 3.3 Fill holes to get BOLD mask\n    func_mask_fill_holes = pe.Node(interface=afni.MaskTool(),\n                                   name='func_mask_fill_holes')\n    func_mask_fill_holes.inputs.fill_holes = True\n    func_mask_fill_holes.inputs.outputtype = 'NIFTI_GZ'\n\n    wf.connect(func_mask_bin, 'out_file',\n               func_mask_fill_holes, 'in_file')\n\n    outputs = {\n        'space-bold_desc-brain_mask': (func_mask_fill_holes, 'out_file')\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "bold_mask_anatomical_resampled",
    "file": "CPAC/func_preproc/func_preproc.py",
    "line_number": 1306,
    "decorator_args": {
      "name": "bold_mask_anatomical_resampled",
      "switch": [
        [
          "functional_preproc",
          "run"
        ],
        [
          "functional_preproc",
          "func_masking",
          "run"
        ]
      ],
      "option_key": [
        "functional_preproc",
        "func_masking",
        "using"
      ],
      "option_val": "Anatomical_Resampled",
      "inputs": [
        "desc-preproc_bold",
        "T1w-template-funcreg",
        "space-template_desc-preproc_T1w",
        "space-template_desc-T1w_mask"
      ],
      "outputs": [
        "space-template_res-bold_desc-brain_T1w",
        "space-template_desc-bold_mask",
        "space-bold_desc-brain_mask"
      ]
    },
    "docstring": "Resample anatomical brain mask in standard space to get BOLD brain mask in standard space\nAdapted from `DCAN Lab's BOLD mask method from the ABCD pipeline <https://github.com/DCAN-Labs/DCAN-HCP/blob/master/fMRIVolume/scripts/OneStepResampling.sh#L121-L132>`_.",
    "source_code": "def bold_mask_anatomical_resampled(wf, cfg, strat_pool, pipe_num, opt=None):\n    '''Resample anatomical brain mask in standard space to get BOLD brain mask in standard space\n    Adapted from `DCAN Lab's BOLD mask method from the ABCD pipeline <https://github.com/DCAN-Labs/DCAN-HCP/blob/master/fMRIVolume/scripts/OneStepResampling.sh#L121-L132>`_.\n    '''\n\n    # applywarp --rel --interp=spline -i ${T1wImage} -r ${ResampRefIm} --premat=$FSLDIR/etc/flirtsch/ident.mat -o ${WD}/${T1wImageFile}.${FinalfMRIResolution}\n    anat_brain_to_func_res = pe.Node(interface=fsl.ApplyWarp(),\n                                     name=f'resample_anat_brain_in_standard_{pipe_num}')\n\n    anat_brain_to_func_res.inputs.interp = 'spline'\n    anat_brain_to_func_res.inputs.premat = cfg.registration_workflows[\n        'anatomical_registration']['registration']['FSL-FNIRT']['identity_matrix']\n\n    node, out = strat_pool.get_data('space-template_desc-preproc_T1w')\n    wf.connect(node, out, anat_brain_to_func_res, 'in_file')\n\n    node, out = strat_pool.get_data('T1w-template-funcreg')\n    wf.connect(node, out, anat_brain_to_func_res, 'ref_file')\n\n    # Create brain masks in this space from the FreeSurfer output (changing resolution)\n    # applywarp --rel --interp=nn -i ${FreeSurferBrainMask}.nii.gz -r ${WD}/${T1wImageFile}.${FinalfMRIResolution} --premat=$FSLDIR/etc/flirtsch/ident.mat -o ${WD}/${FreeSurferBrainMaskFile}.${FinalfMRIResolution}.nii.gz\n    anat_brain_mask_to_func_res = pe.Node(interface=fsl.ApplyWarp(),\n                                          name=f'resample_anat_brain_mask_in_standard_{pipe_num}')\n\n    anat_brain_mask_to_func_res.inputs.interp = 'nn'\n    anat_brain_mask_to_func_res.inputs.premat = cfg.registration_workflows[\n        'anatomical_registration']['registration']['FSL-FNIRT']['identity_matrix']\n\n    node, out = strat_pool.get_data('space-template_desc-T1w_mask')\n    wf.connect(node, out, anat_brain_mask_to_func_res, 'in_file')\n\n    wf.connect(anat_brain_to_func_res, 'out_file',\n               anat_brain_mask_to_func_res, 'ref_file')\n\n    # Resample func mask in template space back to native space\n    func_mask_template_to_native = pe.Node(\n        interface=afni.Resample(),\n        name=f'resample_func_mask_to_native_{pipe_num}',\n        mem_gb=0,\n        mem_x=(0.0115, 'in_file', 't'))\n    func_mask_template_to_native.inputs.resample_mode = 'NN'\n    func_mask_template_to_native.inputs.outputtype = 'NIFTI_GZ'\n\n    wf.connect(anat_brain_mask_to_func_res, 'out_file',\n        func_mask_template_to_native, 'in_file')\n\n    node, out = strat_pool.get_data(\"desc-preproc_bold\")\n    wf.connect(node, out, func_mask_template_to_native, 'master')\n\n    outputs = {\n        'space-template_res-bold_desc-brain_T1w': (anat_brain_to_func_res, 'out_file'),\n        'space-template_desc-bold_mask': (anat_brain_mask_to_func_res, 'out_file'),\n        'space-bold_desc-brain_mask': (func_mask_template_to_native, 'out_file')\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "bold_mask_ccs",
    "file": "CPAC/func_preproc/func_preproc.py",
    "line_number": 1374,
    "decorator_args": {
      "name": "bold_mask_ccs",
      "switch": [
        [
          "functional_preproc",
          "run"
        ],
        [
          "functional_preproc",
          "func_masking",
          "run"
        ]
      ],
      "option_key": [
        "functional_preproc",
        "func_masking",
        "using"
      ],
      "option_val": "CCS_Anatomical_Refined",
      "inputs": [
        [
          "desc-motion_bold",
          "desc-preproc_bold",
          "bold"
        ],
        "desc-brain_T1w",
        [
          "desc-preproc_T1w",
          "desc-reorient_T1w",
          "T1w"
        ]
      ],
      "outputs": [
        "space-bold_desc-brain_mask",
        "desc-ref_bold"
      ]
    },
    "docstring": "Generate the BOLD mask by basing it off of the anatomical brain.\nAdapted from `the BOLD mask method from the CCS pipeline <https://github.com/TingsterX/CCS/blob/master/ccs_01_funcpreproc.sh#L89-L110>`_.",
    "source_code": "def bold_mask_ccs(wf, cfg, strat_pool, pipe_num, opt=None):\n    '''Generate the BOLD mask by basing it off of the anatomical brain.\n    Adapted from `the BOLD mask method from the CCS pipeline <https://github.com/TingsterX/CCS/blob/master/ccs_01_funcpreproc.sh#L89-L110>`_.\n    '''\n\n    # Run 3dAutomask to generate func initial mask\n    func_tmp_brain_mask = pe.Node(interface=preprocess.Automask(),\n                                  name=f'func_tmp_brain_mask_AFNI_{pipe_num}')\n    func_tmp_brain_mask.inputs.dilate = 1\n    func_tmp_brain_mask.inputs.outputtype = 'NIFTI_GZ'\n\n    node, out = strat_pool.get_data([\"desc-motion_bold\",\n                                     \"desc-preproc_bold\",\n                                     \"bold\"])\n    wf.connect(node, out, func_tmp_brain_mask, 'in_file')\n\n    # Extract 8th volume as func ROI\n    func_roi = pe.Node(interface=fsl.ExtractROI(),\n                       name=f'extract_func_roi_{pipe_num}')\n    func_roi.inputs.t_min = 7\n    func_roi.inputs.t_size = 1\n\n    node, out = strat_pool.get_data([\"desc-motion_bold\",\n                                     \"desc-preproc_bold\",\n                                     \"bold\"])\n    wf.connect(node, out, func_roi, 'in_file')\n\n    # Apply func initial mask on func ROI volume\n    func_tmp_brain = pe.Node(interface=fsl.maths.ApplyMask(),\n                             name=f'get_func_tmp_brain_{pipe_num}')\n\n    wf.connect(func_roi, 'roi_file',\n               func_tmp_brain, 'in_file')\n\n    wf.connect(func_tmp_brain_mask, 'out_file',\n               func_tmp_brain, 'mask_file')\n\n    # Register func tmp brain to anat brain to get func2anat matrix\n    reg_func_to_anat = pe.Node(interface=fsl.FLIRT(),\n                               name=f'func_to_anat_linear_reg_{pipe_num}')\n    reg_func_to_anat.inputs.interp = 'trilinear'\n    reg_func_to_anat.inputs.cost = 'corratio'\n    reg_func_to_anat.inputs.dof = 6\n\n    wf.connect(func_tmp_brain, 'out_file',\n               reg_func_to_anat, 'in_file')\n\n    node, out = strat_pool.get_data(\"desc-brain_T1w\")\n    wf.connect(node, out, reg_func_to_anat, 'reference')\n\n    # Inverse func2anat matrix\n    inv_func_to_anat_affine = pe.Node(interface=fsl.ConvertXFM(),\n                                      name=f'inv_func2anat_affine_{pipe_num}')\n    inv_func_to_anat_affine.inputs.invert_xfm = True\n\n    wf.connect(reg_func_to_anat, 'out_matrix_file',\n               inv_func_to_anat_affine, 'in_file')\n\n    # Transform anat brain to func space\n    reg_anat_brain_to_func = pe.Node(interface=fsl.FLIRT(),\n                                     name=f'reg_anat_brain_to_func_{pipe_num}')\n    reg_anat_brain_to_func.inputs.apply_xfm = True\n    reg_anat_brain_to_func.inputs.interp = 'trilinear'\n\n    node, out = strat_pool.get_data(\"desc-brain_T1w\")\n    wf.connect(node, out, reg_anat_brain_to_func, 'in_file')\n\n    wf.connect(func_roi, 'roi_file',\n               reg_anat_brain_to_func, 'reference')\n\n    wf.connect(inv_func_to_anat_affine, 'out_file',\n               reg_anat_brain_to_func, 'in_matrix_file')\n\n    # Binarize and dilate anat brain in func space\n    bin_anat_brain_in_func = pe.Node(interface=fsl.ImageMaths(),\n                                     name=f'bin_anat_brain_in_func_{pipe_num}')\n    bin_anat_brain_in_func.inputs.op_string = '-bin -dilM'\n\n    wf.connect(reg_anat_brain_to_func, 'out_file',\n               bin_anat_brain_in_func, 'in_file')\n\n    # Binarize detectable func signals\n    bin_func = pe.Node(interface=fsl.ImageMaths(),\n                                     name=f'bin_func_{pipe_num}')\n    bin_func.inputs.op_string = '-Tstd -bin'\n\n    node, out = strat_pool.get_data([\"desc-motion_bold\",\n                                     \"desc-preproc_bold\",\n                                     \"bold\"])\n    wf.connect(node, out, bin_func, 'in_file')\n\n    # Take intersection of masks\n    merge_func_mask = pe.Node(util.Merge(2),\n                              name=f'merge_func_mask_{pipe_num}')\n\n    wf.connect(func_tmp_brain_mask, 'out_file',\n               merge_func_mask, 'in1')\n\n    wf.connect(bin_anat_brain_in_func, 'out_file',\n               merge_func_mask, 'in2')\n\n    intersect_mask = pe.Node(interface=fsl.MultiImageMaths(),\n                             name=f'intersect_mask_{pipe_num}')\n    intersect_mask.inputs.op_string = '-mul %s -mul %s'\n    intersect_mask.inputs.output_datatype = 'char'\n\n    wf.connect(bin_func, 'out_file',\n               intersect_mask, 'in_file')\n\n    wf.connect(merge_func_mask, 'out',\n               intersect_mask, 'operand_files')\n\n    # this is the func input for coreg in ccs\n    # TODO evaluate if it's necessary to use this brain\n    example_func_brain = pe.Node(interface=fsl.maths.ApplyMask(),\n                                 name=f'get_example_func_brain_{pipe_num}')\n\n    wf.connect(func_roi, 'roi_file',\n               example_func_brain, 'in_file')\n\n    wf.connect(intersect_mask, 'out_file',\n               example_func_brain, 'mask_file')\n\n    outputs = {\n        'space-bold_desc-brain_mask': (intersect_mask, 'out_file'),\n        'desc-ref_bold': (example_func_brain, 'out_file')\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "bold_masking",
    "file": "CPAC/func_preproc/func_preproc.py",
    "line_number": 1514,
    "decorator_args": {
      "name": "bold_masking",
      "switch": [
        [
          "functional_preproc",
          "run"
        ],
        [
          "functional_preproc",
          "func_masking",
          "run"
        ],
        [
          "functional_preproc",
          "func_masking",
          "apply_func_mask_in_native_space"
        ]
      ],
      "inputs": [
        [
          "desc-preproc_bold",
          "space-bold_desc-brain_mask"
        ]
      ],
      "outputs": "!UNSUPPORTED_TYPE:Dict!"
    },
    "docstring": null,
    "source_code": "def bold_masking(wf, cfg, strat_pool, pipe_num, opt=None):\n    func_edge_detect = pe.Node(interface=afni_utils.Calc(),\n                               name=f'func_extract_brain_{pipe_num}')\n\n    func_edge_detect.inputs.expr = 'a*b'\n    func_edge_detect.inputs.outputtype = 'NIFTI_GZ'\n\n    node, out = strat_pool.get_data(\"desc-preproc_bold\")\n    wf.connect(node, out, func_edge_detect, 'in_file_a')\n\n    node, out = strat_pool.get_data(\"space-bold_desc-brain_mask\")\n    wf.connect(node, out, func_edge_detect, 'in_file_b')\n\n    outputs = {\n        'desc-preproc_bold': (func_edge_detect, 'out_file'),\n        'desc-brain_bold': (func_edge_detect, 'out_file')\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "func_mean",
    "file": "CPAC/func_preproc/func_preproc.py",
    "line_number": 1541,
    "decorator_args": {
      "name": "func_mean",
      "switch": [
        [
          "functional_preproc",
          "run"
        ],
        [
          "functional_preproc",
          "generate_func_mean",
          "run"
        ]
      ],
      "inputs": [
        "desc-preproc_bold"
      ],
      "outputs": [
        "desc-mean_bold"
      ]
    },
    "docstring": null,
    "source_code": "def func_mean(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    func_mean = pe.Node(interface=afni_utils.TStat(),\n                        name=f'func_mean_{pipe_num}')\n\n    func_mean.inputs.options = '-mean'\n    func_mean.inputs.outputtype = 'NIFTI_GZ'\n\n    node, out = strat_pool.get_data(\"desc-preproc_bold\")\n    wf.connect(node, out, func_mean, 'in_file')\n\n    outputs = {\n        'desc-mean_bold': (func_mean, 'out_file')\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "func_normalize",
    "file": "CPAC/func_preproc/func_preproc.py",
    "line_number": 1565,
    "decorator_args": {
      "name": "func_normalize",
      "switch": [
        [
          "functional_preproc",
          "run"
        ],
        [
          "functional_preproc",
          "normalize_func",
          "run"
        ]
      ],
      "inputs": [
        "desc-preproc_bold"
      ],
      "outputs": [
        "desc-preproc_bold"
      ]
    },
    "docstring": null,
    "source_code": "def func_normalize(wf, cfg, strat_pool, pipe_num, opt=None):\n    func_normalize = pe.Node(interface=fsl.ImageMaths(),\n                             name=f'func_normalize_{pipe_num}',\n                             mem_gb=0.7,\n                             mem_x=(4538494663498653 /\n                                    604462909807314587353088, 'in_file'))\n    func_normalize.inputs.op_string = '-ing 10000'\n    func_normalize.inputs.out_data_type = 'float'\n\n    node, out = strat_pool.get_data(\"desc-preproc_bold\")\n    wf.connect(node, out, func_normalize, 'in_file')\n\n    outputs = {\n        'desc-preproc_bold': (func_normalize, 'out_file')\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "func_mask_normalize",
    "file": "CPAC/func_preproc/func_preproc.py",
    "line_number": 1591,
    "decorator_args": {
      "name": "func_mask_normalize",
      "config": [
        "functional_preproc"
      ],
      "switch": [
        "run"
      ],
      "inputs": [
        [
          "desc-preproc_bold",
          "space-bold_desc-brain_mask"
        ]
      ],
      "outputs": [
        "space-bold_desc-brain_mask"
      ]
    },
    "docstring": null,
    "source_code": "def func_mask_normalize(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    func_mask_normalize = pe.Node(interface=fsl.ImageMaths(),\n                                  name=f'func_mask_normalize_{pipe_num}',\n                                  mem_gb=0.7,\n                                  mem_x=(4538494663498653 /\n                                         604462909807314587353088, 'in_file'))\n    func_mask_normalize.inputs.op_string = '-Tmin -bin'\n    func_mask_normalize.inputs.out_data_type = 'char'\n\n    node, out = strat_pool.get_data(\"desc-preproc_bold\")\n    wf.connect(node, out, func_mask_normalize, 'in_file')\n\n    outputs = {\n        'space-bold_desc-brain_mask': (func_mask_normalize, 'out_file')\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "register_FSL_anat_to_template",
    "file": "CPAC/registration/registration.py",
    "line_number": 2012,
    "decorator_args": {
      "name": "register_FSL_anat_to_template",
      "config": [
        "registration_workflows",
        "anatomical_registration"
      ],
      "switch": [
        "run"
      ],
      "option_key": [
        "registration",
        "using"
      ],
      "option_val": [
        "FSL",
        "FSL-linear"
      ],
      "inputs": [
        [
          [
            "desc-preproc_T1w",
            "space-longitudinal_desc-reorient_T1w"
          ],
          [
            "desc-brain_T1w",
            "space-longitudinal_desc-brain_T1w"
          ]
        ],
        "T1w-template",
        "T1w-brain-template",
        "FNIRT-T1w-template",
        "FNIRT-T1w-brain-template",
        "template-ref-mask"
      ],
      "outputs": "!UNSUPPORTED_TYPE:Dict!"
    },
    "docstring": null,
    "source_code": "def register_FSL_anat_to_template(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    fsl, outputs = FSL_registration_connector(f'register_{opt}_anat_to_'\n                                              f'template_{pipe_num}', cfg,\n                                              orig='T1w', opt=opt)\n\n    fsl.inputs.inputspec.interpolation = cfg.registration_workflows[\n        'anatomical_registration']['registration']['FSL-FNIRT'][\n        'interpolation']\n\n    fsl.inputs.inputspec.fnirt_config = cfg.registration_workflows[\n        'anatomical_registration']['registration']['FSL-FNIRT'][\n        'fnirt_config']\n\n    connect, brain = \\\n        strat_pool.get_data(['desc-brain_T1w',\n                             'space-longitudinal_desc-brain_T1w'],\n                            report_fetched=True)\n    node, out = connect\n    wf.connect(node, out, fsl, 'inputspec.input_brain')\n\n    if cfg.registration_workflows['anatomical_registration']['registration']['FSL-FNIRT']['ref_resolution'] ==  \\\n        cfg.registration_workflows['anatomical_registration']['resolution_for_anat']:\n\n        node, out = strat_pool.get_data('T1w-brain-template')\n        wf.connect(node, out, fsl, 'inputspec.reference_brain')\n\n        node, out = strat_pool.get_data('T1w-template')\n        wf.connect(node, out, fsl, 'inputspec.reference_head')\n    else:\n        node, out = strat_pool.get_data('FNIRT-T1w-brain-template')\n        wf.connect(node, out, fsl, 'inputspec.reference_brain')\n\n        node, out = strat_pool.get_data('FNIRT-T1w-template')\n        wf.connect(node, out, fsl, 'inputspec.reference_head')\n\n    node, out = strat_pool.get_data([\"desc-preproc_T1w\",\n                                     \"space-longitudinal_desc-reorient_T1w\"])\n    wf.connect(node, out, fsl, 'inputspec.input_head')\n\n    node, out = strat_pool.get_data('template-ref-mask')\n    wf.connect(node, out, fsl, 'inputspec.reference_mask')\n\n    if 'space-longitudinal' in brain:\n        for key in outputs.keys():\n            if 'from-T1w' in key:\n                new_key = key.replace('from-T1w', 'from-longitudinal')\n                outputs[new_key] = outputs[key]\n                del outputs[key]\n            if 'to-T1w' in key:\n                new_key = key.replace('to-T1w', 'to-longitudinal')\n                outputs[new_key] = outputs[key]\n                del outputs[key]\n\n    return (wf, outputs)"
  },
  {
    "name": "register_symmetric_FSL_anat_to_template",
    "file": "CPAC/registration/registration.py",
    "line_number": 2108,
    "decorator_args": {
      "name": "register_symmetric_FSL_anat_to_template",
      "config": [
        "registration_workflows",
        "anatomical_registration"
      ],
      "switch": [
        "run"
      ],
      "option_key": [
        "registration",
        "using"
      ],
      "option_val": [
        "FSL",
        "FSL-linear"
      ],
      "inputs": [
        [
          [
            "desc-preproc_T1w",
            "space-longitudinal_desc-reorient_T1w"
          ],
          [
            "desc-brain_T1w",
            "space-longitudinal_desc-brain_T1w"
          ]
        ],
        "T1w-template-symmetric",
        "T1w-brain-template-symmetric",
        "dilated-symmetric-brain-mask"
      ],
      "outputs": "!UNSUPPORTED_TYPE:Dict!"
    },
    "docstring": null,
    "source_code": "def register_symmetric_FSL_anat_to_template(wf, cfg, strat_pool, pipe_num,\n                                            opt=None):\n\n    fsl, outputs = FSL_registration_connector(f'register_{opt}_anat_to_'\n                                              f'template_symmetric_'\n                                              f'{pipe_num}', cfg, orig='T1w',\n                                              opt=opt, symmetric=True)\n\n    fsl.inputs.inputspec.interpolation = cfg.registration_workflows[\n        'anatomical_registration']['registration']['FSL-FNIRT'][\n        'interpolation']\n\n    fsl.inputs.inputspec.fnirt_config = cfg.registration_workflows[\n        'anatomical_registration']['registration']['FSL-FNIRT'][\n        'fnirt_config']\n\n    connect, brain = \\\n        strat_pool.get_data(['desc-brain_T1w',\n                             'space-longitudinal_desc-brain_T1w'],\n                            report_fetched=True)\n    node, out = connect\n    wf.connect(node, out, fsl, 'inputspec.input_brain')\n\n    node, out = strat_pool.get_data('T1w-brain-template-symmetric')\n    wf.connect(node, out, fsl, 'inputspec.reference_brain')\n\n    node, out = strat_pool.get_data([\"desc-preproc_T1w\",\n                                     \"space-longitudinal_desc-reorient_T1w\"])\n    wf.connect(node, out, fsl, 'inputspec.input_head')\n\n    node, out = strat_pool.get_data('T1w-template-symmetric')\n    wf.connect(node, out, fsl, 'inputspec.reference_head')\n\n    node, out = strat_pool.get_data('dilated-symmetric-brain-mask')\n    wf.connect(node, out, fsl, 'inputspec.reference_mask')\n\n    if 'space-longitudinal' in brain:\n        for key in outputs.keys():\n            if 'from-T1w' in key:\n                new_key = key.replace('from-T1w', 'from-longitudinal')\n                outputs[new_key] = outputs[key]\n                del outputs[key]\n            if 'to-T1w' in key:\n                new_key = key.replace('to-T1w', 'to-longitudinal')\n                outputs[new_key] = outputs[key]\n                del outputs[key]\n\n    return (wf, outputs)"
  },
  {
    "name": "register_FSL_EPI_to_template",
    "file": "CPAC/registration/registration.py",
    "line_number": 2182,
    "decorator_args": {
      "name": "register_FSL_EPI_to_template",
      "config": [
        "registration_workflows",
        "functional_registration",
        "EPI_registration"
      ],
      "switch": [
        "run"
      ],
      "option_key": "using",
      "option_val": [
        "FSL",
        "FSL-linear"
      ],
      "inputs": [
        [
          "sbref",
          "space-bold_desc-brain_mask"
        ],
        "EPI-template",
        "EPI-template-mask"
      ],
      "outputs": "!UNSUPPORTED_TYPE:Dict!"
    },
    "docstring": "Directly register the mean functional to an EPI template. No T1w\ninvolved.",
    "source_code": "def register_FSL_EPI_to_template(wf, cfg, strat_pool, pipe_num, opt=None):\n    '''Directly register the mean functional to an EPI template. No T1w\n    involved.\n    '''\n\n    fsl, outputs = FSL_registration_connector(f'register_{opt}_EPI_to_'\n                                              f'template_{pipe_num}', cfg,\n                                              orig='bold', opt=opt,\n                                              template='EPI')\n\n    fsl.inputs.inputspec.interpolation = cfg['registration_workflows'][\n        'functional_registration']['EPI_registration']['FSL-FNIRT'][\n        'interpolation']\n\n    fsl.inputs.inputspec.fnirt_config = cfg['registration_workflows'][\n        'functional_registration']['EPI_registration']['FSL-FNIRT'][\n        'fnirt_config']\n\n    node, out = strat_pool.get_data('sbref')\n    wf.connect(node, out, fsl, 'inputspec.input_brain')\n\n    node, out = strat_pool.get_data('EPI-template')\n    wf.connect(node, out, fsl, 'inputspec.reference_brain')\n\n    node, out = strat_pool.get_data('sbref')\n    wf.connect(node, out, fsl, 'inputspec.input_head')\n\n    node, out = strat_pool.get_data('EPI-template')\n    wf.connect(node, out, fsl, 'inputspec.reference_head')\n\n    node, out = strat_pool.get_data('EPI-template-mask')\n    wf.connect(node, out, fsl, 'inputspec.reference_mask')\n\n    return (wf, outputs)"
  },
  {
    "name": "register_ANTs_anat_to_template",
    "file": "CPAC/registration/registration.py",
    "line_number": 2319,
    "decorator_args": {
      "name": "register_ANTs_anat_to_template",
      "config": [
        "registration_workflows",
        "anatomical_registration"
      ],
      "switch": [
        "run"
      ],
      "option_key": [
        "registration",
        "using"
      ],
      "option_val": "ANTS",
      "inputs": [
        [
          [
            "desc-preproc_T1w",
            "space-longitudinal_desc-brain_T1w"
          ],
          [
            "space-T1w_desc-brain_mask",
            "space-longitudinal_desc-brain_mask",
            "space-T1w_desc-acpcbrain_mask"
          ],
          [
            "desc-restore_T1w",
            "desc-head_T1w",
            "desc-preproc_T1w",
            "space-longitudinal_desc-reorient_T1w"
          ],
          "space-template_desc-head_T1w",
          "space-template_desc-preproc_T1w"
        ],
        "T1w-template",
        "T1w-brain-template",
        "T1w-brain-template-mask",
        "label-lesion_mask"
      ],
      "outputs": "!UNSUPPORTED_TYPE:Dict!"
    },
    "docstring": null,
    "source_code": "def register_ANTs_anat_to_template(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    params = cfg.registration_workflows['anatomical_registration'][\n        'registration']['ANTs']['T1_registration']\n\n    ants_rc, outputs = ANTs_registration_connector('ANTS_T1_to_template_'\n                                                   f'{pipe_num}', cfg,\n                                                   params, orig='T1w')\n\n    ants_rc.inputs.inputspec.interpolation = cfg.registration_workflows[\n        'anatomical_registration']['registration']['ANTs']['interpolation']\n\n    connect, brain = \\\n        strat_pool.get_data(['desc-preproc_T1w',\n                             'space-longitudinal_desc-brain_T1w'],\n                            report_fetched=True)\n    node, out = connect\n    wf.connect(node, out, ants_rc, 'inputspec.input_brain')\n\n    t1w_brain_template = strat_pool.node_data('T1w-brain-template')\n    wf.connect(t1w_brain_template.node, t1w_brain_template.out,\n               ants_rc, 'inputspec.reference_brain')\n\n    # TODO check the order of T1w\n    node, out = strat_pool.get_data([\"desc-restore_T1w\", \"desc-head_T1w\",\n                                     \"desc-preproc_T1w\",\n                                     \"space-longitudinal_desc-reorient_T1w\"])\n    wf.connect(node, out, ants_rc, 'inputspec.input_head')\n\n\n    t1w_template = strat_pool.node_data('T1w-template')\n    wf.connect(t1w_template.node, t1w_template.out,\n               ants_rc, 'inputspec.reference_head')\n\n    brain_mask = strat_pool.node_data([\"space-T1w_desc-brain_mask\",\n                                       \"space-longitudinal_desc-brain_mask\",\n                                       \"space-T1w_desc-acpcbrain_mask\"])\n    wf.connect(brain_mask.node, brain_mask.out,\n               ants_rc, 'inputspec.input_mask')\n\n    if strat_pool.check_rpool('T1w-brain-template-mask'):\n        node, out = strat_pool.get_data('T1w-brain-template-mask')\n        wf.connect(node, out, ants_rc, 'inputspec.reference_mask')\n\n    if strat_pool.check_rpool('label-lesion_mask'):\n        node, out = strat_pool.get_data('label-lesion_mask')\n        wf.connect(node, out, ants_rc, 'inputspec.lesion_mask')\n\n    if 'space-longitudinal' in brain:\n        for key in outputs:\n            for direction in ['from', 'to']:\n                if f'{direction}-T1w' in key:\n                    new_key = key.replace(f'{direction}-T1w',\n                                          f'{direction}-longitudinal')\n                    outputs[new_key] = outputs[key]\n                    del outputs[key]\n\n    return (wf, outputs)"
  },
  {
    "name": "register_symmetric_ANTs_anat_to_template",
    "file": "CPAC/registration/registration.py",
    "line_number": 2443,
    "decorator_args": {
      "name": "register_symmetric_ANTs_anat_to_template",
      "config": [
        "registration_workflows",
        "anatomical_registration"
      ],
      "switch": [
        "run"
      ],
      "option_key": [
        "registration",
        "using"
      ],
      "option_val": "ANTS",
      "inputs": [
        [
          [
            "desc-preproc_T1w",
            "space-longitudinal_desc-brain_T1w"
          ],
          [
            "space-T1w_desc-brain_mask",
            "space-longitudinal_desc-brain_mask"
          ],
          [
            "desc-head_T1w",
            "desc-preproc_T1w",
            "space-longitudinal_desc-reorient_T1w"
          ]
        ],
        "T1w-template-symmetric",
        "T1w-brain-template-symmetric",
        "dilated-symmetric-brain-mask",
        "label-lesion_mask"
      ],
      "outputs": "!UNSUPPORTED_TYPE:Dict!"
    },
    "docstring": null,
    "source_code": "def register_symmetric_ANTs_anat_to_template(wf, cfg, strat_pool, pipe_num,\n                                             opt=None):\n\n    params = cfg.registration_workflows['anatomical_registration'][\n        'registration']['ANTs']['T1_registration']\n\n    ants, outputs = ANTs_registration_connector('ANTS_T1_to_template_'\n                                                f'symmetric_{pipe_num}', cfg,\n                                                params, orig='T1w',\n                                                symmetric=True)\n\n    ants.inputs.inputspec.interpolation = cfg.registration_workflows[\n        'anatomical_registration']['registration']['ANTs']['interpolation']\n\n    connect, brain = \\\n        strat_pool.get_data(['desc-preproc_T1w',\n                             'space-longitudinal_desc-brain_T1w'],\n                            report_fetched=True)\n    node, out = connect\n    wf.connect(node, out, ants, 'inputspec.input_brain')\n\n    node, out = strat_pool.get_data('T1w-brain-template-symmetric')\n    wf.connect(node, out, ants, 'inputspec.reference_brain')\n\n    node, out = strat_pool.get_data([\"desc-head_T1w\", \"desc-preproc_T1w\",\n                                     \"space-longitudinal_desc-reorient_T1w\"])\n    wf.connect(node, out, ants, 'inputspec.input_head')\n\n    node, out = strat_pool.get_data('T1w-template-symmetric')\n    wf.connect(node, out, ants, 'inputspec.reference_head')\n\n    node, out = strat_pool.get_data([\"space-T1w_desc-brain_mask\",\n                                     \"space-longitudinal_desc-brain_mask\"])\n    wf.connect(node, out, ants, 'inputspec.input_mask')\n\n    node, out = strat_pool.get_data('dilated-symmetric-brain-mask')\n    wf.connect(node, out, ants, 'inputspec.reference_mask')\n\n    if strat_pool.check_rpool('label-lesion_mask'):\n        node, out = strat_pool.get_data('label-lesion_mask')\n        wf.connect(node, out, ants, 'inputspec.lesion_mask')\n\n    if 'space-longitudinal' in brain:\n        for key in outputs.keys():\n            if 'from-T1w' in key:\n                new_key = key.replace('from-T1w', 'from-longitudinal')\n                outputs[new_key] = outputs[key]\n                del outputs[key]\n            if 'to-T1w' in key:\n                new_key = key.replace('to-T1w', 'to-longitudinal')\n                outputs[new_key] = outputs[key]\n                del outputs[key]\n\n    return (wf, outputs)"
  },
  {
    "name": "register_ANTs_EPI_to_template",
    "file": "CPAC/registration/registration.py",
    "line_number": 2530,
    "decorator_args": {
      "name": "register_ANTs_EPI_to_template",
      "config": [
        "registration_workflows",
        "functional_registration",
        "EPI_registration"
      ],
      "switch": [
        "run"
      ],
      "option_key": "using",
      "option_val": "ANTS",
      "inputs": [
        [
          "sbref",
          "space-bold_desc-brain_mask"
        ],
        "EPI-template",
        "EPI-template-mask"
      ],
      "outputs": "!UNSUPPORTED_TYPE:Dict!"
    },
    "docstring": "Directly register the mean functional to an EPI template. No T1w\ninvolved.",
    "source_code": "def register_ANTs_EPI_to_template(wf, cfg, strat_pool, pipe_num, opt=None):\n    '''Directly register the mean functional to an EPI template. No T1w\n    involved.\n    '''\n    params = cfg.registration_workflows['functional_registration'][\n        'EPI_registration']['ANTs']['parameters']\n\n    ants, outputs = ANTs_registration_connector('ANTS_bold_to_EPI-template'\n                                                f'_{pipe_num}', cfg, params,\n                                                orig='bold', template='EPI')\n\n    ants.inputs.inputspec.interpolation = cfg.registration_workflows[\n        'functional_registration']['EPI_registration']['ANTs'][\n        'interpolation']\n\n    node, out = strat_pool.get_data('sbref')\n    wf.connect(node, out, ants, 'inputspec.input_brain')\n\n    node, out = strat_pool.get_data('EPI-template')\n    wf.connect(node, out, ants, 'inputspec.reference_brain')\n\n    node, out = strat_pool.get_data('sbref')\n    wf.connect(node, out, ants, 'inputspec.input_head')\n\n    node, out = strat_pool.get_data('EPI-template')\n    wf.connect(node, out, ants, 'inputspec.reference_head')\n\n    node, out = strat_pool.get_data('space-bold_desc-brain_mask')\n    wf.connect(node, out, ants, 'inputspec.input_mask')\n\n    if strat_pool.check_rpool('EPI-template-mask'):\n        node, out = strat_pool.get_data('EPI-template-mask')\n        wf.connect(node, out, ants, 'inputspec.reference_mask')\n\n    return (wf, outputs)"
  },
  {
    "name": "overwrite_transform_anat_to_template",
    "file": "CPAC/registration/registration.py",
    "line_number": 2608,
    "decorator_args": {
      "name": "overwrite_transform_anat_to_template",
      "switch": [
        [
          "registration_workflows",
          "anatomical_registration",
          "run"
        ],
        [
          "registration_workflows",
          "anatomical_registration",
          "overwrite_transform",
          "run"
        ]
      ],
      "option_key": [
        "registration_workflows",
        "anatomical_registration",
        "overwrite_transform",
        "using"
      ],
      "option_val": "FSL",
      "inputs": [
        [
          "desc-restore-brain_T1w",
          [
            "desc-preproc_T1w",
            "space-longitudinal_desc-brain_T1w"
          ],
          [
            "desc-restore_T1w",
            "desc-preproc_T1w",
            "desc-reorient_T1w",
            "T1w"
          ],
          [
            "desc-preproc_T1w",
            "desc-reorient_T1w",
            "T1w"
          ],
          "space-T1w_desc-brain_mask",
          "T1w-template",
          "from-T1w_to-template_mode-image_xfm",
          "from-template_to-T1w_mode-image_xfm",
          "space-template_desc-brain_T1w",
          "space-template_desc-preproc_T1w"
        ]
      ],
      "outputs": "!UNSUPPORTED_TYPE:Dict!"
    },
    "docstring": null,
    "source_code": "def overwrite_transform_anat_to_template(wf, cfg, strat_pool, pipe_num,\n                                         opt=None):\n\n    xfm_prov = strat_pool.get_cpac_provenance(\n        'from-T1w_to-template_mode-image_xfm')\n\n    reg_tool = check_prov_for_regtool(xfm_prov)\n\n    if opt.lower() == 'fsl' and reg_tool.lower() == 'ants':\n\n        # Apply head-to-head transforms on brain using ABCD-style registration\n        # Convert ANTs warps to FSL warps to be consistent with the functional registration\n        # Ref: https://github.com/DCAN-Labs/DCAN-HCP/blob/master/PostFreeSurfer/scripts/AtlasRegistrationToMNI152_ANTsbased.sh#L134-L172\n\n        # antsApplyTransforms -d 3 -i ${T1wRestore}.nii.gz -r ${Reference} \\\n        # -t ${WD}/xfms/T1w_to_MNI_3Warp.nii.gz \\\n        # -t ${WD}/xfms/T1w_to_MNI_2Affine.mat \\\n        # -t ${WD}/xfms/T1w_to_MNI_1Rigid.mat \\\n        # -t ${WD}/xfms/T1w_to_MNI_0DerivedInitialMovingTranslation.mat \\\n        # -o [${WD}/xfms/ANTs_CombinedWarp.nii.gz,1]\n        ants_apply_warp_t1_to_template = pe.Node(interface=ants.ApplyTransforms(),\n                                                name=f'ANTS-ABCD_T1_to_template_{pipe_num}')\n        ants_apply_warp_t1_to_template.inputs.dimension = 3\n        ants_apply_warp_t1_to_template.inputs.print_out_composite_warp_file = True\n        ants_apply_warp_t1_to_template.inputs.output_image = 'ANTs_CombinedWarp.nii.gz'\n\n        node, out = strat_pool.get_data(['desc-restore_T1w', 'desc-preproc_T1w'])\n        wf.connect(node, out, ants_apply_warp_t1_to_template, 'input_image')\n\n        node, out = strat_pool.get_data('T1w-template')\n        wf.connect(node, out, ants_apply_warp_t1_to_template, 'reference_image')\n\n        node, out = strat_pool.get_data('from-T1w_to-template_mode-image_xfm')\n        wf.connect(node, out, ants_apply_warp_t1_to_template, 'transforms')\n\n        # antsApplyTransforms -d 3 -i ${T1wImage}.nii.gz -r ${Reference} \\\n        # -t [${WD}/xfms/T1w_to_MNI_0DerivedInitialMovingTranslation.mat,1] \\\n        # -t [${WD}/xfms/T1w_to_MNI_1Rigid.mat,1] \\\n        # -t [${WD}/xfms/T1w_to_MNI_2Affine.mat,1] \\\n        # -t ${WD}/xfms/T1w_to_MNI_3InverseWarp.nii.gz \\\n        # -o [${WD}/xfms/ANTs_CombinedInvWarp.nii.gz,1]\n\n        # T1wImage is ACPC aligned head\n        ants_apply_warp_template_to_t1 = pe.Node(interface=ants.ApplyTransforms(),\n                                                name=f'ANTS-ABCD_template_to_T1_{pipe_num}')\n        ants_apply_warp_template_to_t1.inputs.dimension = 3\n        ants_apply_warp_template_to_t1.inputs.print_out_composite_warp_file = True\n        ants_apply_warp_template_to_t1.inputs.output_image = 'ANTs_CombinedInvWarp.nii.gz'\n\n        node, out = strat_pool.get_data('desc-preproc_T1w')\n        wf.connect(node, out, ants_apply_warp_template_to_t1, 'input_image')\n\n        node, out = strat_pool.get_data('T1w-template')\n        wf.connect(node, out, ants_apply_warp_template_to_t1, 'reference_image')\n\n        node, out = strat_pool.get_data('from-template_to-T1w_mode-image_xfm')\n        wf.connect(node, out, ants_apply_warp_template_to_t1, 'transforms')\n\n        # c4d -mcs ${WD}/xfms/ANTs_CombinedWarp.nii.gz -oo ${WD}/xfms/e1.nii.gz ${WD}/xfms/e2.nii.gz ${WD}/xfms/e3.nii.gz\n        # -mcs: -multicomponent-split, -oo: -output-multiple\n        split_combined_warp = pe.Node(util.Function(input_names=['input',\n                                                                'output_name'],\n                                                    output_names=['output1',\n                                                                'output2',\n                                                                'output3'],\n                                                    function=run_c4d),\n                                    name=f'split_combined_warp_{pipe_num}')\n        split_combined_warp.inputs.output_name = 'e'\n\n        wf.connect(ants_apply_warp_t1_to_template, 'output_image',\n            split_combined_warp, 'input')\n\n        # c4d -mcs ${WD}/xfms/ANTs_CombinedInvWarp.nii.gz -oo ${WD}/xfms/e1inv.nii.gz ${WD}/xfms/e2inv.nii.gz ${WD}/xfms/e3inv.nii.gz\n        split_combined_inv_warp = pe.Node(util.Function(input_names=['input',\n                                                                    'output_name'],\n                                                        output_names=['output1',\n                                                                    'output2',\n                                                                    'output3'],\n                                                        function=run_c4d),\n                                    name=f'split_combined_inv_warp_{pipe_num}')\n        split_combined_inv_warp.inputs.output_name = 'einv'\n\n        wf.connect(ants_apply_warp_template_to_t1, 'output_image',\n            split_combined_inv_warp, 'input')\n\n        # fslmaths ${WD}/xfms/e2.nii.gz -mul -1 ${WD}/xfms/e-2.nii.gz\n        change_e2_sign = pe.Node(interface=fsl.maths.MathsCommand(),\n                            name=f'change_e2_sign_{pipe_num}')\n        change_e2_sign.inputs.args = '-mul -1'\n\n        wf.connect(split_combined_warp, 'output2',\n            change_e2_sign, 'in_file')\n\n        # fslmaths ${WD}/xfms/e2inv.nii.gz -mul -1 ${WD}/xfms/e-2inv.nii.gz\n        change_e2inv_sign = pe.Node(interface=fsl.maths.MathsCommand(),\n                                name=f'change_e2inv_sign_{pipe_num}')\n        change_e2inv_sign.inputs.args = '-mul -1'\n\n        wf.connect(split_combined_inv_warp, 'output2',\n            change_e2inv_sign, 'in_file')\n\n        # fslmerge -t ${OutputTransform} ${WD}/xfms/e1.nii.gz ${WD}/xfms/e-2.nii.gz ${WD}/xfms/e3.nii.gz\n        merge_xfms_to_list = pe.Node(util.Merge(3),\n                                     name=f'merge_t1_to_template_xfms_to_list_{pipe_num}')\n\n        wf.connect(split_combined_warp, 'output1',\n            merge_xfms_to_list, 'in1')\n        wf.connect(change_e2_sign, 'out_file',\n            merge_xfms_to_list, 'in2')\n        wf.connect(split_combined_warp, 'output3',\n            merge_xfms_to_list, 'in3')\n\n        merge_xfms = pe.Node(interface=fslMerge(),\n                             name=f'merge_t1_to_template_xfms_{pipe_num}')\n        merge_xfms.inputs.dimension = 't'\n\n        wf.connect(merge_xfms_to_list, 'out',\n            merge_xfms, 'in_files')\n\n        # fslmerge -t ${OutputInvTransform} ${WD}/xfms/e1inv.nii.gz ${WD}/xfms/e-2inv.nii.gz ${WD}/xfms/e3inv.nii.gz\n        merge_inv_xfms_to_list = pe.Node(util.Merge(3),\n                                         name=f'merge_template_to_t1_xfms_to_list_{pipe_num}')\n\n        wf.connect(split_combined_inv_warp, 'output1',\n            merge_inv_xfms_to_list, 'in1')\n        wf.connect(change_e2inv_sign, 'out_file',\n            merge_inv_xfms_to_list, 'in2')\n        wf.connect(split_combined_inv_warp, 'output3',\n            merge_inv_xfms_to_list, 'in3')\n\n        merge_inv_xfms = pe.Node(interface=fslMerge(),\n                                 name=f'merge_template_to_t1_xfms_{pipe_num}')\n        merge_inv_xfms.inputs.dimension = 't'\n\n        wf.connect(merge_inv_xfms_to_list, 'out',\n            merge_inv_xfms, 'in_files')\n\n        # applywarp --rel --interp=spline -i ${T1wRestore} -r ${Reference} -w ${OutputTransform} -o ${OutputT1wImageRestore}\n        fsl_apply_warp_t1_to_template = pe.Node(interface=fsl.ApplyWarp(),\n                                                name=f'FSL-ABCD_T1_to_template_{pipe_num}')\n        fsl_apply_warp_t1_to_template.inputs.relwarp = True\n        fsl_apply_warp_t1_to_template.inputs.interp = 'spline'\n\n        node, out = strat_pool.get_data(['desc-restore_T1w', 'desc-preproc_T1w'])\n        wf.connect(node, out, fsl_apply_warp_t1_to_template, 'in_file')\n\n        node, out = strat_pool.get_data('T1w-template')\n        wf.connect(node, out, fsl_apply_warp_t1_to_template, 'ref_file')\n\n        wf.connect(merge_xfms, 'merged_file',\n            fsl_apply_warp_t1_to_template, 'field_file')\n\n        # applywarp --rel --interp=nn -i ${T1wRestoreBrain} -r ${Reference} -w ${OutputTransform} -o ${OutputT1wImageRestoreBrain}\n        fsl_apply_warp_t1_brain_to_template = pe.Node(interface=fsl.ApplyWarp(),\n                                                      name=f'FSL-ABCD_T1_brain_to_template_{pipe_num}')\n        fsl_apply_warp_t1_brain_to_template.inputs.relwarp = True\n        fsl_apply_warp_t1_brain_to_template.inputs.interp = 'nn'\n\n        # TODO connect T1wRestoreBrain, check T1wRestoreBrain quality\n        node, out = strat_pool.get_data('desc-preproc_T1w')\n        wf.connect(node, out, fsl_apply_warp_t1_brain_to_template, 'in_file')\n\n        node, out = strat_pool.get_data('T1w-template')\n        wf.connect(node, out, fsl_apply_warp_t1_brain_to_template, 'ref_file')\n\n        wf.connect(merge_xfms, 'merged_file',\n            fsl_apply_warp_t1_brain_to_template, 'field_file')\n\n        fsl_apply_warp_t1_brain_mask_to_template = pe.Node(interface=fsl.ApplyWarp(),\n                                                        name=f'FSL-ABCD_T1_brain_mask_to_template_{pipe_num}')\n        fsl_apply_warp_t1_brain_mask_to_template.inputs.relwarp = True\n        fsl_apply_warp_t1_brain_mask_to_template.inputs.interp = 'nn'\n\n        node, out = strat_pool.get_data('space-T1w_desc-brain_mask')\n        wf.connect(node, out, fsl_apply_warp_t1_brain_mask_to_template, 'in_file')\n\n        node, out = strat_pool.get_data('T1w-template')\n        wf.connect(node, out, fsl_apply_warp_t1_brain_mask_to_template, 'ref_file')\n\n        wf.connect(merge_xfms, 'merged_file',\n            fsl_apply_warp_t1_brain_mask_to_template, 'field_file')\n\n        # fslmaths ${OutputT1wImageRestore} -mas ${OutputT1wImageRestoreBrain} ${OutputT1wImageRestoreBrain}\n        apply_mask = pe.Node(interface=fsl.maths.ApplyMask(),\n                            name=f'get_t1_brain_{pipe_num}')\n\n        wf.connect(fsl_apply_warp_t1_to_template, 'out_file',\n            apply_mask, 'in_file')\n\n        wf.connect(fsl_apply_warp_t1_brain_to_template, 'out_file',\n            apply_mask, 'mask_file')\n\n        outputs = {\n            'space-template_desc-preproc_T1w': (apply_mask, 'out_file'),\n            'space-template_desc-head_T1w': (fsl_apply_warp_t1_to_template, 'out_file'),\n            'space-template_desc-T1w_mask': (fsl_apply_warp_t1_brain_mask_to_template, 'out_file'),\n            'from-T1w_to-template_mode-image_xfm': (merge_xfms, 'merged_file'),\n            'from-template_to-T1w_mode-image_xfm': (merge_inv_xfms, 'merged_file')\n        }\n\n    return (wf, outputs)"
  },
  {
    "name": "coregistration_prep_vol",
    "file": "CPAC/registration/registration.py",
    "line_number": 2825,
    "decorator_args": {
      "name": "coregistration_prep_vol",
      "switch": [
        "functional_preproc",
        "run"
      ],
      "option_key": [
        "registration_workflows",
        "functional_registration",
        "coregistration",
        "func_input_prep",
        "input"
      ],
      "option_val": "Selected_Functional_Volume",
      "inputs": [
        [
          "desc-brain_bold",
          [
            "desc-motion_bold",
            "bold"
          ],
          "sbref"
        ]
      ],
      "outputs": [
        "sbref"
      ]
    },
    "docstring": null,
    "source_code": "def coregistration_prep_vol(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    get_func_volume = pe.Node(interface=afni.Calc(),\n                              name=f'get_func_volume_{pipe_num}')\n\n    get_func_volume.inputs.set(\n        expr='a',\n        single_idx=cfg.registration_workflows['functional_registration']['coregistration'][\n            'func_input_prep']['Selected Functional Volume']['func_reg_input_volume'],\n        outputtype='NIFTI_GZ'\n    )\n\n    if not cfg.registration_workflows['functional_registration'][\n        'coregistration']['func_input_prep']['reg_with_skull']:\n        node, out = strat_pool.get_data(\"desc-brain_bold\")\n    else:\n        # TODO check which file is functional_skull_leaf\n        # TODO add a function to choose brain or skull?\n        node, out = strat_pool.get_data([\"desc-motion_bold\", \"bold\"])\n\n    wf.connect(node, out, get_func_volume, 'in_file_a')\n\n    coreg_input = (get_func_volume, 'out_file')\n\n    outputs = {\n        'sbref': coreg_input\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "coregistration_prep_mean",
    "file": "CPAC/registration/registration.py",
    "line_number": 2871,
    "decorator_args": {
      "name": "coregistration_prep_mean",
      "switch": [
        [
          "functional_preproc",
          "run"
        ],
        [
          "functional_preproc",
          "coreg_prep",
          "run"
        ]
      ],
      "option_key": [
        "registration_workflows",
        "functional_registration",
        "coregistration",
        "func_input_prep",
        "input"
      ],
      "option_val": "Mean_Functional",
      "inputs": [
        "desc-mean_bold"
      ],
      "outputs": [
        "sbref"
      ]
    },
    "docstring": null,
    "source_code": "def coregistration_prep_mean(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    coreg_input = strat_pool.get_data(\"desc-mean_bold\")\n\n    # TODO add mean skull\n    if cfg.registration_workflows['functional_registration'][\n            'coregistration']['func_input_prep']['Mean Functional'][\n            'n4_correct_func']:\n        n4_correct_func = pe.Node(\n            interface=\n            ants.N4BiasFieldCorrection(dimension=3,\n                                       copy_header=True,\n                                       bspline_fitting_distance=200),\n            shrink_factor=2,\n            name=f'func_mean_n4_corrected_{pipe_num}')\n        n4_correct_func.inputs.args = '-r True'\n\n        node, out = coreg_input\n        wf.connect(node, out, n4_correct_func, 'input_image')\n\n        coreg_input = (n4_correct_func, 'output_image')\n\n    outputs = {\n        'sbref': coreg_input\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "coregistration_prep_fmriprep",
    "file": "CPAC/registration/registration.py",
    "line_number": 2915,
    "decorator_args": {
      "name": "coregistration_prep_fmriprep",
      "switch": [
        [
          "functional_preproc",
          "run"
        ],
        [
          "functional_preproc",
          "coreg_prep",
          "run"
        ]
      ],
      "option_key": [
        "registration_workflows",
        "functional_registration",
        "coregistration",
        "func_input_prep",
        "input"
      ],
      "option_val": "fmriprep_reference",
      "inputs": [
        "desc-ref_bold"
      ],
      "outputs": [
        "sbref"
      ]
    },
    "docstring": null,
    "source_code": "def coregistration_prep_fmriprep(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    coreg_input = strat_pool.get_data(\"desc-ref_bold\")\n\n    outputs = {\n        'sbref': coreg_input\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "coregistration",
    "file": "CPAC/registration/registration.py",
    "line_number": 2958,
    "decorator_args": {
      "name": "coregistration",
      "config": [
        "registration_workflows",
        "functional_registration",
        "coregistration"
      ],
      "switch": [
        "run"
      ],
      "inputs": [
        [
          "sbref",
          "desc-motion_bold",
          "space-bold_label-WM_mask",
          "despiked-fieldmap",
          "fieldmap-mask",
          "effectiveEchoSpacing",
          "pe-direction"
        ],
        [
          "desc-preproc_T1w",
          "desc-restore-brain_T1w",
          "desc-preproc_T2w",
          "desc-preproc_T2w",
          "T2w",
          [
            "label-WM_probseg",
            "label-WM_mask"
          ],
          [
            "label-WM_pveseg",
            "label-WM_mask"
          ],
          "desc-head_T1w",
          "desc-head_T2w"
        ]
      ],
      "outputs": [
        "space-T1w_sbref",
        "from-bold_to-T1w_mode-image_desc-linear_xfm",
        "from-bold_to-T1w_mode-image_desc-linear_warp"
      ]
    },
    "docstring": null,
    "source_code": "def coregistration(wf, cfg, strat_pool, pipe_num, opt=None):\n    diff_complete = False\n    if strat_pool.check_rpool(\"despiked-fieldmap\") and \\\n            strat_pool.check_rpool(\"fieldmap-mask\"):\n        diff_complete = True\n\n    if strat_pool.check_rpool('T2w') and cfg.anatomical_preproc['run_t2']:\n        # monkey data\n        func_to_anat = create_register_func_to_anat_use_T2(cfg,\n                                                    f'func_to_anat_FLIRT_'\n                                                    f'{pipe_num}')\n\n        # https://github.com/DCAN-Labs/dcan-macaque-pipeline/blob/master/fMRIVolume/GenericfMRIVolumeProcessingPipeline.sh#L177\n        # fslmaths \"$fMRIFolder\"/\"$NameOffMRI\"_mc -Tmean \"$fMRIFolder\"/\"$ScoutName\"_gdc\n        func_mc_mean = pe.Node(interface=afni_utils.TStat(),\n                            name=f'func_motion_corrected_mean_{pipe_num}')\n\n        func_mc_mean.inputs.options = '-mean'\n        func_mc_mean.inputs.outputtype = 'NIFTI_GZ'\n\n        node, out = strat_pool.get_data(\"desc-motion_bold\")\n        wf.connect(node, out, func_mc_mean, 'in_file')\n\n        wf.connect(func_mc_mean, 'out_file', func_to_anat, 'inputspec.func')\n\n        node, out = strat_pool.get_data('desc-preproc_T1w')\n        wf.connect(node, out, func_to_anat, 'inputspec.T1_brain')\n\n        node, out = strat_pool.get_data('desc-head_T2w')\n        wf.connect(node, out, func_to_anat, 'inputspec.T2_head')\n\n        node, out = strat_pool.get_data('desc-preproc_T2w')\n        wf.connect(node, out, func_to_anat, 'inputspec.T2_brain')\n\n    else:\n        # if field map-based distortion correction is on, but BBR is off,\n        # send in the distortion correction files here\n        func_to_anat = create_register_func_to_anat(cfg, diff_complete,\n                                                    f'func_to_anat_FLIRT_'\n                                                    f'{pipe_num}')\n\n        func_to_anat.inputs.inputspec.dof = cfg.registration_workflows[\n        'functional_registration']['coregistration']['dof']\n\n        func_to_anat.inputs.inputspec.interp = cfg.registration_workflows[\n        'functional_registration']['coregistration']['interpolation']\n\n        node, out = strat_pool.get_data('sbref')\n        wf.connect(node, out, func_to_anat, 'inputspec.func')\n\n        if cfg.registration_workflows['functional_registration'][\n            'coregistration']['reference'] == 'brain':\n            # TODO: use JSON meta-data to confirm\n            node, out = strat_pool.get_data('desc-preproc_T1w')\n        elif cfg.registration_workflows['functional_registration'][\n            'coregistration']['reference'] == 'restore-brain':\n            node, out = strat_pool.get_data('desc-restore-brain_T1w')\n        wf.connect(node, out, func_to_anat, 'inputspec.anat')\n\n    if diff_complete:\n        node, out = strat_pool.get_data('effectiveEchoSpacing')\n        wf.connect(node, out, func_to_anat, 'echospacing_input.echospacing')\n\n        node, out = strat_pool.get_data('pe-direction')\n        wf.connect(node, out, func_to_anat, 'pedir_input.pedir')\n\n        node, out = strat_pool.get_data(\"despiked-fieldmap\")\n        wf.connect(node, out, func_to_anat, 'inputspec.fieldmap')\n\n        node, out = strat_pool.get_data(\"fieldmap-mask\")\n        wf.connect(node, out, func_to_anat, 'inputspec.fieldmapmask')\n\n    if strat_pool.check_rpool('T2w') and cfg.anatomical_preproc['run_t2']:\n        outputs = {\n            'space-T1w_sbref':\n                (func_to_anat, 'outputspec.anat_func_nobbreg'),\n            'from-bold_to-T1w_mode-image_desc-linear_xfm':\n                (func_to_anat, 'outputspec.func_to_anat_linear_xfm_nobbreg'),\n            'from-bold_to-T1w_mode-image_desc-linear_warp':\n                (func_to_anat, 'outputspec.func_to_anat_linear_warp_nobbreg')\n        }\n    else:\n        outputs = {\n            'space-T1w_sbref':\n                (func_to_anat, 'outputspec.anat_func_nobbreg'),\n            'from-bold_to-T1w_mode-image_desc-linear_xfm':\n                (func_to_anat, 'outputspec.func_to_anat_linear_xfm_nobbreg')\n        }\n\n    if True in cfg.registration_workflows['functional_registration'][\n        'coregistration'][\"boundary_based_registration\"][\"run\"]:\n\n        func_to_anat_bbreg = create_bbregister_func_to_anat(diff_complete,\n                                                            f'func_to_anat_'\n                                                            f'bbreg_'\n                                                            f'{pipe_num}')\n        func_to_anat_bbreg.inputs.inputspec.bbr_schedule = \\\n            cfg.registration_workflows['functional_registration'][\n                'coregistration']['boundary_based_registration'][\n                'bbr_schedule']\n\n        func_to_anat_bbreg.inputs.inputspec.bbr_wm_mask_args = \\\n            cfg.registration_workflows['functional_registration'][\n                'coregistration']['boundary_based_registration'][\n                'bbr_wm_mask_args']\n\n        node, out = strat_pool.get_data('sbref')\n        wf.connect(node, out, func_to_anat_bbreg, 'inputspec.func')\n\n        if cfg.registration_workflows['functional_registration'][\n                'coregistration']['boundary_based_registration'][\n                'reference'] == 'whole-head':\n            node, out = strat_pool.get_data('desc-head_T1w')\n            wf.connect(node, out, func_to_anat_bbreg, 'inputspec.anat')\n\n        elif cfg.registration_workflows['functional_registration'][\n                'coregistration']['boundary_based_registration'][\n                'reference'] == 'brain':\n            node, out = strat_pool.get_data('desc-preproc_T1w')\n            wf.connect(node, out, func_to_anat_bbreg, 'inputspec.anat')\n\n        wf.connect(func_to_anat, 'outputspec.func_to_anat_linear_xfm_nobbreg',\n                   func_to_anat_bbreg, 'inputspec.linear_reg_matrix')\n\n        if strat_pool.check_rpool('space-bold_label-WM_mask'):\n            node, out = strat_pool.get_data([\"space-bold_label-WM_mask\"])\n            wf.connect(node, out,\n                       func_to_anat_bbreg, 'inputspec.anat_wm_segmentation')\n        else:\n            if cfg.registration_workflows['functional_registration'][\n                'coregistration']['boundary_based_registration']['bbr_wm_map'] == 'probability_map':\n                node, out = strat_pool.get_data([\"label-WM_probseg\",\n                                                 \"label-WM_mask\"])\n            elif cfg.registration_workflows['functional_registration'][\n                'coregistration']['boundary_based_registration']['bbr_wm_map'] == 'partial_volume_map':\n                node, out = strat_pool.get_data([\"label-WM_pveseg\",\n                                                 \"label-WM_mask\"])\n            wf.connect(node, out,\n                       func_to_anat_bbreg, 'inputspec.anat_wm_segmentation')\n\n        if diff_complete:\n            node, out = strat_pool.get_data('effectiveEchoSpacing')\n            wf.connect(node, out,\n                       func_to_anat_bbreg, 'echospacing_input.echospacing')\n\n            node, out = strat_pool.get_data('pe-direction')\n            wf.connect(node, out, func_to_anat_bbreg, 'pedir_input.pedir')\n\n            node, out = strat_pool.get_data(\"despiked-fieldmap\")\n            wf.connect(node, out, func_to_anat_bbreg, 'inputspec.fieldmap')\n\n            node, out = strat_pool.get_data(\"fieldmap-mask\")\n            wf.connect(node, out,\n                       func_to_anat_bbreg, 'inputspec.fieldmapmask')\n\n        outputs = {\n            'space-T1w_sbref':\n                (func_to_anat_bbreg, 'outputspec.anat_func'),\n            'from-bold_to-T1w_mode-image_desc-linear_xfm':\n                (func_to_anat_bbreg, 'outputspec.func_to_anat_linear_xfm')\n        }\n\n    return (wf, outputs)"
  },
  {
    "name": "create_func_to_T1template_xfm",
    "file": "CPAC/registration/registration.py",
    "line_number": 3156,
    "decorator_args": {
      "name": "create_func_to_T1template_xfm",
      "config": [
        "registration_workflows",
        "functional_registration",
        "func_registration_to_template"
      ],
      "switch": [
        "run"
      ],
      "option_key": [
        "target_template",
        "using"
      ],
      "option_val": "T1_template",
      "inputs": [
        [
          "sbref",
          "from-bold_to-T1w_mode-image_desc-linear_xfm",
          "ants-blip-warp",
          "fsl-blip-warp"
        ],
        [
          "from-T1w_to-template_mode-image_xfm",
          "from-template_to-T1w_mode-image_xfm",
          "desc-brain_T1w"
        ],
        "T1w-brain-template-funcreg"
      ],
      "outputs": "!UNSUPPORTED_TYPE:Dict!"
    },
    "docstring": "Condense the BOLD-to-T1 coregistration transform and the T1-to-template\ntransform into one transform matrix.",
    "source_code": "def create_func_to_T1template_xfm(wf, cfg, strat_pool, pipe_num, opt=None):\n    '''Condense the BOLD-to-T1 coregistration transform and the T1-to-template\n    transform into one transform matrix.\n    '''\n    xfm_prov = strat_pool.get_cpac_provenance(\n        'from-T1w_to-template_mode-image_xfm')\n    reg_tool = check_prov_for_regtool(xfm_prov)\n\n    xfm, outputs = bold_to_T1template_xfm_connector('create_func_to_T1w'\n                                                    f'template_xfm_{pipe_num}',\n                                                    cfg, reg_tool,\n                                                    symmetric=False)\n\n    node, out = strat_pool.get_data(\n        'from-bold_to-T1w_mode-image_desc-linear_xfm')\n    wf.connect(node, out, xfm, 'inputspec.coreg_xfm')\n\n    node, out = strat_pool.get_data('desc-brain_T1w')\n    wf.connect(node, out, xfm, 'inputspec.input_brain')\n\n    node, out = strat_pool.get_data('sbref')\n    wf.connect(node, out, xfm, 'inputspec.mean_bold')\n\n    node, out = strat_pool.get_data('T1w-brain-template-funcreg')\n    wf.connect(node, out, xfm, 'inputspec.T1w-brain-template_funcreg')\n\n    node, out = strat_pool.get_data('from-T1w_to-template_mode-image_xfm')\n    wf.connect(node, out, xfm, 'inputspec.T1w_to_template_xfm')\n\n    # FNIRT pipelines don't have an inverse nonlinear warp, make optional\n    if strat_pool.check_rpool('from-template_to-T1w_mode-image_xfm'):\n        node, out = strat_pool.get_data('from-template_to-T1w_mode-image_xfm')\n        wf.connect(node, out, xfm, 'inputspec.template_to_T1w_xfm')\n\n    if strat_pool.check_rpool('ants-blip-warp'):\n        if reg_tool == 'ants':\n            node, out = strat_pool.get_data('ants-blip-warp')\n            wf.connect(node, out, xfm, 'inputspec.blip_warp')\n        elif reg_tool == 'fsl':\n            # apply the ants blip warp separately\n            pass\n    elif strat_pool.check_rpool('fsl-blip-warp'):\n        if reg_tool == 'fsl':\n            node, out = strat_pool.get_data('fsl-blip-warp')\n            wf.connect(node, out, xfm, 'inputspec.blip_warp')\n        elif reg_tool == 'ants':\n            # apply the fsl blip warp separately\n            pass\n\n    return (wf, outputs)"
  },
  {
    "name": "create_func_to_T1template_symmetric_xfm",
    "file": "CPAC/registration/registration.py",
    "line_number": 3236,
    "decorator_args": {
      "name": "create_func_to_T1template_symmetric_xfm",
      "config": [
        "registration_workflows",
        "functional_registration",
        "func_registration_to_template"
      ],
      "switch": [
        "run"
      ],
      "option_key": [
        "target_template",
        "using"
      ],
      "option_val": "T1_template",
      "inputs": [
        [
          "from-T1w_to-symtemplate_mode-image_xfm",
          "from-symtemplate_to-T1w_mode-image_xfm",
          "desc-brain_T1w"
        ],
        [
          "sbref",
          "from-bold_to-T1w_mode-image_desc-linear_xfm"
        ],
        "T1w-brain-template-symmetric-deriv"
      ],
      "outputs": "!UNSUPPORTED_TYPE:Dict!"
    },
    "docstring": "Condense the BOLD-to-T1 coregistration transform and the T1-to-\nsymmetric-template transform into one transform matrix.",
    "source_code": "def create_func_to_T1template_symmetric_xfm(wf, cfg, strat_pool, pipe_num,\n                                            opt=None):\n    '''Condense the BOLD-to-T1 coregistration transform and the T1-to-\n    symmetric-template transform into one transform matrix.\n    '''\n\n    xfm_prov = strat_pool.get_cpac_provenance(\n        'from-T1w_to-symtemplate_mode-image_xfm')\n    reg_tool = check_prov_for_regtool(xfm_prov)\n\n    xfm, outputs = bold_to_T1template_xfm_connector('create_func_to_T1wsymtem'\n                                                    f'plate_xfm_{pipe_num}',\n                                                    cfg, reg_tool,\n                                                    symmetric=True)\n\n    node, out = strat_pool.get_data(\n        'from-bold_to-T1w_mode-image_desc-linear_xfm')\n    wf.connect(node, out, xfm, 'inputspec.coreg_xfm')\n\n    node, out = strat_pool.get_data('desc-brain_T1w')\n    wf.connect(node, out, xfm, 'inputspec.input_brain')\n\n    node, out = strat_pool.get_data('sbref')\n    wf.connect(node, out, xfm, 'inputspec.mean_bold')\n\n    node, out = strat_pool.get_data('T1w-brain-template-symmetric-deriv')\n    wf.connect(node, out, xfm, 'inputspec.T1w-brain-template_funcreg')\n\n    node, out = strat_pool.get_data('from-T1w_to-symtemplate_mode-image_xfm')\n    wf.connect(node, out, xfm, 'inputspec.T1w_to_template_xfm')\n\n    # FNIRT pipelines don't have an inverse nonlinear warp, make optional\n    if strat_pool.check_rpool('from-symtemplate_to-T1w_mode-image_xfm'):\n        node, out = \\\n            strat_pool.get_data('from-symtemplate_to-T1w_mode-image_xfm')\n        wf.connect(node, out, xfm, 'inputspec.template_to_T1w_xfm')\n\n    return (wf, outputs)"
  },
  {
    "name": "apply_phasediff_to_timeseries_separately",
    "file": "CPAC/registration/registration.py",
    "line_number": 3309,
    "decorator_args": {
      "name": "apply_phasediff_to_timeseries_separately",
      "switch": [
        [
          "registration_workflows",
          "functional_registration",
          "func_registration_to_template",
          "run"
        ],
        [
          "functional_preproc",
          "distortion_correction",
          "run"
        ]
      ],
      "option_key": [
        "registration_workflows",
        "functional_registration",
        "func_registration_to_template",
        "apply_transform",
        "using"
      ],
      "option_val": [
        "default",
        "single_step_resampling_from_stc",
        "abcd"
      ],
      "inputs": [
        [
          "sbref",
          "desc-preproc_bold",
          "desc-stc_bold",
          "bold",
          "from-bold_to-T1w_mode-image_desc-linear_xfm"
        ],
        "despiked-fieldmap",
        "pe-direction",
        "effectiveEchoSpacing"
      ],
      "outputs": [
        "sbref",
        "desc-preproc_bold",
        "desc-stc_bold",
        "bold"
      ]
    },
    "docstring": null,
    "source_code": "def apply_phasediff_to_timeseries_separately(wf, cfg, strat_pool, pipe_num,\n                                             opt=None):\n\n    outputs = {'desc-preproc_bold': strat_pool.get_data(\"desc-preproc_bold\")}\n    if not strat_pool.check_rpool(\"despiked-fieldmap\"):\n        return (wf, outputs)\n\n    invert_coreg_xfm = pe.Node(interface=fsl.ConvertXFM(),\n        name=f'invert_coreg_xfm_{pipe_num}')\n    invert_coreg_xfm.inputs.invert_xfm = True\n\n    node, out = strat_pool.get_data(\"from-bold_to-T1w_mode-image_desc-linear_xfm\")\n    wf.connect(node, out, invert_coreg_xfm, 'in_file')\n\n    warp_fmap = pe.Node(interface=fsl.ApplyWarp(),\n        name=f'warp_fmap_{pipe_num}')\n\n    node, out = strat_pool.get_data('despiked-fieldmap')\n    wf.connect(node, out, warp_fmap, 'in_file')\n\n    node, out = strat_pool.get_data('sbref')\n    wf.connect(node, out, warp_fmap, 'ref_file')\n\n    wf.connect(invert_coreg_xfm, 'out_file', warp_fmap, 'premat')\n\n    mask_fmap = pe.Node(interface=fsl.maths.MathsCommand(),\n                        name=f'mask_fmap_{pipe_num}')\n    mask_fmap.inputs.args = '-abs -bin'\n\n    wf.connect(warp_fmap, 'out_file', mask_fmap, 'in_file')\n\n    conv_pedir = \\\n        pe.Node(interface=util.Function(input_names=['pedir',\n                                                     'convert'],\n                                        output_names=['pedir'],\n                                        function=convert_pedir),\n                name=f'apply_phasediff_convert_pedir_{pipe_num}')\n    conv_pedir.inputs.convert = 'ijk_to_xyz'\n\n    node, out = strat_pool.get_data('pe-direction')\n    wf.connect(node, out, conv_pedir, 'pedir')\n\n    fugue_saveshift = pe.Node(interface=fsl.FUGUE(),\n                              name=f'fugue_saveshift_{pipe_num}')\n    fugue_saveshift.inputs.save_shift = True\n\n    wf.connect(warp_fmap, 'out_file', fugue_saveshift, 'fmap_in_file')\n    wf.connect(mask_fmap, 'out_file', fugue_saveshift, 'mask_file')\n\n    # FSL calls effective echo spacing = dwell time (not accurate)\n    node, out = strat_pool.get_data('effectiveEchoSpacing')\n    wf.connect(node, out, fugue_saveshift, 'dwell_time')\n\n    wf.connect(conv_pedir, 'pedir', fugue_saveshift, 'unwarp_direction')\n\n    shift_warp = pe.Node(interface=fsl.ConvertWarp(), \n                         name=f'shift_warp_{pipe_num}')\n    shift_warp.inputs.out_relwarp = True\n\n    wf.connect(fugue_saveshift, 'shift_out_file', shift_warp, 'shift_in_file')\n\n    node, out = strat_pool.get_data('sbref')\n    wf.connect(node, out, shift_warp, 'reference')\n\n    wf.connect(conv_pedir, 'pedir', shift_warp, 'shift_direction')\n\n    warp_bold = pe.Node(interface=fsl.ApplyWarp(),\n                        name=f'warp_bold_phasediff_{pipe_num}')\n    warp_bold.inputs.relwarp = True\n    warp_bold.inputs.interp = 'spline'\n\n    if opt == 'default':\n        node, out = strat_pool.get_data('desc-preproc_bold')\n        out_label = 'desc-preproc_bold'\n    elif opt == 'single_step_resampling_from_stc':\n        node, out = strat_pool.get_data('desc-stc_bold')\n        out_label = 'desc-stc_bold'\n    elif opt == 'abcd':\n        node, out = strat_pool.get_data('bold')\n        out_label = 'bold'\n\n    wf.connect(node, out, warp_bold, 'in_file')\n\n    node, out = strat_pool.get_data('sbref')\n    wf.connect(node, out, warp_bold, 'ref_file')\n\n    wf.connect(shift_warp, 'out_file', warp_bold, 'field_file')\n    \n    warp_sbref = pe.Node(interface=fsl.ApplyWarp(),\n                        name=f'warp_sbref_phasediff_{pipe_num}')\n    warp_sbref.inputs.relwarp = True\n    warp_sbref.inputs.interp = 'spline'\n\n    node, out = strat_pool.get_data('sbref')\n    wf.connect(node, out, warp_sbref, 'in_file')\n    wf.connect(node, out, warp_sbref, 'ref_file')\n\n    wf.connect(shift_warp, 'out_file', warp_sbref, 'field_file')\n\n    outputs = {\n        out_label: (warp_bold, 'out_file'),\n        'sbref': (warp_sbref, 'out_file')\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "apply_blip_to_timeseries_separately",
    "file": "CPAC/registration/registration.py",
    "line_number": 3448,
    "decorator_args": {
      "name": "apply_blip_to_timeseries_separately",
      "switch": [
        [
          "registration_workflows",
          "functional_registration",
          "func_registration_to_template",
          "run"
        ],
        [
          "functional_preproc",
          "distortion_correction",
          "run"
        ]
      ],
      "option_key": [
        "registration_workflows",
        "functional_registration",
        "func_registration_to_template",
        "apply_transform",
        "using"
      ],
      "option_val": [
        "default",
        "single_step_resampling_from_stc",
        "abcd"
      ],
      "inputs": [
        [
          "sbref",
          "desc-preproc_bold",
          "desc-stc_bold",
          "bold",
          "from-bold_to-template_mode-image_xfm",
          "ants-blip-warp",
          "fsl-blip-warp"
        ]
      ],
      "outputs": [
        "desc-preproc_bold",
        "desc-stc_bold",
        "bold"
      ]
    },
    "docstring": null,
    "source_code": "def apply_blip_to_timeseries_separately(wf, cfg, strat_pool, pipe_num,\n                                        opt=None):\n\n    xfm_prov = strat_pool.get_cpac_provenance(\n        'from-bold_to-template_mode-image_xfm')\n    reg_tool = check_prov_for_regtool(xfm_prov)\n\n    outputs = {'desc-preproc_bold': strat_pool.get_data(\"desc-preproc_bold\")}\n    if strat_pool.check_rpool(\"ants-blip-warp\"):\n        if reg_tool == 'fsl':\n            blip_node, blip_out = strat_pool.get_data(\"ants-blip-warp\")\n            reg_tool = 'ants'\n        else:\n            return (wf, outputs)\n    elif strat_pool.check_rpool(\"fsl-blip-warp\"):\n        if reg_tool == 'ants':\n            blip_node, blip_out = strat_pool.get_data(\"fsl-blip-warp\")\n            reg_tool = 'fsl'\n        else:\n            return (wf, outputs)\n    else:\n        return (wf, outputs)\n\n    num_cpus = cfg.pipeline_setup['system_config'][\n        'max_cores_per_participant']\n\n    num_ants_cores = cfg.pipeline_setup['system_config']['num_ants_threads']\n\n    apply_xfm = apply_transform(f'warp_ts_to_blip_sep_{pipe_num}', reg_tool,\n                                time_series=True, num_cpus=num_cpus,\n                                num_ants_cores=num_ants_cores)\n\n    if reg_tool == 'ants':\n        apply_xfm.inputs.inputspec.interpolation = cfg.registration_workflows[\n            'functional_registration']['func_registration_to_template'][\n            'ANTs_pipelines']['interpolation']\n    elif reg_tool == 'fsl':\n        apply_xfm.inputs.inputspec.interpolation = cfg.registration_workflows[\n            'functional_registration']['func_registration_to_template'][\n            'FNIRT_pipelines']['interpolation']\n\n    connect = strat_pool.get_data(\"desc-preproc_bold\")\n\n    if opt == 'default':\n        node, out = strat_pool.get_data('desc-preproc_bold')\n        out_label = 'desc-preproc_bold'\n    elif opt == 'single_step_resampling_from_stc':\n        node, out = strat_pool.get_data('desc-stc_bold')\n        out_label = 'desc-stc_bold'\n    elif opt == 'abcd':\n        node, out = strat_pool.get_data('bold')\n        out_label = 'bold'\n\n    wf.connect(node, out, apply_xfm, 'inputspec.input_image')\n\n    node, out = strat_pool.get_data(\"sbref\")\n    wf.connect(node, out, apply_xfm, 'inputspec.reference')\n\n    wf.connect(blip_node, blip_out, apply_xfm, 'inputspec.transform')\n\n    outputs = {\n        out_label: (apply_xfm, 'outputspec.output_image')\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "warp_wholeheadT1_to_template",
    "file": "CPAC/registration/registration.py",
    "line_number": 3529,
    "decorator_args": {
      "name": "transform_whole_head_T1w_to_T1template",
      "config": [
        "registration_workflows",
        "anatomical_registration"
      ],
      "switch": [
        "run"
      ],
      "inputs": [
        [
          "desc-head_T1w",
          "from-T1w_to-template_mode-image_xfm",
          "space-template_desc-head_T1w"
        ],
        "T1w-template"
      ],
      "outputs": "!UNSUPPORTED_TYPE:Dict!"
    },
    "docstring": null,
    "source_code": "def warp_wholeheadT1_to_template(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    xfm_prov = strat_pool.get_cpac_provenance(\n        'from-T1w_to-template_mode-image_xfm')\n    reg_tool = check_prov_for_regtool(xfm_prov)\n\n    num_cpus = cfg.pipeline_setup['system_config'][\n        'max_cores_per_participant']\n\n    num_ants_cores = cfg.pipeline_setup['system_config']['num_ants_threads']\n\n    apply_xfm = apply_transform(f'warp_wholehead_T1w_to_T1template_{pipe_num}', \n                                reg_tool, time_series=False, num_cpus=num_cpus,\n                                num_ants_cores=num_ants_cores)\n\n    if reg_tool == 'ants':\n        apply_xfm.inputs.inputspec.interpolation = cfg.registration_workflows[\n            'functional_registration']['func_registration_to_template'][\n            'ANTs_pipelines']['interpolation']\n    elif reg_tool == 'fsl':\n        apply_xfm.inputs.inputspec.interpolation = cfg.registration_workflows[\n            'functional_registration']['func_registration_to_template'][\n            'FNIRT_pipelines']['interpolation']\n\n    connect = strat_pool.get_data(\"desc-head_T1w\")\n    node, out = connect\n    wf.connect(node, out, apply_xfm, 'inputspec.input_image')\n\n    node, out = strat_pool.get_data(\"T1w-template\")\n    wf.connect(node, out, apply_xfm, 'inputspec.reference')\n\n    node, out = strat_pool.get_data(\"from-T1w_to-template_mode-image_xfm\")\n    wf.connect(node, out, apply_xfm, 'inputspec.transform')\n\n    outputs = {\n        'space-template_desc-head_T1w': (apply_xfm, 'outputspec.output_image')\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "warp_T1mask_to_template",
    "file": "CPAC/registration/registration.py",
    "line_number": 3583,
    "decorator_args": {
      "name": "transform_T1mask_to_T1template",
      "switch": [
        [
          "registration_workflows",
          "anatomical_registration",
          "run"
        ],
        [
          "anatomical_preproc",
          "run"
        ],
        [
          "anatomical_preproc",
          "brain_extraction",
          "run"
        ]
      ],
      "inputs": [
        [
          "space-T1w_desc-brain_mask",
          "from-T1w_to-template_mode-image_xfm"
        ],
        "T1w-template"
      ],
      "outputs": "!UNSUPPORTED_TYPE:Dict!"
    },
    "docstring": null,
    "source_code": "def warp_T1mask_to_template(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    xfm_prov = strat_pool.get_cpac_provenance(\n        'from-T1w_to-template_mode-image_xfm')\n    reg_tool = check_prov_for_regtool(xfm_prov)\n\n    num_cpus = cfg.pipeline_setup['system_config'][\n        'max_cores_per_participant']\n\n    num_ants_cores = cfg.pipeline_setup['system_config']['num_ants_threads']\n\n    apply_xfm = apply_transform(f'warp_T1mask_to_T1template_{pipe_num}', \n                                reg_tool, time_series=False, num_cpus=num_cpus,\n                                num_ants_cores=num_ants_cores)\n\n    apply_xfm.inputs.inputspec.interpolation = \"NearestNeighbor\"\n    '''\n    if reg_tool == 'ants':\n        apply_xfm.inputs.inputspec.interpolation = cfg.registration_workflows[\n            'functional_registration']['func_registration_to_template'][\n            'ANTs_pipelines']['interpolation']\n    elif reg_tool == 'fsl':\n        apply_xfm.inputs.inputspec.interpolation = cfg.registration_workflows[\n            'functional_registration']['func_registration_to_template'][\n            'FNIRT_pipelines']['interpolation']\n    '''\n    connect = strat_pool.get_data(\"space-T1w_desc-brain_mask\")\n    node, out = connect\n    wf.connect(node, out, apply_xfm, 'inputspec.input_image')\n\n    node, out = strat_pool.get_data(\"T1w-template\")\n    wf.connect(node, out, apply_xfm, 'inputspec.reference')\n\n    node, out = strat_pool.get_data(\"from-T1w_to-template_mode-image_xfm\")\n    wf.connect(node, out, apply_xfm, 'inputspec.transform')\n\n    outputs = {\n        'space-template_desc-brain_mask': (apply_xfm, 'outputspec.output_image')\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "warp_timeseries_to_T1template",
    "file": "CPAC/registration/registration.py",
    "line_number": 3645,
    "decorator_args": {
      "name": "transform_timeseries_to_T1template",
      "config": [
        "registration_workflows",
        "functional_registration",
        "func_registration_to_template"
      ],
      "switch": [
        "run"
      ],
      "option_key": [
        "apply_transform",
        "using"
      ],
      "option_val": "default",
      "inputs": [
        [
          "desc-preproc_bold",
          "from-bold_to-template_mode-image_xfm"
        ],
        "T1w-brain-template-funcreg"
      ],
      "outputs": "!UNSUPPORTED_TYPE:Dict!"
    },
    "docstring": null,
    "source_code": "def warp_timeseries_to_T1template(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    xfm_prov = strat_pool.get_cpac_provenance(\n        'from-bold_to-template_mode-image_xfm')\n    reg_tool = check_prov_for_regtool(xfm_prov)\n\n    num_cpus = cfg.pipeline_setup['system_config'][\n        'max_cores_per_participant']\n\n    num_ants_cores = cfg.pipeline_setup['system_config']['num_ants_threads']\n\n    apply_xfm = apply_transform(f'warp_ts_to_T1template_{pipe_num}', reg_tool,\n                                time_series=True, num_cpus=num_cpus,\n                                num_ants_cores=num_ants_cores)\n\n    if reg_tool == 'ants':\n        apply_xfm.inputs.inputspec.interpolation = cfg.registration_workflows[\n            'functional_registration']['func_registration_to_template'][\n            'ANTs_pipelines']['interpolation']\n    elif reg_tool == 'fsl':\n        apply_xfm.inputs.inputspec.interpolation = cfg.registration_workflows[\n            'functional_registration']['func_registration_to_template'][\n            'FNIRT_pipelines']['interpolation']\n\n    connect = strat_pool.get_data(\"desc-preproc_bold\")\n    node, out = connect\n    wf.connect(node, out, apply_xfm, 'inputspec.input_image')\n\n    node, out = strat_pool.get_data(\"T1w-brain-template-funcreg\")\n    wf.connect(node, out, apply_xfm, 'inputspec.reference')\n\n    node, out = strat_pool.get_data(\"from-bold_to-template_mode-image_xfm\")\n    wf.connect(node, out, apply_xfm, 'inputspec.transform')\n\n    outputs = {\n        'space-template_desc-preproc_bold': (apply_xfm, 'outputspec.output_image')\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "warp_timeseries_to_T1template_deriv",
    "file": "CPAC/registration/registration.py",
    "line_number": 3706,
    "decorator_args": {
      "name": "transform_timeseries_to_T1template_deriv",
      "config": [
        "registration_workflows",
        "functional_registration",
        "func_registration_to_template"
      ],
      "switch": [
        "run"
      ],
      "option_key": [
        "apply_transform",
        "using"
      ],
      "option_val": "default",
      "inputs": [
        [
          "desc-preproc_bold",
          "from-bold_to-template_mode-image_xfm"
        ],
        "T1w-brain-template-funcreg"
      ],
      "outputs": "!UNSUPPORTED_TYPE:Dict!"
    },
    "docstring": null,
    "source_code": "def warp_timeseries_to_T1template_deriv(wf, cfg, strat_pool, pipe_num,\n                                        opt=None):\n    xfm_prov = strat_pool.get_cpac_provenance(\n        'from-bold_to-template_mode-image_xfm')\n    reg_tool = check_prov_for_regtool(xfm_prov)\n\n    num_cpus = cfg.pipeline_setup['system_config'][\n        'max_cores_per_participant']\n\n    num_ants_cores = cfg.pipeline_setup['system_config']['num_ants_threads']\n\n    apply_xfm = apply_transform(f'warp_ts_to_T1template_{pipe_num}', reg_tool,\n                                time_series=True, num_cpus=num_cpus,\n                                num_ants_cores=num_ants_cores)\n\n    if reg_tool == 'ants':\n        apply_xfm.inputs.inputspec.interpolation = cfg.registration_workflows[\n            'functional_registration']['func_registration_to_template'][\n            'ANTs_pipelines']['interpolation']\n    elif reg_tool == 'fsl':\n        apply_xfm.inputs.inputspec.interpolation = cfg.registration_workflows[\n            'functional_registration']['func_registration_to_template'][\n            'FNIRT_pipelines']['interpolation']\n\n    connect = strat_pool.get_data(\"desc-preproc_bold\")\n    node, out = connect\n    wf.connect(node, out, apply_xfm, 'inputspec.input_image')\n\n    node, out = strat_pool.get_data(\"T1w-brain-template-deriv\")\n    wf.connect(node, out, apply_xfm, 'inputspec.reference')\n\n    node, out = strat_pool.get_data(\"from-bold_to-template_mode-image_xfm\")\n    wf.connect(node, out, apply_xfm, 'inputspec.transform')\n\n    outputs = {\n        'space-template_res-derivative_desc-preproc_bold': \n            (apply_xfm, 'outputspec.output_image')\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "warp_timeseries_to_T1template_abcd",
    "file": "CPAC/registration/registration.py",
    "line_number": 3779,
    "decorator_args": {
      "name": "transform_timeseries_to_T1template_abcd",
      "config": [
        "registration_workflows",
        "functional_registration",
        "func_registration_to_template"
      ],
      "switch": [
        "run"
      ],
      "option_key": [
        "apply_transform",
        "using"
      ],
      "option_val": "abcd",
      "inputs": [
        [
          "desc-preproc_bold",
          "bold",
          "motion-basefile",
          "coordinate-transformation"
        ],
        "from-T1w_to-template_mode-image_xfm",
        "from-bold_to-T1w_mode-image_desc-linear_xfm",
        "from-bold_to-template_mode-image_xfm",
        "fsl-blip-warp",
        "desc-preproc_T1w",
        "space-template_res-bold_desc-brain_T1w",
        "space-template_desc-bold_mask",
        "T1w-brain-template-funcreg"
      ],
      "outputs": "!UNSUPPORTED_TYPE:Dict!"
    },
    "docstring": null,
    "source_code": "def warp_timeseries_to_T1template_abcd(wf, cfg, strat_pool, pipe_num, opt=None\n                                       ):\n    # Apply motion correction, coreg, anat-to-template transforms on raw functional timeseries using ABCD-style registration\n    # Ref: https://github.com/DCAN-Labs/DCAN-HCP/blob/master/fMRIVolume/scripts/OneStepResampling.sh#L168-L197\n\n    # https://github.com/DCAN-Labs/DCAN-HCP/blob/master/fMRIVolume/scripts/DistortionCorrectionAndEPIToT1wReg_FLIRTBBRAndFreeSurferBBRbased.sh#L548\n    # convertwarp --relout --rel -m ${WD}/fMRI2str.mat --ref=${T1wImage} --out=${WD}/fMRI2str.nii.gz\n    convert_func_to_anat_linear_warp = pe.Node(interface=fsl.ConvertWarp(),\n        name=f'convert_func_to_anat_linear_warp_{pipe_num}')\n\n    convert_func_to_anat_linear_warp.inputs.out_relwarp = True\n    convert_func_to_anat_linear_warp.inputs.relwarp = True\n    \n    node, out = strat_pool.get_data('desc-preproc_T1w')\n    wf.connect(node, out, convert_func_to_anat_linear_warp, 'reference')\n    \n    if strat_pool.check_rpool('fsl-blip-warp'):\n        node, out = strat_pool.get_data('from-bold_to-T1w_mode-image_desc-linear_xfm')\n        wf.connect(node, out, convert_func_to_anat_linear_warp, 'postmat')\n\n        node, out = strat_pool.get_data('fsl-blip-warp')\n        wf.connect(node, out, convert_func_to_anat_linear_warp, 'warp1')\n    else:\n        node, out = strat_pool.get_data('from-bold_to-T1w_mode-image_desc-linear_xfm')\n        wf.connect(node, out, convert_func_to_anat_linear_warp, 'premat')\n\n    # https://github.com/DCAN-Labs/DCAN-HCP/blob/master/fMRIVolume/scripts/OneStepResampling.sh#L140\n    # convertwarp --relout --rel --warp1=${fMRIToStructuralInput} --warp2=${StructuralToStandard} --ref=${WD}/${T1wImageFile}.${FinalfMRIResolution} --out=${OutputTransform}\n    convert_func_to_standard_warp = pe.Node(interface=fsl.ConvertWarp(),\n        name=f'convert_func_to_standard_warp_{pipe_num}')\n\n    convert_func_to_standard_warp.inputs.out_relwarp = True\n    convert_func_to_standard_warp.inputs.relwarp = True\n\n    wf.connect(convert_func_to_anat_linear_warp, 'out_file',\n        convert_func_to_standard_warp, 'warp1')\n\n    node, out = strat_pool.get_data('from-T1w_to-template_mode-image_xfm')\n    wf.connect(node, out, convert_func_to_standard_warp, 'warp2')\n\n    node, out = strat_pool.get_data('space-template_res-bold_desc-brain_T1w')\n    wf.connect(node, out, convert_func_to_standard_warp, 'reference')\n\n    # TODO add condition: if no gradient distortion\n    # https://github.com/DCAN-Labs/DCAN-HCP/blob/master/fMRIVolume/GenericfMRIVolumeProcessingPipeline.sh#L283-L284\n    # fslroi \"$fMRIFolder\"/\"$NameOffMRI\"_gdc \"$fMRIFolder\"/\"$NameOffMRI\"_gdc_warp 0 3\n    extract_func_roi = pe.Node(interface=fsl.ExtractROI(),\n        name=f'extract_func_roi_{pipe_num}')\n\n    extract_func_roi.inputs.t_min = 0\n    extract_func_roi.inputs.t_size = 3\n\n    node, out = strat_pool.get_data('bold')\n    wf.connect(node, out, extract_func_roi, 'in_file')\n\n    # fslmaths \"$fMRIFolder\"/\"$NameOffMRI\"_gdc_warp -mul 0 \"$fMRIFolder\"/\"$NameOffMRI\"_gdc_warp\n    multiply_func_roi_by_zero = pe.Node(interface=fsl.maths.MathsCommand(),\n                                        name=f'multiply_func_roi_by_zero_{pipe_num}')\n\n    multiply_func_roi_by_zero.inputs.args = '-mul 0'\n\n    wf.connect(extract_func_roi, 'roi_file',\n        multiply_func_roi_by_zero, 'in_file')\n\n    # https://github.com/DCAN-Labs/DCAN-HCP/blob/master/fMRIVolume/scripts/OneStepResampling.sh#L168-L193\n    # fslsplit ${InputfMRI} ${WD}/prevols/vol -t\n    split_func = pe.Node(interface=fsl.Split(),\n        name=f'split_func_{pipe_num}')\n\n    split_func.inputs.dimension = 't'\n\n    node, out = strat_pool.get_data('bold')\n    wf.connect(node, out, split_func, 'in_file')\n\n    ### Loop starts! ###\n    # convertwarp --relout --rel --ref=${WD}/prevols/vol${vnum}.nii.gz --warp1=${GradientDistortionField} --postmat=${MotionMatrixFolder}/${MotionMatrixPrefix}${vnum} --out=${MotionMatrixFolder}/${MotionMatrixPrefix}${vnum}_gdc_warp.nii.gz\n    convert_motion_distortion_warp = pe.MapNode(interface=fsl.ConvertWarp(),\n        name=f'convert_motion_distortion_warp_{pipe_num}',\n        iterfield=['reference', 'postmat'])\n\n    convert_motion_distortion_warp.inputs.out_relwarp = True\n    convert_motion_distortion_warp.inputs.relwarp = True\n\n    wf.connect(multiply_func_roi_by_zero, 'out_file',\n        convert_motion_distortion_warp, 'warp1')\n\n    wf.connect(split_func, 'out_files',\n        convert_motion_distortion_warp, 'reference')\n\n    node, out = strat_pool.get_data('coordinate-transformation')\n    wf.connect(node, out, convert_motion_distortion_warp, 'postmat')\n\n    # convertwarp --relout --rel --ref=${WD}/${T1wImageFile}.${FinalfMRIResolution} --warp1=${MotionMatrixFolder}/${MotionMatrixPrefix}${vnum}_gdc_warp.nii.gz --warp2=${OutputTransform} --out=${MotionMatrixFolder}/${MotionMatrixPrefix}${vnum}_all_warp.nii.gz\n    convert_registration_warp = pe.MapNode(interface=fsl.ConvertWarp(),\n        name=f'convert_registration_warp_{pipe_num}',\n        iterfield=['warp1'])\n\n    convert_registration_warp.inputs.out_relwarp = True\n    convert_registration_warp.inputs.relwarp = True\n\n    node, out = strat_pool.get_data('space-template_res-bold_desc-brain_T1w')\n    wf.connect(node, out, convert_registration_warp, 'reference')\n\n    wf.connect(convert_motion_distortion_warp, 'out_file',\n        convert_registration_warp, 'warp1')\n\n    wf.connect(convert_func_to_standard_warp, 'out_file',\n        convert_registration_warp, 'warp2')\n\n    # fslmaths ${WD}/prevols/vol${vnum}.nii.gz -mul 0 -add 1 ${WD}/prevols/vol${vnum}_mask.nii.gz\n    generate_vol_mask = pe.MapNode(interface=fsl.maths.MathsCommand(),\n                        name=f'generate_mask_{pipe_num}',\n                        iterfield=['in_file'])\n\n    generate_vol_mask.inputs.args = '-mul 0 -add 1'\n\n    wf.connect(split_func, 'out_files',\n        generate_vol_mask, 'in_file')\n\n    # applywarp --rel --interp=spline --in=${WD}/prevols/vol${vnum}.nii.gz --warp=${MotionMatrixFolder}/${MotionMatrixPrefix}${vnum}_all_warp.nii.gz --ref=${WD}/${T1wImageFile}.${FinalfMRIResolution} --out=${WD}/postvols/vol${vnum}.nii.gz\n    applywarp_func_to_standard = pe.MapNode(interface=fsl.ApplyWarp(),\n                                    name=f'applywarp_func_to_standard_{pipe_num}',\n                                    iterfield=['in_file', 'field_file'])\n\n    applywarp_func_to_standard.inputs.relwarp = True\n    applywarp_func_to_standard.inputs.interp = 'spline'\n\n    wf.connect(split_func, 'out_files',\n        applywarp_func_to_standard, 'in_file')\n\n    wf.connect(convert_registration_warp, 'out_file',\n        applywarp_func_to_standard, 'field_file')\n\n    node, out = strat_pool.get_data('space-template_res-bold_desc-brain_T1w')\n    wf.connect(node, out,\n        applywarp_func_to_standard, 'ref_file')\n\n    # applywarp --rel --interp=nn --in=${WD}/prevols/vol${vnum}_mask.nii.gz --warp=${MotionMatrixFolder}/${MotionMatrixPrefix}${vnum}_all_warp.nii.gz --ref=${WD}/${T1wImageFile}.${FinalfMRIResolution} --out=${WD}/postvols/vol${vnum}_mask.nii.gz\n    applywarp_func_mask_to_standard = pe.MapNode(interface=fsl.ApplyWarp(),\n                                    name=f'applywarp_func_mask_to_standard_{pipe_num}',\n                                    iterfield=['in_file', 'field_file'])\n\n    applywarp_func_mask_to_standard.inputs.relwarp = True\n    applywarp_func_mask_to_standard.inputs.interp = 'nn'\n\n    wf.connect(generate_vol_mask, 'out_file',\n        applywarp_func_mask_to_standard, 'in_file')\n\n    wf.connect(convert_registration_warp, 'out_file',\n        applywarp_func_mask_to_standard, 'field_file')\n\n    node, out = strat_pool.get_data('space-template_res-bold_desc-brain_T1w')\n    wf.connect(node, out,\n        applywarp_func_mask_to_standard, 'ref_file')\n\n    ### Loop ends! ###\n\n    # fslmerge -tr ${OutputfMRI} $FrameMergeSTRING $TR_vol\n    merge_func_to_standard = pe.Node(interface=fslMerge(),\n                                     name=f'merge_func_to_standard_{pipe_num}')\n\n    merge_func_to_standard.inputs.dimension = 't'\n\n    wf.connect(applywarp_func_to_standard, 'out_file',\n        merge_func_to_standard, 'in_files')\n\n    # fslmerge -tr ${OutputfMRI}_mask $FrameMergeSTRINGII $TR_vol\n    merge_func_mask_to_standard = pe.Node(interface=fslMerge(),\n                                          name='merge_func_mask_to_'\n                                               f'standard_{pipe_num}')\n\n    merge_func_mask_to_standard.inputs.dimension = 't'\n\n    wf.connect(applywarp_func_mask_to_standard, 'out_file',\n        merge_func_mask_to_standard, 'in_files')\n\n    # fslmaths ${OutputfMRI}_mask -Tmin ${OutputfMRI}_mask\n    find_min_mask = pe.Node(interface=fsl.maths.MathsCommand(),\n                        name=f'find_min_mask_{pipe_num}')\n\n    find_min_mask.inputs.args = '-Tmin'\n\n    wf.connect(merge_func_mask_to_standard, 'merged_file',\n        find_min_mask, 'in_file')\n\n    # Combine transformations: gradient non-linearity distortion + fMRI_dc to standard\n    # convertwarp --relout --rel --ref=${WD}/${T1wImageFile}.${FinalfMRIResolution} --warp1=${GradientDistortionField} --warp2=${OutputTransform} --out=${WD}/Scout_gdc_MNI_warp.nii.gz\n    convert_dc_warp = pe.Node(interface=fsl.ConvertWarp(),\n        name=f'convert_dc_warp_{pipe_num}')\n\n    convert_dc_warp.inputs.out_relwarp = True\n    convert_dc_warp.inputs.relwarp = True\n\n    node, out = strat_pool.get_data('space-template_res-bold_desc-brain_T1w')\n    wf.connect(node, out, convert_dc_warp, 'reference')\n\n    wf.connect(multiply_func_roi_by_zero, 'out_file',\n        convert_dc_warp, 'warp1')\n\n    wf.connect(convert_func_to_standard_warp, 'out_file',\n        convert_dc_warp, 'warp2')\n\n    # applywarp --rel --interp=spline --in=${ScoutInput} -w ${WD}/Scout_gdc_MNI_warp.nii.gz -r ${WD}/${T1wImageFile}.${FinalfMRIResolution} -o ${ScoutOutput}\n    applywarp_scout = pe.Node(interface=fsl.ApplyWarp(),\n        name=f'applywarp_scout_input_{pipe_num}')\n\n    applywarp_scout.inputs.relwarp = True\n    applywarp_scout.inputs.interp = 'spline'\n\n    node, out = strat_pool.get_data('motion-basefile')\n    wf.connect(node, out, applywarp_scout, 'in_file')\n\n    node, out = strat_pool.get_data('space-template_res-bold_desc-brain_T1w')\n    wf.connect(node, out, applywarp_scout, 'ref_file')\n\n    wf.connect(convert_dc_warp, 'out_file', applywarp_scout, 'field_file')\n\n    # https://github.com/DCAN-Labs/DCAN-HCP/blob/master/fMRIVolume/scripts/IntensityNormalization.sh#L124-L127\n    # fslmaths ${InputfMRI} -mas ${BrainMask} -mas ${InputfMRI}_mask -thr 0 -ing 10000 ${OutputfMRI} -odt float\n    merge_func_mask = pe.Node(util.Merge(2),\n        name=f'merge_func_mask_{pipe_num}')\n\n    node, out = strat_pool.get_data('space-template_desc-bold_mask')\n    wf.connect(node, out, merge_func_mask, 'in1')\n\n    wf.connect(find_min_mask, 'out_file', merge_func_mask, 'in2')\n\n    extract_func_brain = pe.Node(interface=fsl.MultiImageMaths(),\n                        name=f'extract_func_brain_{pipe_num}')\n\n    extract_func_brain.inputs.op_string = '-mas %s -mas %s -thr 0 -ing 10000'\n    extract_func_brain.inputs.output_datatype = 'float'\n\n    wf.connect(merge_func_to_standard, 'merged_file',\n        extract_func_brain, 'in_file')\n\n    wf.connect(merge_func_mask, 'out',\n        extract_func_brain, 'operand_files')\n\n    # fslmaths ${ScoutInput} -mas ${BrainMask} -mas ${InputfMRI}_mask -thr 0 -ing 10000 ${ScoutOutput} -odt float\n    extract_scout_brain = pe.Node(interface=fsl.MultiImageMaths(),\n        name=f'extract_scout_brain_{pipe_num}')\n\n    extract_scout_brain.inputs.op_string = '-mas %s -mas %s -thr 0 -ing 10000'\n    extract_scout_brain.inputs.output_datatype = 'float'\n\n    wf.connect(applywarp_scout, 'out_file',\n        extract_scout_brain, 'in_file')\n\n    wf.connect(merge_func_mask, 'out',\n        extract_scout_brain, 'operand_files')\n\n    outputs = {\n        'space-template_desc-preproc_bold': (extract_func_brain, 'out_file'),\n        'space-template_desc-scout_bold': (extract_scout_brain, 'out_file'),\n        'space-template_desc-head_bold': (merge_func_to_standard, 'merged_file')\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "warp_timeseries_to_T1template_dcan_nhp",
    "file": "CPAC/registration/registration.py",
    "line_number": 4067,
    "decorator_args": {
      "name": "transform_timeseries_to_T1template_dcan_nhp",
      "config": [
        "registration_workflows",
        "functional_registration",
        "func_registration_to_template"
      ],
      "switch": [
        "run"
      ],
      "option_key": [
        "apply_transform",
        "using"
      ],
      "option_val": "dcan_nhp",
      "inputs": [
        [
          [
            "desc-reorient_bold",
            "bold"
          ],
          "coordinate-transformation",
          "from-T1w_to-template_mode-image_warp",
          "from-bold_to-T1w_mode-image_desc-linear_warp",
          "T1w-template",
          "space-template_desc-head_T1w",
          "space-template_desc-T1w_mask",
          "space-template_desc-T1wT2w_biasfield"
        ]
      ],
      "outputs": "!UNSUPPORTED_TYPE:Dict!"
    },
    "docstring": null,
    "source_code": "def warp_timeseries_to_T1template_dcan_nhp(wf, cfg, strat_pool, pipe_num,\n                                           opt=None):\n    # Apply motion correction, coreg, anat-to-template transforms on raw functional timeseries\n    # Ref: https://github.com/DCAN-Labs/dcan-macaque-pipeline/blob/master/fMRIVolume/scripts/OneStepResampling.sh\n\n    # https://github.com/DCAN-Labs/dcan-macaque-pipeline/blob/master/fMRIVolume/scripts/OneStepResampling.sh#L131\n    # ${FSLDIR}/bin/flirt -interp spline -in ${T1wImage} -ref ${T1wImage} -applyisoxfm $FinalfMRIResolution -out ${WD}/${T1wImageFile}.${FinalfMRIResolution}\n    anat_resample = pe.Node(interface=fsl.FLIRT(),\n                            name=f'anat_resample_func_res_{pipe_num}'\n                            )\n    anat_resample.inputs.apply_isoxfm = float(cfg.registration_workflows['functional_registration']['func_registration_to_template']['output_resolution']['func_preproc_outputs'].replace(\"mm\", \"\"))\n    anat_resample.inputs.interp = 'spline'\n\n    node, out = strat_pool.get_data('space-template_desc-head_T1w')\n    wf.connect(node, out, anat_resample, 'in_file')\n    wf.connect(node, out, anat_resample, 'reference')\n\n    # ${FSLDIR}/bin/applywarp --rel --interp=spline -i ${T1wImage} -r ${ResampRefIm} --premat=$FSLDIR/etc/flirtsch/ident.mat -o ${WD}/${T1wImageFile}.${FinalfMRIResolution}\n    applywarp_anat_res = pe.Node(interface=fsl.ApplyWarp(),\n                                name=f'anat_func_res_{pipe_num}')\n\n    applywarp_anat_res.inputs.relwarp = True\n    applywarp_anat_res.inputs.interp = 'spline'\n    applywarp_anat_res.inputs.premat = cfg.registration_workflows['anatomical_registration']['registration']['FSL-FNIRT']['identity_matrix']\n\n    node, out = strat_pool.get_data('space-template_desc-head_T1w')\n    wf.connect(node, out, applywarp_anat_res, 'in_file')\n    wf.connect(anat_resample, 'out_file', applywarp_anat_res, 'ref_file')\n\n    # https://github.com/DCAN-Labs/dcan-macaque-pipeline/blob/master/fMRIVolume/scripts/OneStepResampling.sh#L136-L138\n    # Create brain masks in this space (changing resolution)\n    # ${FSLDIR}/bin/applywarp --rel --interp=nn -i ${FreeSurferBrainMask}.nii.gz -r ${WD}/${T1wImageFile}.${FinalfMRIResolution} --premat=$FSLDIR/etc/flirtsch/ident.mat -o ${WD}/${FreeSurferBrainMaskFile}.${FinalfMRIResolution}.nii.gz\n    applywarp_anat_mask_res = pe.Node(interface=fsl.ApplyWarp(),\n                                name=f'anat_mask_func_res_{pipe_num}')\n    applywarp_anat_mask_res.inputs.relwarp = True\n    applywarp_anat_mask_res.inputs.interp = 'nn'\n    applywarp_anat_mask_res.inputs.premat = cfg.registration_workflows['anatomical_registration']['registration']['FSL-FNIRT']['identity_matrix']\n\n    node, out = strat_pool.get_data('space-template_desc-T1w_mask')\n    wf.connect(node, out, applywarp_anat_mask_res, 'in_file')\n    wf.connect(applywarp_anat_res, 'out_file', applywarp_anat_mask_res, 'ref_file')\n\n    # ${FSLDIR}/bin/fslmaths ${WD}/${T1wImageFile}.${FinalfMRIResolution} -mas ${WD}/${FreeSurferBrainMaskFile}.${FinalfMRIResolution}.nii.gz ${WD}/${FreeSurferBrainMaskFile}.${FinalfMRIResolution}.nii.gz\n    T1_brain_res = pe.Node(interface=fsl.MultiImageMaths(),\n                                  name=f't1_brain_func_res_{pipe_num}')\n    T1_brain_res.inputs.op_string = \"-mas %s \"\n\n    wf.connect(applywarp_anat_res, 'out_file', T1_brain_res, 'in_file')\n    wf.connect(applywarp_anat_mask_res, 'out_file', T1_brain_res, 'operand_files')\n\n    # Create versions of the biasfield (changing resolution)\n    # ${FSLDIR}/bin/applywarp --rel --interp=spline -i ${BiasField} -r ${WD}/${FreeSurferBrainMaskFile}.${FinalfMRIResolution}.nii.gz --premat=$FSLDIR/etc/flirtsch/ident.mat -o ${WD}/${BiasFieldFile}.${FinalfMRIResolution}\n    applywarp_bias_field_res = pe.Node(interface=fsl.ApplyWarp(),\n                                name=f'biasfiled_func_res_{pipe_num}')\n    applywarp_bias_field_res.inputs.relwarp = True\n    applywarp_bias_field_res.inputs.interp = 'spline'\n    applywarp_bias_field_res.inputs.premat = cfg.registration_workflows['anatomical_registration']['registration']['FSL-FNIRT']['identity_matrix']\n\n    node, out = strat_pool.get_data('space-template_desc-T1wT2w_biasfield')\n    wf.connect(node, out, applywarp_bias_field_res, 'in_file')\n    wf.connect(T1_brain_res, 'out_file', applywarp_bias_field_res, 'ref_file')\n\n    # ${FSLDIR}/bin/fslmaths ${WD}/${BiasFieldFile}.${FinalfMRIResolution} -thr 0.1 ${WD}/${BiasFieldFile}.${FinalfMRIResolution}\n    biasfield_thr = pe.Node(interface=fsl.MultiImageMaths(),\n                                  name=f'biasfiedl_thr_{pipe_num}')\n    biasfield_thr.inputs.op_string = \"-thr 0.1\"\n\n    wf.connect(applywarp_bias_field_res, 'out_file', biasfield_thr, 'in_file')\n\n    # https://github.com/DCAN-Labs/dcan-macaque-pipeline/blob/master/fMRIVolume/scripts/OneStepResampling.sh#L144-L146\n    # convertwarp --relout --rel --warp1=${fMRIToStructuralInput} --warp2=${StructuralToStandard} --ref=${WD}/${T1wImageFile}.${FinalfMRIResolution} --out=${OutputTransform}\n    convert_func_to_standard_warp = pe.Node(interface=fsl.ConvertWarp(),\n        name=f'convert_func_to_standard_warp_{pipe_num}')\n\n    convert_func_to_standard_warp.inputs.out_relwarp = True\n    convert_func_to_standard_warp.inputs.relwarp = True\n\n    node, out = strat_pool.get_data('from-bold_to-T1w_mode-image_desc-linear_warp')\n    wf.connect(node, out, convert_func_to_standard_warp, 'warp1')\n\n    node, out = strat_pool.get_data('from-T1w_to-template_mode-image_warp')\n    wf.connect(node, out, convert_func_to_standard_warp, 'warp2')\n\n    wf.connect(applywarp_anat_res, 'out_file', convert_func_to_standard_warp, 'reference')\n\n    # https://github.com/DCAN-Labs/dcan-macaque-pipeline/blob/master/fMRIVolume/GenericfMRIVolumeProcessingPipeline.sh#L157-L158\n    # fslroi \"$fMRIFolder\"/\"$NameOffMRI\"_gdc \"$fMRIFolder\"/\"$NameOffMRI\"_gdc_warp 0 3\n    extract_func_roi = pe.Node(interface=fsl.ExtractROI(),\n        name=f'extract_func_roi_{pipe_num}')\n\n    extract_func_roi.inputs.t_min = 0\n    extract_func_roi.inputs.t_size = 3\n\n    node, out = strat_pool.get_data(['desc-reorient_bold', 'bold'])\n    wf.connect(node, out, extract_func_roi, 'in_file')\n\n    # fslmaths \"$fMRIFolder\"/\"$NameOffMRI\"_gdc_warp -mul 0 \"$fMRIFolder\"/\"$NameOffMRI\"_gdc_warp\n    multiply_func_roi_by_zero = pe.Node(interface=fsl.maths.MathsCommand(),\n                                        name=f'multiply_func_roi_by_zero_{pipe_num}')\n\n    multiply_func_roi_by_zero.inputs.args = '-mul 0'\n\n    wf.connect(extract_func_roi, 'roi_file',\n        multiply_func_roi_by_zero, 'in_file')\n\n    # https://github.com/DCAN-Labs/dcan-macaque-pipeline/blob/master/fMRIVolume/scripts/OneStepResampling.sh#L173\n    # fslsplit ${InputfMRI} ${WD}/prevols/vol -t\n    split_func = pe.Node(interface=fsl.Split(),\n        name=f'split_func_{pipe_num}')\n\n    split_func.inputs.dimension = 't'\n\n    node, out = strat_pool.get_data(['desc-reorient_bold', 'bold'])\n    wf.connect(node, out, split_func, 'in_file')\n\n    ### Loop starts! ###\n    # convertwarp --relout --rel --ref=${WD}/prevols/vol${vnum}.nii.gz --warp1=${GradientDistortionField} --postmat=${MotionMatrixFolder}/${MotionMatrixPrefix}${vnum} --out=${MotionMatrixFolder}/${MotionMatrixPrefix}${vnum}_gdc_warp.nii.gz\n    convert_motion_distortion_warp = pe.MapNode(interface=fsl.ConvertWarp(),\n        name=f'convert_motion_distortion_warp_{pipe_num}',\n        iterfield=['reference', 'postmat'])\n\n    convert_motion_distortion_warp.inputs.out_relwarp = True\n    convert_motion_distortion_warp.inputs.relwarp = True\n\n    wf.connect(multiply_func_roi_by_zero, 'out_file',\n        convert_motion_distortion_warp, 'warp1')\n\n    wf.connect(split_func, 'out_files',\n        convert_motion_distortion_warp, 'reference')\n\n    node, out = strat_pool.get_data('coordinate-transformation')\n    wf.connect(node, out, convert_motion_distortion_warp, 'postmat')\n\n    # convertwarp --relout --rel --ref=${WD}/${T1wImageFile}.${FinalfMRIResolution} --warp1=${MotionMatrixFolder}/${MotionMatrixPrefix}${vnum}_gdc_warp.nii.gz --warp2=${OutputTransform} --out=${MotionMatrixFolder}/${MotionMatrixPrefix}${vnum}_all_warp.nii.gz\n    convert_registration_warp = pe.MapNode(interface=fsl.ConvertWarp(),\n        name=f'convert_registration_warp_{pipe_num}',\n        iterfield=['warp1'])\n\n    convert_registration_warp.inputs.out_relwarp = True\n    convert_registration_warp.inputs.relwarp = True\n\n    wf.connect(applywarp_anat_res, 'out_file', convert_registration_warp, 'reference')\n\n    wf.connect(convert_motion_distortion_warp, 'out_file',\n        convert_registration_warp, 'warp1')\n\n    wf.connect(convert_func_to_standard_warp, 'out_file',\n        convert_registration_warp, 'warp2')\n\n    # fslmaths ${WD}/prevols/vol${vnum}.nii.gz -mul 0 -add 1 ${WD}/prevols/vol${vnum}_mask.nii.gz\n    generate_vol_mask = pe.MapNode(interface=fsl.maths.MathsCommand(),\n                        name=f'generate_mask_{pipe_num}',\n                        iterfield=['in_file'])\n\n    generate_vol_mask.inputs.args = '-mul 0 -add 1'\n\n    wf.connect(split_func, 'out_files',\n        generate_vol_mask, 'in_file')\n\n    # applywarp --rel --interp=spline --in=${WD}/prevols/vol${vnum}.nii.gz --warp=${MotionMatrixFolder}/${MotionMatrixPrefix}${vnum}_all_warp.nii.gz --ref=${WD}/${T1wImageFile}.${FinalfMRIResolution} --out=${WD}/postvols/vol${vnum}.nii.gz\n    applywarp_func_to_standard = pe.MapNode(interface=fsl.ApplyWarp(),\n                                    name=f'applywarp_func_to_standard_{pipe_num}',\n                                    iterfield=['in_file', 'field_file'])\n\n    applywarp_func_to_standard.inputs.relwarp = True\n    applywarp_func_to_standard.inputs.interp = 'spline'\n\n    wf.connect(split_func, 'out_files',\n        applywarp_func_to_standard, 'in_file')\n\n    wf.connect(convert_registration_warp, 'out_file',\n        applywarp_func_to_standard, 'field_file')\n\n    wf.connect(applywarp_anat_res, 'out_file',\n        applywarp_func_to_standard, 'ref_file')\n\n    # applywarp --rel --interp=nn --in=${WD}/prevols/vol${vnum}_mask.nii.gz --warp=${MotionMatrixFolder}/${MotionMatrixPrefix}${vnum}_all_warp.nii.gz --ref=${WD}/${T1wImageFile}.${FinalfMRIResolution} --out=${WD}/postvols/vol${vnum}_mask.nii.gz\n    applywarp_func_mask_to_standard = pe.MapNode(interface=fsl.ApplyWarp(),\n                                    name=f'applywarp_func_mask_to_standard_{pipe_num}',\n                                    iterfield=['in_file', 'field_file'])\n\n    applywarp_func_mask_to_standard.inputs.relwarp = True\n    applywarp_func_mask_to_standard.inputs.interp = 'nn'\n\n    wf.connect(generate_vol_mask, 'out_file',\n        applywarp_func_mask_to_standard, 'in_file')\n\n    wf.connect(convert_registration_warp, 'out_file',\n        applywarp_func_mask_to_standard, 'field_file')\n\n    wf.connect(applywarp_anat_res, 'out_file',\n        applywarp_func_mask_to_standard, 'ref_file')\n\n    ### Loop ends! ###\n\n    # fslmerge -tr ${OutputfMRI} $FrameMergeSTRING $TR_vol\n    merge_func_to_standard = pe.Node(interface=fslMerge(),\n                                     name=f'merge_func_to_standard_{pipe_num}')\n\n    merge_func_to_standard.inputs.dimension = 't'\n\n    wf.connect(applywarp_func_to_standard, 'out_file',\n        merge_func_to_standard, 'in_files')\n\n    # fslmerge -tr ${OutputfMRI}_mask $FrameMergeSTRINGII $TR_vol\n    merge_func_mask_to_standard = pe.Node(interface=fslMerge(),\n                                          name='merge_func_mask_to_'\n                                               f'standard_{pipe_num}')\n\n    merge_func_mask_to_standard.inputs.dimension = 't'\n\n    wf.connect(applywarp_func_mask_to_standard, 'out_file',\n        merge_func_mask_to_standard, 'in_files')\n\n    # fslmaths ${OutputfMRI}_mask -Tmin ${OutputfMRI}_mask\n    find_min_mask = pe.Node(interface=fsl.maths.MathsCommand(),\n        name=f'find_min_mask_{pipe_num}')\n\n    find_min_mask.inputs.args = '-Tmin'\n\n    wf.connect(merge_func_mask_to_standard, 'merged_file',\n        find_min_mask, 'in_file')\n\n    # https://github.com/DCAN-Labs/dcan-macaque-pipeline/blob/master/fMRIVolume/scripts/IntensityNormalization.sh#L113-L119\n    # fslmaths ${InputfMRI} -div ${BiasField} $jacobiancom -mas ${BrainMask} -mas ${InputfMRI}_mask -ing 10000 ${OutputfMRI} -odt float\n\n    merge_func_mask = pe.Node(util.Merge(3),\n                                name=f'merge_operand_files_{pipe_num}')\n\n    wf.connect(biasfield_thr, 'out_file', merge_func_mask, 'in1')\n\n    wf.connect(applywarp_anat_mask_res, 'out_file', merge_func_mask, 'in2')\n\n    wf.connect(find_min_mask, 'out_file', merge_func_mask, 'in3')\n\n\n    extract_func_brain = pe.Node(interface=fsl.MultiImageMaths(),\n                        name=f'extract_func_brain_{pipe_num}')\n\n    extract_func_brain.inputs.op_string = '-div %s -mas %s -mas %s -ing 10000'\n    extract_func_brain.inputs.output_datatype = 'float'\n\n    wf.connect(merge_func_to_standard, 'merged_file',\n        extract_func_brain, 'in_file')\n\n    wf.connect(merge_func_mask, 'out',\n        extract_func_brain, 'operand_files')\n\n    func_mask_final = pe.Node(interface=fsl.MultiImageMaths(),\n                                name=f'func_mask_final_{pipe_num}')\n    func_mask_final.inputs.op_string = \"-mas %s \"\n\n    wf.connect(applywarp_anat_mask_res, 'out_file', func_mask_final, 'in_file')\n\n    wf.connect(find_min_mask, 'out_file', func_mask_final, 'operand_files')\n\n    outputs = {\n        'space-template_desc-preproc_bold': (extract_func_brain, 'out_file'),\n        'space-template_desc-bold_mask': (func_mask_final, 'out_file')\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "single_step_resample_timeseries_to_T1template",
    "file": "CPAC/registration/registration.py",
    "line_number": 4376,
    "decorator_args": {
      "name": "single_step_resample_stc_timeseries_to_T1template",
      "config": [
        "registration_workflows",
        "functional_registration",
        "func_registration_to_template"
      ],
      "switch": [
        "run"
      ],
      "option_key": [
        "apply_transform",
        "using"
      ],
      "option_val": "single_step_resampling_from_stc",
      "inputs": [
        [
          "sbref",
          "desc-stc_bold",
          "motion-basefile",
          "space-bold_desc-brain_mask",
          "coordinate-transformation",
          "from-T1w_to-template_mode-image_xfm",
          "from-bold_to-T1w_mode-image_desc-linear_xfm",
          "from-bold_to-template_mode-image_xfm",
          "ants-blip-warp",
          "fsl-blip-warp",
          "T1w",
          "desc-preproc_T1w",
          "T1w-brain-template-funcreg",
          "T1w-brain-template-deriv"
        ]
      ],
      "outputs": "!UNSUPPORTED_TYPE:Dict!"
    },
    "docstring": "Apply motion correction, coreg, anat-to-template transforms on\nslice-time corrected functional timeseries based on fMRIPrep\npipeline\n\nCopyright (c) 2015-2018, the CRN developers team.\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions\nare met:\n\n* Redistributions of source code must retain the above copyright\nnotice, this list of conditions and the following disclaimer.\n\n* Redistributions in binary form must reproduce the above copyright\nnotice, this list of conditions and the following disclaimer in the\ndocumentation and/or other materials provided with the distribution.\n\n* Neither the name of fmriprep nor the names of its contributors\nmay be used to endorse or promote products derived from this\nsoftware without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\nFOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\nCOPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\nINDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\nHOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\nSTRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\nOF THE POSSIBILITY OF SUCH DAMAGE.\n\nRef: https://github.com/nipreps/fmriprep/blob/84a6005b/fmriprep/workflows/bold/resampling.py#L159-L419",
    "source_code": "def single_step_resample_timeseries_to_T1template(wf, cfg, strat_pool,\n                                                  pipe_num, opt=None):\n    '''\n    Apply motion correction, coreg, anat-to-template transforms on\n    slice-time corrected functional timeseries based on fMRIPrep\n    pipeline\n\n    Copyright (c) 2015-2018, the CRN developers team.\n    All rights reserved.\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n    * Redistributions of source code must retain the above copyright\n    notice, this list of conditions and the following disclaimer.\n\n    * Redistributions in binary form must reproduce the above copyright\n    notice, this list of conditions and the following disclaimer in the\n    documentation and/or other materials provided with the distribution.\n\n    * Neither the name of fmriprep nor the names of its contributors\n    may be used to endorse or promote products derived from this\n    software without specific prior written permission.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n    FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n    COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n    INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n    SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n    HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n    STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n    OF THE POSSIBILITY OF SUCH DAMAGE.\n\n    Ref: https://github.com/nipreps/fmriprep/blob/84a6005b/fmriprep/workflows/bold/resampling.py#L159-L419\n    '''  # noqa: 501\n    xfm_prov = strat_pool.get_cpac_provenance(\n        'from-T1w_to-template_mode-image_xfm')\n    reg_tool = check_prov_for_regtool(xfm_prov)\n\n    bbr2itk = pe.Node(util.Function(input_names=['reference_file',\n                                                 'source_file',\n                                                 'transform_file'],\n                                    output_names=['itk_transform'],\n                                    function=run_c3d),\n                      name=f'convert_bbr2itk_{pipe_num}')\n\n    if cfg.registration_workflows['functional_registration'][\n            'coregistration']['boundary_based_registration'][\n            'reference'] == 'whole-head':\n        node, out = strat_pool.get_data('T1w')\n        wf.connect(node, out, bbr2itk, 'reference_file')\n\n    elif cfg.registration_workflows['functional_registration'][\n            'coregistration']['boundary_based_registration'][\n            'reference'] == 'brain':\n        node, out = strat_pool.get_data('desc-preproc_T1w')\n        wf.connect(node, out, bbr2itk, 'reference_file')\n\n    node, out = strat_pool.get_data('sbref')\n    wf.connect(node, out, bbr2itk, 'source_file')\n\n    node, out = strat_pool.get_data(\n        'from-bold_to-T1w_mode-image_desc-linear_xfm')\n    wf.connect(node, out, bbr2itk, 'transform_file')\n\n    split_func = pe.Node(interface=fsl.Split(),\n        name=f'split_func_{pipe_num}')\n\n    split_func.inputs.dimension = 't'\n\n    node, out = strat_pool.get_data('desc-stc_bold')\n    wf.connect(node, out, split_func, 'in_file')\n\n    ### Loop starts! ###\n    motionxfm2itk = pe.MapNode(util.Function(\n        input_names=['reference_file',\n                     'source_file',\n                     'transform_file'],\n        output_names=['itk_transform'],\n        function=run_c3d),\n        name=f'convert_motionxfm2itk_{pipe_num}',\n        iterfield=['transform_file'])\n\n    node, out = strat_pool.get_data('motion-basefile')\n    wf.connect(node, out, motionxfm2itk, 'reference_file')\n    wf.connect(node, out, motionxfm2itk, 'source_file')\n\n    node, out = strat_pool.get_data('coordinate-transformation')\n    motion_correct_tool = check_prov_for_motion_tool(\n        strat_pool.get_cpac_provenance('coordinate-transformation'))\n    if motion_correct_tool == 'mcflirt':\n        wf.connect(node, out, motionxfm2itk, 'transform_file')\n    elif motion_correct_tool == '3dvolreg':\n        convert_transform = pe.Node(util.Function(\n            input_names=['one_d_filename'],\n            output_names=['transform_directory'],\n            function=one_d_to_mat,\n            imports=['import os', 'import numpy as np']),\n            name=f'convert_transform_{pipe_num}')\n        wf.connect(node, out, convert_transform, 'one_d_filename')\n        wf.connect(convert_transform, 'transform_directory',\n                   motionxfm2itk, 'transform_file')\n\n    merge_num = 4\n    blip = False\n    if strat_pool.check_rpool('ants-blip-warp') and reg_tool == 'ants':\n        blip_node, blip_out = strat_pool.get_data('ants-blip-warp')\n        merge_num = 5\n        blip = True\n    elif strat_pool.check_rpool('fsl-blip-warp') and reg_tool == 'fsl':\n        blip_node, blip_out = strat_pool.get_data('fsl-blip-warp')\n        merge_num = 5\n        blip = True\n\n    collectxfm = pe.MapNode(util.Merge(merge_num),\n                            name=f'collectxfm_func_to_standard_{pipe_num}',\n                            iterfield=[f'in{merge_num}'])\n\n    node, out = strat_pool.get_data('from-T1w_to-template_mode-image_xfm')\n    wf.connect(node, out, collectxfm, 'in1')\n\n    wf.connect(bbr2itk, 'itk_transform',\n               collectxfm, 'in2')\n\n    collectxfm.inputs.in3 = 'identity'\n\n    if blip:\n        wf.connect(blip_node, blip_out, collectxfm, 'in4')\n\n    wf.connect(motionxfm2itk, 'itk_transform',\n               collectxfm, f'in{merge_num}')\n\n    applyxfm_func_to_standard = pe.MapNode(\n        interface=ants.ApplyTransforms(),\n        name=f'applyxfm_func_to_standard_{pipe_num}',\n        iterfield=['input_image', 'transforms'])\n    applyxfm_func_to_standard.inputs.float = True\n    applyxfm_func_to_standard.inputs.interpolation = 'LanczosWindowedSinc'\n\n    applyxfm_derivfunc_to_standard = pe.MapNode(\n        interface=ants.ApplyTransforms(),\n        name=f'applyxfm_derivfunc_to_standard_{pipe_num}',\n        iterfield=['input_image', 'transforms'])\n    applyxfm_derivfunc_to_standard.inputs.float = True\n    applyxfm_derivfunc_to_standard.inputs.interpolation = 'LanczosWindowedSinc'\n\n    wf.connect(split_func, 'out_files',\n               applyxfm_func_to_standard, 'input_image')\n    wf.connect(split_func, 'out_files',\n               applyxfm_derivfunc_to_standard, 'input_image')\n\n    node, out = strat_pool.get_data('T1w-brain-template-funcreg')\n    wf.connect(node, out, applyxfm_func_to_standard, 'reference_image')\n    \n    node, out = strat_pool.get_data('T1w-brain-template-deriv')\n    wf.connect(node, out, applyxfm_derivfunc_to_standard, 'reference_image')\n\n    wf.connect(collectxfm, 'out', applyxfm_func_to_standard, 'transforms')\n    wf.connect(collectxfm, 'out', applyxfm_derivfunc_to_standard, 'transforms')\n\n    ### Loop ends! ###\n\n    merge_func_to_standard = pe.Node(interface=fslMerge(),\n                                     name=f'merge_func_to_standard_{pipe_num}')\n    merge_func_to_standard.inputs.dimension = 't'\n\n    wf.connect(applyxfm_func_to_standard, 'output_image',\n               merge_func_to_standard, 'in_files')\n\n    merge_derivfunc_to_standard = pe.Node(\n        interface=fslMerge(), name=f'merge_derivfunc_to_standard_{pipe_num}')\n    merge_derivfunc_to_standard.inputs.dimension = 't'\n\n    wf.connect(applyxfm_derivfunc_to_standard, 'output_image',\n               merge_derivfunc_to_standard, 'in_files')\n\n    applyxfm_func_mask_to_standard = pe.Node(\n        interface=ants.ApplyTransforms(),\n        name=f'applyxfm_func_mask_to_standard_{pipe_num}')\n    applyxfm_func_mask_to_standard.inputs.interpolation = 'MultiLabel'\n\n    node, out = strat_pool.get_data('space-bold_desc-brain_mask')\n    wf.connect(node, out, applyxfm_func_mask_to_standard, 'input_image')\n\n    node, out = strat_pool.get_data('T1w-brain-template-funcreg')\n    wf.connect(node, out, applyxfm_func_mask_to_standard, 'reference_image')\n\n    collectxfm_mask = pe.Node(\n        util.Merge(2), name=f'collectxfm_func_mask_to_standard_{pipe_num}')\n\n    node, out = strat_pool.get_data('from-T1w_to-template_mode-image_xfm')\n    wf.connect(node, out, collectxfm_mask, 'in1')\n\n    wf.connect(bbr2itk, 'itk_transform', collectxfm_mask, 'in2')\n\n    wf.connect(collectxfm_mask, 'out',\n               applyxfm_func_mask_to_standard, 'transforms')\n\n    applyxfm_deriv_mask_to_standard = pe.Node(\n        interface=ants.ApplyTransforms(),\n        name=f'applyxfm_deriv_mask_to_standard_{pipe_num}')\n    applyxfm_deriv_mask_to_standard.inputs.interpolation = 'MultiLabel'\n\n    node, out = strat_pool.get_data('space-bold_desc-brain_mask')\n    wf.connect(node, out, applyxfm_deriv_mask_to_standard, 'input_image')\n\n    node, out = strat_pool.get_data('T1w-brain-template-deriv')\n    wf.connect(node, out, applyxfm_deriv_mask_to_standard, 'reference_image')\n\n    collectxfm_deriv_mask = pe.Node(\n        util.Merge(2), name=f'collectxfm_deriv_mask_to_standard_{pipe_num}')\n\n    node, out = strat_pool.get_data('from-T1w_to-template_mode-image_xfm')\n    wf.connect(node, out, collectxfm_deriv_mask, 'in1')\n\n    wf.connect(bbr2itk, 'itk_transform',\n               collectxfm_deriv_mask, 'in2')\n\n    wf.connect(collectxfm_deriv_mask, 'out',\n               applyxfm_deriv_mask_to_standard, 'transforms')\n\n    apply_mask = pe.Node(interface=fsl.maths.ApplyMask(),\n                         name=f'get_func_brain_to_standard_{pipe_num}')\n\n    wf.connect(merge_func_to_standard, 'merged_file',\n               apply_mask, 'in_file')\n\n    wf.connect(applyxfm_func_mask_to_standard, 'output_image',\n               apply_mask, 'mask_file')\n\n    outputs = {\n        'space-template_desc-head_bold': (merge_func_to_standard,\n                                          'merged_file'),\n        'space-template_desc-brain_bold': (apply_mask, 'out_file'),\n        'space-template_desc-preproc_bold': (apply_mask, 'out_file'),\n        'space-template_desc-bold_mask': (applyxfm_func_mask_to_standard,\n                                          'output_image'),\n        'space-template_res-derivative_desc-preproc_bold':\n            (merge_derivfunc_to_standard, 'merged_file'),\n        'space-template_res-derivative_desc-bold_mask':\n            (applyxfm_deriv_mask_to_standard, 'output_image')\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "warp_sbref_to_T1template",
    "file": "CPAC/registration/registration.py",
    "line_number": 4647,
    "decorator_args": {
      "name": "transform_sbref_to_T1template",
      "switch": [
        "registration_workflows",
        "functional_registration",
        "func_registration_to_template",
        "run"
      ],
      "inputs": [
        [
          "sbref",
          "from-bold_to-template_mode-image_xfm"
        ],
        "T1w-brain-template-funcreg"
      ],
      "outputs": "!UNSUPPORTED_TYPE:Dict!"
    },
    "docstring": null,
    "source_code": "def warp_sbref_to_T1template(wf, cfg, strat_pool, pipe_num, opt=None):\n    xfm = 'from-bold_to-template_mode-image_xfm'\n    wf, apply_xfm = warp_resource_to_template(\n        wf, cfg, strat_pool, pipe_num, 'sbref', xfm,\n        reference='T1w-brain-template-funcreg', time_series=False)[:2]\n    outputs = {'space-template_sbref':\n               (apply_xfm, 'outputspec.output_image')}\n    return _warp_return(wf, apply_xfm, outputs)"
  },
  {
    "name": "warp_bold_mask_to_T1template",
    "file": "CPAC/registration/registration.py",
    "line_number": 4683,
    "decorator_args": {
      "name": "transform_bold_mask_to_T1template",
      "switch": [
        [
          "registration_workflows",
          "functional_registration",
          "func_registration_to_template",
          "run"
        ],
        [
          "registration_workflows",
          "anatomical_registration",
          "run"
        ]
      ],
      "option_key": [
        "registration_workflows",
        "functional_registration",
        "func_registration_to_template",
        "apply_transform",
        "using"
      ],
      "option_val": [
        "default",
        "abcd",
        "dcan_nhp"
      ],
      "inputs": [
        [
          "space-bold_desc-brain_mask",
          "from-bold_to-template_mode-image_xfm"
        ],
        "T1w-brain-template-funcreg"
      ],
      "outputs": "!UNSUPPORTED_TYPE:Dict!"
    },
    "docstring": null,
    "source_code": "def warp_bold_mask_to_T1template(wf, cfg, strat_pool, pipe_num, opt=None):\n    xfm = 'from-bold_to-template_mode-image_xfm'\n    wf, apply_xfm = warp_resource_to_template(\n        wf, cfg, strat_pool, pipe_num, 'space-bold_desc-brain_mask', xfm,\n        reference='T1w-brain-template-funcreg', time_series=False)[:2]\n    outputs = {'space-template_desc-bold_mask':\n               (apply_xfm, 'outputspec.output_image')}\n    return _warp_return(wf, apply_xfm, outputs)"
  },
  {
    "name": "warp_deriv_mask_to_T1template",
    "file": "CPAC/registration/registration.py",
    "line_number": 4722,
    "decorator_args": {
      "name": "transform_deriv_mask_to_T1template",
      "switch": [
        [
          "registration_workflows",
          "functional_registration",
          "func_registration_to_template",
          "run"
        ],
        [
          "registration_workflows",
          "anatomical_registration",
          "run"
        ]
      ],
      "option_key": [
        "registration_workflows",
        "functional_registration",
        "func_registration_to_template",
        "apply_transform",
        "using"
      ],
      "option_val": [
        "default",
        "abcd",
        "dcan_nhp"
      ],
      "inputs": [
        [
          "space-bold_desc-brain_mask",
          "from-bold_to-template_mode-image_xfm"
        ],
        "T1w-brain-template-deriv"
      ],
      "outputs": "!UNSUPPORTED_TYPE:Dict!"
    },
    "docstring": "Transform the BOLD mask to template space and to the resolution set for\nthe derivative outputs.",
    "source_code": "def warp_deriv_mask_to_T1template(wf, cfg, strat_pool, pipe_num, opt=None):\n    '''Transform the BOLD mask to template space and to the resolution set for\n    the derivative outputs.\n    '''\n    xfm = 'from-bold_to-template_mode-image_xfm'\n    wf, apply_xfm = warp_resource_to_template(\n        wf, cfg, strat_pool, pipe_num, 'space-bold_desc-brain_mask', xfm,\n        reference='T1w-brain-template-deriv', time_series=False)[:2]\n    outputs = {'space-template_res-derivative_desc-bold_mask':\n               (apply_xfm, 'outputspec.output_image')}\n    return _warp_return(wf, apply_xfm, outputs)"
  },
  {
    "name": "warp_timeseries_to_EPItemplate",
    "file": "CPAC/registration/registration.py",
    "line_number": 4749,
    "decorator_args": {
      "name": "transform_timeseries_to_EPItemplate",
      "config": [
        "registration_workflows",
        "functional_registration",
        "func_registration_to_template"
      ],
      "switch": [
        "run_EPI"
      ],
      "inputs": [
        [
          "desc-preproc_bold",
          "from-bold_to-EPItemplate_mode-image_xfm"
        ],
        "EPI-template"
      ],
      "outputs": "!UNSUPPORTED_TYPE:Dict!"
    },
    "docstring": null,
    "source_code": "def warp_timeseries_to_EPItemplate(wf, cfg, strat_pool, pipe_num, opt=None):\n    xfm = 'from-bold_to-EPItemplate_mode-image_xfm'\n    wf, apply_xfm, resource = warp_resource_to_template(\n        wf, cfg, strat_pool, pipe_num, 'desc-preproc_bold', xfm,\n        time_series=True)\n    outputs = {f'space-template_{resource}':\n               (apply_xfm, 'outputspec.output_image')}\n    return _warp_return(wf, apply_xfm, outputs)"
  },
  {
    "name": "warp_bold_mean_to_EPItemplate",
    "file": "CPAC/registration/registration.py",
    "line_number": 4773,
    "decorator_args": {
      "name": "transform_bold_mean_to_EPItemplate",
      "config": [
        "registration_workflows",
        "functional_registration",
        "func_registration_to_template"
      ],
      "switch": [
        "run_EPI"
      ],
      "inputs": [
        [
          "desc-mean_bold",
          "from-bold_to-EPItemplate_mode-image_xfm"
        ],
        "EPI-template"
      ],
      "outputs": "!UNSUPPORTED_TYPE:Dict!"
    },
    "docstring": null,
    "source_code": "def warp_bold_mean_to_EPItemplate(wf, cfg, strat_pool, pipe_num, opt=None):\n    xfm = 'from-bold_to-EPItemplate_mode-image_xfm'\n    wf, apply_xfm = warp_resource_to_template(\n        wf, cfg, strat_pool, pipe_num, 'desc-mean_bold', xfm,\n        time_series=False)[:2]\n    outputs = {'space-template_desc-mean_bold':\n               (apply_xfm, 'outputspec.output_image')}\n    return _warp_return(wf, apply_xfm, outputs)"
  },
  {
    "name": "warp_bold_mask_to_EPItemplate",
    "file": "CPAC/registration/registration.py",
    "line_number": 4798,
    "decorator_args": {
      "name": "transform_bold_mask_to_EPItemplate",
      "config": [
        "registration_workflows",
        "functional_registration",
        "func_registration_to_template"
      ],
      "switch": [
        "run_EPI"
      ],
      "inputs": [
        [
          "space-bold_desc-brain_mask",
          "from-bold_to-EPItemplate_mode-image_xfm"
        ],
        "EPI-template"
      ],
      "outputs": "!UNSUPPORTED_TYPE:Dict!"
    },
    "docstring": null,
    "source_code": "def warp_bold_mask_to_EPItemplate(wf, cfg, strat_pool, pipe_num, opt=None):\n    xfm = 'from-bold_to-EPItemplate_mode-image_xfm'\n    wf, apply_xfm = warp_resource_to_template(\n        wf, cfg, strat_pool, pipe_num, 'space-bold_desc-brain_mask', xfm,\n        time_series=False)[:2]\n    outputs = {'space-template_desc-bold_mask':\n               (apply_xfm, 'outputspec.output_image')}\n    return _warp_return(wf, apply_xfm, outputs)"
  },
  {
    "name": "warp_deriv_mask_to_EPItemplate",
    "file": "CPAC/registration/registration.py",
    "line_number": 4826,
    "decorator_args": {
      "name": "transform_deriv_mask_to_EPItemplate",
      "config": [
        "registration_workflows",
        "functional_registration",
        "func_registration_to_template"
      ],
      "switch": [
        "run_EPI"
      ],
      "inputs": [
        [
          "space-bold_desc-brain_mask",
          "from-bold_to-EPItemplate_mode-image_xfm"
        ],
        "EPI-template"
      ],
      "outputs": "!UNSUPPORTED_TYPE:Dict!"
    },
    "docstring": "Transform the BOLD mask to template space and to the resolution set for\nthe derivative outputs.",
    "source_code": "def warp_deriv_mask_to_EPItemplate(wf, cfg, strat_pool, pipe_num, opt=None):\n    '''Transform the BOLD mask to template space and to the resolution set for\n    the derivative outputs.\n    '''\n    xfm = 'from-bold_to-EPItemplate_mode-image_xfm'\n    wf, apply_xfm = warp_resource_to_template(\n        wf, cfg, strat_pool, pipe_num, 'space-bold_desc-brain_mask', xfm,\n        time_series=False)[:2]\n    outputs = {'space-template_res-derivative_desc-bold_mask':\n               (apply_xfm, 'outputspec.output_image')}\n    return _warp_return(wf, apply_xfm, outputs)"
  },
  {
    "name": "warp_tissuemask_to_T1template",
    "file": "CPAC/registration/registration.py",
    "line_number": 4857,
    "decorator_args": {
      "name": "warp_tissuemask_to_T1template",
      "switch": [
        "registration_workflows",
        "anatomical_registration",
        "run"
      ],
      "inputs": [
        [
          "label-CSF_mask",
          "label-WM_mask",
          "label-GM_mask",
          "from-T1w_to-template_mode-image_xfm"
        ],
        "T1w-template"
      ],
      "outputs": "!UNSUPPORTED_TYPE:Dict!"
    },
    "docstring": null,
    "source_code": "def warp_tissuemask_to_T1template(wf, cfg, strat_pool, pipe_num, opt=None):\n    return warp_tissuemask_to_template(wf, cfg, strat_pool, pipe_num,\n                                       xfm='from-T1w_to-template_mode-image_'\n                                           'xfm', template_space='T1')"
  },
  {
    "name": "warp_tissuemask_to_EPItemplate",
    "file": "CPAC/registration/registration.py",
    "line_number": 4886,
    "decorator_args": {
      "name": "warp_tissuemask_to_EPItemplate",
      "switch": [
        "registration_workflows",
        "functional_registration",
        "EPI_registration",
        "run"
      ],
      "inputs": [
        [
          "label-CSF_mask",
          "label-WM_mask",
          "label-GM_mask",
          "from-bold_to-EPItemplate_mode-image_xfm"
        ],
        "EPI-template"
      ],
      "outputs": "!UNSUPPORTED_TYPE:Dict!"
    },
    "docstring": null,
    "source_code": "def warp_tissuemask_to_EPItemplate(wf, cfg, strat_pool, pipe_num, opt=None):\n    return warp_tissuemask_to_template(wf, cfg, strat_pool, pipe_num,\n                                       xfm='from-bold_to-EPItemplate_'\n                                           'mode-image_xfm',\n                                       template_space='EPI')"
  },
  {
    "name": "mask_T1w_longitudinal_template",
    "file": "CPAC/longitudinal_pipeline/longitudinal_workflow.py",
    "line_number": 82,
    "decorator_args": {
      "name": "mask_T1w_longitudinal_template",
      "config": [
        "longitudinal_template_generation"
      ],
      "switch": [
        "run"
      ],
      "inputs": [
        "desc-brain_T1w"
      ],
      "outputs": [
        "space-T1w_desc-brain_mask"
      ]
    },
    "docstring": null,
    "source_code": "def mask_T1w_longitudinal_template(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    brain_mask = pe.Node(interface=fsl.maths.MathsCommand(),\n                         name=f'longitudinal_anatomical_brain_mask_'\n                              f'{pipe_num}')\n    brain_mask.inputs.args = '-bin'\n\n    node, out = strat_pool.get_data('desc-brain_T1w')\n    wf.connect(node, out, brain_mask, 'in_file')\n\n    outputs = {\n        'space-T1w_desc-brain_mask': (brain_mask, 'out_file')\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "mask_longitudinal_T1w_brain",
    "file": "CPAC/longitudinal_pipeline/longitudinal_workflow.py",
    "line_number": 257,
    "decorator_args": {
      "name": "mask_longitudinal_T1w_brain",
      "config": [
        "longitudinal_template_generation"
      ],
      "switch": [
        "run"
      ],
      "inputs": [
        "space-longitudinal_desc-brain_T1w"
      ],
      "outputs": [
        "space-longitudinal_desc-brain_mask"
      ]
    },
    "docstring": null,
    "source_code": "def mask_longitudinal_T1w_brain(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    brain_mask = pe.Node(interface=fsl.maths.MathsCommand(),\n                         name=f'longitudinal_T1w_brain_mask_{pipe_num}')\n    brain_mask.inputs.args = '-bin'\n\n    node, out = strat_pool.get_data(\"space-longitudinal_desc-brain_T1w\")\n    wf.connect(node, out, brain_mask, 'in_file')\n\n    outputs = {\n        'space-longitudinal_desc-brain_mask': (brain_mask, 'out_file')\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "warp_longitudinal_T1w_to_template",
    "file": "CPAC/longitudinal_pipeline/longitudinal_workflow.py",
    "line_number": 285,
    "decorator_args": {
      "name": "warp_longitudinal_T1w_to_template",
      "config": [
        "longitudinal_template_generation"
      ],
      "switch": [
        "run"
      ],
      "inputs": [
        [
          "space-longitudinal_desc-brain_T1w",
          "from-longitudinal_to-template_mode-image_xfm"
        ]
      ],
      "outputs": [
        "space-template_desc-brain_T1w"
      ]
    },
    "docstring": null,
    "source_code": "def warp_longitudinal_T1w_to_template(wf, cfg, strat_pool, pipe_num,\n                                      opt=None):\n\n    xfm_prov = strat_pool.get_cpac_provenance(\n        'from-longitudinal_to-template_mode-image_xfm')\n    reg_tool = check_prov_for_regtool(xfm_prov)\n\n    num_cpus = cfg.pipeline_setup['system_config'][\n        'max_cores_per_participant']\n\n    num_ants_cores = cfg.pipeline_setup['system_config']['num_ants_threads']\n\n    apply_xfm = apply_transform(f'warp_longitudinal_to_T1template_{pipe_num}',\n                                reg_tool, time_series=False,\n                                num_cpus=num_cpus,\n                                num_ants_cores=num_ants_cores)\n\n    if reg_tool == 'ants':\n        apply_xfm.inputs.inputspec.interpolation = cfg.registration_workflows[\n            'anatomical_registration']['registration']['ANTs'][\n            'interpolation']\n    elif reg_tool == 'fsl':\n        apply_xfm.inputs.inputspec.interpolation = cfg.registration_workflows[\n            'anatomical_registration']['registration']['FSL-FNIRT'][\n            'interpolation']\n\n    node, out = strat_pool.get_data(\"space-longitudinal_desc-brain_T1w\")\n    wf.connect(node, out, apply_xfm, 'inputspec.input_image')\n\n    node, out = strat_pool.get_data(\"T1w_brain_template\")\n    wf.connect(node, out, apply_xfm, 'inputspec.reference')\n\n    node, out = \\\n        strat_pool.get_data(\"from-longitudinal_to-template_mode-image_xfm\")\n    wf.connect(node, out, apply_xfm, 'inputspec.transform')\n\n    outputs = {\n        'space-template_desc-brain_T1w':\n            (apply_xfm, 'outputspec.output_image')\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "warp_longitudinal_seg_to_T1w",
    "file": "CPAC/longitudinal_pipeline/longitudinal_workflow.py",
    "line_number": 359,
    "decorator_args": {
      "name": "warp_longitudinal_seg_to_T1w",
      "config": [
        "longitudinal_template_generation"
      ],
      "switch": [
        "run"
      ],
      "inputs": [
        [
          "from-longitudinal_to-T1w_mode-image_desc-linear_xfm",
          "space-longitudinal_label-CSF_mask",
          "space-longitudinal_label-GM_mask",
          "space-longitudinal_label-WM_mask",
          "space-longitudinal_label-CSF_desc-preproc_mask",
          "space-longitudinal_label-GM_desc-preproc_mask",
          "space-longitudinal_label-WM_desc-preproc_mask",
          "space-longitudinal_label-CSF_probseg",
          "space-longitudinal_label-GM_probseg",
          "space-longitudinal_label-WM_probseg"
        ]
      ],
      "outputs": [
        "label-CSF_mask",
        "label-GM_mask",
        "label-WM_mask",
        "label-CSF_desc-preproc_mask",
        "label-GM_desc-preproc_mask",
        "label-WM_desc-preproc_mask",
        "label-CSF_probseg",
        "label-GM_probseg",
        "label-WM_probseg"
      ]
    },
    "docstring": null,
    "source_code": "def warp_longitudinal_seg_to_T1w(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    xfm_prov = strat_pool.get_cpac_provenance(\n        'from-longitudinal_to-T1w_mode-image_desc-linear_xfm')\n    reg_tool = check_prov_for_regtool(xfm_prov)\n\n    num_cpus = cfg.pipeline_setup['system_config'][\n        'max_cores_per_participant']\n\n    num_ants_cores = cfg.pipeline_setup['system_config']['num_ants_threads']\n\n    outputs = {}\n\n    labels = [\n        'CSF_mask', 'CSF_desc-preproc_mask', 'CSF_probseg',\n        'GM_mask', 'GM_desc-preproc_mask', 'GM_probseg',\n        'WM_mask', 'WM_desc-preproc_mask', 'WM_probseg',\n    ]\n\n    for label in labels:\n        apply_xfm = apply_transform(f'warp_longitudinal_seg_to_T1w_{label}_'\n                                    f'{pipe_num}', reg_tool,\n                                    time_series=False,  num_cpus=num_cpus,\n                                    num_ants_cores=num_ants_cores)\n\n        if reg_tool == 'ants':\n            apply_xfm.inputs.inputspec.interpolation = \\\n                cfg.registration_workflows['anatomical_registration'][\n                    'registration']['ANTs']['interpolation']\n        elif reg_tool == 'fsl':\n            apply_xfm.inputs.inputspec.interpolation = \\\n                cfg.registration_workflows['anatomical_registration'][\n                    'registration']['FSL-FNIRT']['interpolation']\n\n        node, out = strat_pool.get_data(\"space-longitudinal_desc-brain_T1w\")\n        wf.connect(node, out, apply_xfm, 'inputspec.input_image')\n\n        node, out = strat_pool.get_data(\"T1w_brain_template\")\n        wf.connect(node, out, apply_xfm, 'inputspec.reference')\n\n        node, out = \\\n            strat_pool.get_data(\"from-longitudinal_to-template_mode-image_xfm\")\n        wf.connect(node, out, apply_xfm, 'inputspec.transform')\n\n        outputs[f'label-{label}'] = (apply_xfm, 'outputspec.output_image')\n\n    return (wf, outputs)"
  },
  {
    "name": "timeseries_extraction_AVG",
    "file": "CPAC/timeseries/timeseries_analysis.py",
    "line_number": 810,
    "decorator_args": {
      "name": "timeseries_extraction_AVG",
      "config": [
        "timeseries_extraction"
      ],
      "switch": [
        "run"
      ],
      "inputs": [
        "space-template_desc-preproc_bold",
        "space-template_desc-bold_mask"
      ],
      "outputs": [
        "space-template_desc-Mean_timeseries",
        "space-template_desc-ndmg_correlations",
        "atlas_name",
        "space-template_desc-PearsonAfni_correlations",
        "space-template_desc-PartialAfni_correlations",
        "space-template_desc-PearsonNilearn_correlations",
        "space-template_desc-PartialNilearn_correlations"
      ]
    },
    "docstring": null,
    "source_code": "def timeseries_extraction_AVG(wf, cfg, strat_pool, pipe_num, opt=None):\n    resample_functional_roi = pe.Node(resample_function(),\n                                      name='resample_functional_roi_'\n                                           f'{pipe_num}')\n    realignment = cfg.timeseries_extraction['realignment']\n    resample_functional_roi.inputs.realignment = realignment\n    resample_functional_roi.inputs.identity_matrix = \\\n    cfg.registration_workflows['functional_registration'][\n        'func_registration_to_template']['FNIRT_pipelines']['identity_matrix']\n\n    roi_dataflow = create_roi_mask_dataflow(\n        cfg.timeseries_extraction['tse_atlases']['Avg'],\n        f'roi_dataflow_{pipe_num}')\n\n    roi_dataflow.inputs.inputspec.set(\n        creds_path=cfg.pipeline_setup['input_creds_path'],\n        dl_dir=cfg.pipeline_setup['working_directory']['path']\n    )\n\n    roi_timeseries = get_roi_timeseries(f'roi_timeseries_{pipe_num}')\n    #roi_timeseries.inputs.inputspec.output_type = cfg.timeseries_extraction[\n    #    'roi_tse_outputs']\n\n    node, out = strat_pool.get_data(\"space-template_desc-preproc_bold\")\n    wf.connect(node, out, resample_functional_roi, 'in_func')\n\n    wf.connect(roi_dataflow, 'outputspec.out_file',\n               resample_functional_roi, 'in_roi')\n\n    # connect it to the roi_timeseries\n    # workflow.connect(roi_dataflow, 'outputspec.out_file',\n    #                  roi_timeseries, 'input_roi.roi')\n    wf.connect(resample_functional_roi, 'out_roi',\n               roi_timeseries, 'input_roi.roi')\n    wf.connect(resample_functional_roi, 'out_func',\n               roi_timeseries, 'inputspec.rest')\n\n    # create the graphs:\n    # - connectivity matrix\n    matrix_outputs = {}\n    for cm_measure in cfg['timeseries_extraction', 'connectivity_matrix',\n                          'measure']:\n        for cm_tool in [tool for tool in cfg['timeseries_extraction',\n                        'connectivity_matrix', 'using'] if tool != 'ndmg']:\n            implementation = get_connectome_method(cm_measure, cm_tool)\n            if implementation is NotImplemented:\n                continue\n\n            if cm_tool == 'Nilearn':\n                timeseries_correlation = create_connectome_nilearn(\n                    name=f'connectomeNilearn{cm_measure}_{pipe_num}'\n                )\n\n            elif cm_tool == \"AFNI\":\n                timeseries_correlation = create_connectome_afni(\n                    name=f'connectomeAfni{cm_measure}_{pipe_num}',\n                    method=cm_measure,\n                    pipe_num=pipe_num\n                )\n                brain_mask_node, brain_mask_out = strat_pool.get_data([\n                    'space-template_desc-bold_mask'])\n                if 'func_to_ROI' in realignment:\n                    resample_brain_mask_roi = pe.Node(\n                        resample_function(),\n                        name=f'resample_brain_mask_roi_{pipe_num}')\n                    resample_brain_mask_roi.inputs.realignment = realignment\n                    resample_brain_mask_roi.inputs.identity_matrix = (\n                        cfg.registration_workflows['functional_registration'][\n                            'func_registration_to_template'\n                        ]['FNIRT_pipelines']['identity_matrix'])\n                    wf.connect([\n                        (brain_mask_node, resample_brain_mask_roi, [\n                            (brain_mask_out, 'in_func')]),\n                        (roi_dataflow, resample_brain_mask_roi, [\n                            ('outputspec.out_file', 'in_roi')]),\n                        (resample_brain_mask_roi, timeseries_correlation, [\n                            ('out_func', 'inputspec.mask')])])\n                else:\n                    wf.connect(brain_mask_node, brain_mask_out,\n                               timeseries_correlation, 'inputspec.mask')\n\n            timeseries_correlation.inputs.inputspec.method = cm_measure\n            wf.connect([\n                (roi_dataflow, timeseries_correlation, [\n                    ('outputspec.out_name', 'inputspec.atlas_name')]),\n                (resample_functional_roi, timeseries_correlation, [\n                    ('out_roi', 'inputspec.in_rois'),\n                    ('out_func', 'inputspec.in_file')])])\n\n            output_desc = ''.join(term.lower().capitalize() for term in [\n                cm_measure, cm_tool])\n            matrix_outputs[f'space-template_desc-{output_desc}_correlations'\n                           ] = (timeseries_correlation, 'outputspec.out_file')\n\n    outputs = {\n        'space-template_desc-Mean_timeseries': (\n            roi_timeseries, 'outputspec.roi_csv'),\n        'atlas_name': (roi_dataflow, 'outputspec.out_name'),\n        **matrix_outputs\n    }\n    # - NDMG\n    if 'ndmg' in cfg['timeseries_extraction', 'connectivity_matrix', 'using']:\n        # pylint: disable=import-outside-toplevel\n        from CPAC.utils.ndmg_utils import ndmg_create_graphs\n\n        ndmg_graph_imports = ['import os',\n                              'from CPAC.utils.ndmg_utils import graph']\n        ndmg_graph = pe.Node(Function(\n            input_names=['ts', 'labels'],\n            output_names=['out_file'],\n            function=ndmg_create_graphs,\n            imports=ndmg_graph_imports,\n            as_module=True\n        ), name=f'ndmg_graphs_{pipe_num}',\n           mem_gb=0.664,\n           mem_x=(1928411764134803 / 302231454903657293676544, 'ts'))\n\n        wf.connect(roi_timeseries, 'outputspec.roi_ts', ndmg_graph, 'ts')\n        wf.connect(roi_dataflow, 'outputspec.out_file', ndmg_graph, 'labels')\n        outputs['space-template_desc-ndmg_correlations'\n                ] = (ndmg_graph, 'out_file')\n\n    return (wf, outputs)"
  },
  {
    "name": "timeseries_extraction_Voxel",
    "file": "CPAC/timeseries/timeseries_analysis.py",
    "line_number": 942,
    "decorator_args": {
      "name": "timeseries_extraction_Voxel",
      "config": [
        "timeseries_extraction"
      ],
      "switch": [
        "run"
      ],
      "inputs": [
        "space-template_desc-preproc_bold"
      ],
      "outputs": [
        "desc-Voxel_timeseries",
        "atlas_name"
      ]
    },
    "docstring": null,
    "source_code": "def timeseries_extraction_Voxel(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    resample_functional_to_mask = pe.Node(resample_function(),\n                                          name='resample_functional_to_mask_'\n                                               f'{pipe_num}')\n\n    resample_functional_to_mask.inputs.realignment = cfg.timeseries_extraction[\n        'realignment']\n    resample_functional_to_mask.inputs.identity_matrix = \\\n    cfg.registration_workflows['functional_registration'][\n        'func_registration_to_template']['FNIRT_pipelines']['identity_matrix']\n\n    mask_dataflow = create_roi_mask_dataflow(cfg.timeseries_extraction[\n                                                 'tse_atlases']['Voxel'],\n                                             f'mask_dataflow_{pipe_num}')\n\n    voxel_timeseries = get_voxel_timeseries(\n        f'voxel_timeseries_{pipe_num}')\n    #voxel_timeseries.inputs.inputspec.output_type = cfg.timeseries_extraction[\n    #    'roi_tse_outputs']\n\n\n    node, out = strat_pool.get_data(\"space-template_desc-preproc_bold\")\n    # resample the input functional file to mask\n    wf.connect(node, out,\n                     resample_functional_to_mask, 'in_func')\n    wf.connect(mask_dataflow, 'outputspec.out_file',\n                     resample_functional_to_mask, 'in_roi')\n\n    # connect it to the voxel_timeseries\n    wf.connect(resample_functional_to_mask, 'out_roi',\n                     voxel_timeseries, 'input_mask.mask')\n    wf.connect(resample_functional_to_mask, 'out_func',\n                     voxel_timeseries, 'inputspec.rest')\n\n    outputs = {\n        'desc-Voxel_timeseries':\n            (voxel_timeseries, 'outputspec.mask_outputs'),\n        'atlas_name': (mask_dataflow, 'outputspec.out_name')\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "spatial_regression",
    "file": "CPAC/timeseries/timeseries_analysis.py",
    "line_number": 995,
    "decorator_args": {
      "name": "spatial_regression",
      "config": [
        "timeseries_extraction"
      ],
      "switch": [
        "run"
      ],
      "inputs": [
        "space-template_desc-preproc_bold",
        [
          "space-template_desc-bold_mask",
          "space-template_desc-brain_mask"
        ]
      ],
      "outputs": [
        "desc-SpatReg_timeseries",
        "atlas_name"
      ]
    },
    "docstring": "Performs spatial regression, extracting the spatial map timeseries of\nthe given atlases.\n\nNote: this is a standalone function for when only spatial regression is\n      selected for the given atlases - if dual regression is selected,\n      that spatial regression is performed in the dual_regression function",
    "source_code": "def spatial_regression(wf, cfg, strat_pool, pipe_num, opt=None):\n    '''Performs spatial regression, extracting the spatial map timeseries of\n    the given atlases.\n\n    Note: this is a standalone function for when only spatial regression is\n          selected for the given atlases - if dual regression is selected,\n          that spatial regression is performed in the dual_regression function\n    '''\n\n    resample_spatial_map_to_native_space = pe.Node(\n        interface=fsl.FLIRT(),\n        name=f'resample_spatial_map_to_native_space_{pipe_num}',\n        mem_gb=3.4,\n        mem_x=(5381614225492473 / 1208925819614629174706176, 'in_file'))\n\n    resample_spatial_map_to_native_space.inputs.set(\n        interp='nearestneighbour',\n        apply_xfm=True,\n        in_matrix_file=cfg.registration_workflows['functional_registration'][\n            'func_registration_to_template']['FNIRT_pipelines'][\n            'identity_matrix'])\n\n    spatial_map_dataflow = create_spatial_map_dataflow(\n        cfg.timeseries_extraction['tse_atlases']['SpatialReg'],\n        f'spatial_map_dataflow_{pipe_num}')\n\n    spatial_map_dataflow.inputs.inputspec.set(\n        creds_path=cfg.pipeline_setup['input_creds_path'],\n        dl_dir=cfg.pipeline_setup['working_directory']['path'])\n\n    spatial_map_timeseries = get_spatial_map_timeseries(\n        f'spatial_map_timeseries_{pipe_num}')\n    spatial_map_timeseries.inputs.inputspec.demean = True\n\n    node, out = strat_pool.get_data(\"space-template_desc-preproc_bold\")\n\n    # resample the input functional file and functional mask\n    # to spatial map\n    wf.connect(node, out, resample_spatial_map_to_native_space, 'reference')\n    wf.connect(spatial_map_dataflow, 'select_spatial_map.out_file',\n               resample_spatial_map_to_native_space, 'in_file')\n\n    wf.connect(node, out, spatial_map_timeseries, 'inputspec.subject_rest')\n\n    # connect it to the spatial_map_timeseries\n    wf.connect(resample_spatial_map_to_native_space, 'out_file',\n               spatial_map_timeseries, 'inputspec.spatial_map')\n\n    node, out = strat_pool.get_data(['space-template_desc-bold_mask', 'space-template_desc-brain_mask'])\n    wf.connect(node, out, spatial_map_timeseries, 'inputspec.subject_mask')\n\n    # 'atlas_name' will be an iterable and will carry through\n    outputs = {\n        'desc-SpatReg_timeseries':\n            (spatial_map_timeseries, 'outputspec.subject_timeseries'),\n        'atlas_name': (spatial_map_dataflow, 'select_spatial_map.out_name')\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "reho",
    "file": "CPAC/reho/reho.py",
    "line_number": 122,
    "decorator_args": {
      "name": "ReHo",
      "config": [
        "regional_homogeneity"
      ],
      "switch": [
        "run"
      ],
      "inputs": [
        "desc-preproc_bold",
        "space-bold_desc-brain_mask"
      ],
      "outputs": [
        "reho"
      ]
    },
    "docstring": null,
    "source_code": "def reho(wf, cfg, strat_pool, pipe_num, opt=None):\n    cluster_size = cfg.regional_homogeneity['cluster_size']\n\n    # Check the cluster size is supported\n    if cluster_size not in [7, 19, 27]:\n        err_msg = 'Cluster size specified: %d, is not ' \\\n                  'supported. Change to 7, 19, or 27 and try ' \\\n                  'again' % cluster_size\n        raise Exception(err_msg)\n\n    reho = create_reho(f'reho_{pipe_num}')\n    reho.inputs.inputspec.cluster_size = cluster_size\n\n    node, out = strat_pool.get_data(\"desc-preproc_bold\")\n    wf.connect(node, out, reho, 'inputspec.rest_res_filt')\n\n    node, out_file = strat_pool.get_data('space-bold_desc-brain_mask')\n    wf.connect(node, out_file, reho, 'inputspec.rest_mask')\n\n    outputs = {\n        'reho': (reho, 'outputspec.raw_reho_map')\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "reho_space_template",
    "file": "CPAC/reho/reho.py",
    "line_number": 160,
    "decorator_args": {
      "name": "ReHo_space_template",
      "config": [
        "regional_homogeneity"
      ],
      "switch": [
        "run"
      ],
      "inputs": [
        [
          "space-template_res-derivative_desc-preproc_bold",
          "space-template_desc-preproc_bold"
        ],
        [
          "space-template_res-derivative_desc-bold_mask",
          "space-template_desc-brain_mask"
        ]
      ],
      "outputs": [
        "space-template_reho"
      ]
    },
    "docstring": null,
    "source_code": "def reho_space_template(wf, cfg, strat_pool, pipe_num, opt=None):\n  \n    cluster_size = cfg.regional_homogeneity['cluster_size']\n\n    # Check the cluster size is supported\n    if cluster_size not in [7, 19, 27]:\n        err_msg = 'Cluster size specified: %d, is not ' \\\n                  'supported. Change to 7, 19, or 27 and try ' \\\n                  'again' % cluster_size\n        raise Exception(err_msg)\n\n    reho = create_reho(f'reho_{pipe_num}')\n    reho.inputs.inputspec.cluster_size = cluster_size\n\n    node, out = strat_pool.get_data([\"space-template_res-derivative_desc-preproc_bold\",\n                                    \"space-template_desc-preproc_bold\"])\n    wf.connect(node, out, reho, 'inputspec.rest_res_filt')\n\n    node, out_file = strat_pool.get_data(['space-template_res-derivative_desc-bold_mask',\n                                          'space-template_desc-brain_mask'])\n    wf.connect(node, out_file, reho, 'inputspec.rest_mask')\n\n    outputs = {\n        'space-template_reho': (reho, 'outputspec.raw_reho_map')\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "smooth_func_vmhc",
    "file": "CPAC/vmhc/vmhc.py",
    "line_number": 28,
    "decorator_args": {
      "name": "smooth_func_vmhc",
      "switch": [
        "voxel_mirrored_homotopic_connectivity",
        "run"
      ],
      "option_key": [
        "post_processing",
        "spatial_smoothing",
        "smoothing_method"
      ],
      "option_val": [
        "AFNI",
        "FSL"
      ],
      "inputs": [
        [
          "desc-cleaned_bold",
          "desc-brain_bold",
          "desc-preproc_bold",
          "bold"
        ],
        "space-bold_desc-brain_mask"
      ],
      "outputs": [
        "desc-sm_bold",
        "fwhm"
      ]
    },
    "docstring": null,
    "source_code": "def smooth_func_vmhc(wf, cfg, strat_pool, pipe_num, opt=None):\n    fwhm = cfg.post_processing['spatial_smoothing']['fwhm']\n\n    smooth = spatial_smoothing(f'smooth_symmetric_{pipe_num}',\n                               fwhm, opt=opt)\n\n    node, out = strat_pool.get_data([\"desc-cleaned_bold\",\n                                     \"desc-brain_bold\",\n                                     \"desc-preproc_bold\",\n                                     \"bold\"])\n    wf.connect(node, out, smooth, 'inputspec.in_file')\n\n    node, out = strat_pool.get_data(\"space-bold_desc-brain_mask\")\n    wf.connect(node, out, smooth, 'inputspec.mask')\n\n    # 'fwhm' output for iterable\n    outputs = {\n        \"desc-sm_bold\": (smooth, 'outputspec.out_file'),\n        \"fwhm\": (smooth, 'fwhm_input.fwhm')\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "warp_timeseries_to_sym_template",
    "file": "CPAC/vmhc/vmhc.py",
    "line_number": 68,
    "decorator_args": {
      "name": "transform_timeseries_to_sym_template",
      "config": [
        "voxel_mirrored_homotopic_connectivity"
      ],
      "switch": [
        "run"
      ],
      "inputs": [
        [
          "desc-cleaned-sm_bold",
          "desc-brain-sm_bold",
          "desc-preproc-sm_bold",
          "desc-sm_bold"
        ],
        "from-bold_to-symtemplate_mode-image_xfm",
        "T1w-brain-template-symmetric"
      ],
      "outputs": [
        "space-symtemplate_desc-sm_bold"
      ]
    },
    "docstring": null,
    "source_code": "def warp_timeseries_to_sym_template(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    xfm_prov = strat_pool.get_cpac_provenance(\n        'from-bold_to-symtemplate_mode-image_xfm')\n    reg_tool = check_prov_for_regtool(xfm_prov)\n\n    num_cpus = cfg.pipeline_setup['system_config'][\n        'max_cores_per_participant']\n\n    num_ants_cores = cfg.pipeline_setup['system_config']['num_ants_threads']\n\n    apply_xfm = apply_transform(f'warp_ts_to_sym_template_{pipe_num}',\n                                reg_tool, time_series=True, num_cpus=num_cpus,\n                                num_ants_cores=num_ants_cores)\n\n    if reg_tool == 'ants':\n        apply_xfm.inputs.inputspec.interpolation = cfg.registration_workflows[\n            'functional_registration']['func_registration_to_template'][\n            'ANTs_pipelines']['interpolation']\n    elif reg_tool == 'fsl':\n        apply_xfm.inputs.inputspec.interpolation = cfg.registration_workflows[\n            'functional_registration']['func_registration_to_template'][\n            'FNIRT_pipelines']['interpolation']\n\n    # smoothed BOLD\n    connect, resource = strat_pool.get_data([\"desc-cleaned-sm_bold\",\n                                             \"desc-brain-sm_bold\",\n                                             \"desc-preproc-sm_bold\",\n                                             \"desc-sm_bold\"],\n                                            report_fetched=True)\n    node, out = connect\n    wf.connect(node, out, apply_xfm, 'inputspec.input_image')\n\n    node, out = strat_pool.get_data(\"T1w-brain-template-symmetric\")\n    wf.connect(node, out, apply_xfm, 'inputspec.reference')\n\n    node, out = strat_pool.get_data(\"from-bold_to-symtemplate_mode-image_xfm\")\n    wf.connect(node, out, apply_xfm, 'inputspec.transform')\n\n    outputs = {\n        f'space-symtemplate_{resource}':\n            (apply_xfm, 'outputspec.output_image')\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "vmhc",
    "file": "CPAC/vmhc/vmhc.py",
    "line_number": 129,
    "decorator_args": {
      "name": "vmhc",
      "config": [
        "voxel_mirrored_homotopic_connectivity"
      ],
      "switch": [
        "run"
      ],
      "inputs": [
        [
          "space-symtemplate_desc-cleaned-sm_bold",
          "space-symtemplate_desc-brain-sm_bold",
          "space-symtemplate_desc-preproc-sm_bold",
          "space-symtemplate_desc-sm_bold"
        ]
      ],
      "outputs": [
        "vmhc"
      ]
    },
    "docstring": "Compute Voxel-Mirrored Homotopic Connectivity.\n\nVMHC is the map of brain functional homotopy, the high degree of\nsynchrony in spontaneous activity between geometrically corresponding\ninterhemispheric (i.e., homotopic) regions.",
    "source_code": "def vmhc(wf, cfg, strat_pool, pipe_num, opt=None):\n    '''Compute Voxel-Mirrored Homotopic Connectivity.\n\n    VMHC is the map of brain functional homotopy, the high degree of\n    synchrony in spontaneous activity between geometrically corresponding\n    interhemispheric (i.e., homotopic) regions.\n    '''\n\n    # write out a swapped version of the file\n    # copy and L/R swap file\n    copy_and_L_R_swap = pe.Node(interface=fsl.SwapDimensions(),\n                                name=f'copy_and_L_R_swap_{pipe_num}',\n                                mem_gb=3.0)\n\n    copy_and_L_R_swap.inputs.new_dims = ('-x', 'y', 'z')\n\n    node, out = strat_pool.get_data([\"space-symtemplate_desc-cleaned-sm_bold\",\n                                     \"space-symtemplate_desc-brain-sm_bold\",\n                                     \"space-symtemplate_desc-preproc-sm_bold\",\n                                     \"space-symtemplate_desc-sm_bold\"])\n    wf.connect(node, out, copy_and_L_R_swap, 'in_file')\n\n    # calculate correlation between original and swapped images\n    pearson_correlation = pe.Node(interface=preprocess.TCorrelate(),\n                                  name=f'pearson_correlation_{pipe_num}',\n                                  mem_gb=3.0)\n\n    pearson_correlation.inputs.pearson = True\n    pearson_correlation.inputs.polort = -1\n    pearson_correlation.inputs.outputtype = 'NIFTI_GZ'\n\n    wf.connect(node, out, pearson_correlation, 'xset')\n\n    wf.connect(copy_and_L_R_swap, 'out_file',\n               pearson_correlation, 'yset')\n\n    outputs = {\n        'vmhc': (pearson_correlation, 'out_file')\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "SCA_AVG",
    "file": "CPAC/sca/sca.py",
    "line_number": 407,
    "decorator_args": {
      "name": "SCA_AVG",
      "config": [
        "seed_based_correlation_analysis"
      ],
      "switch": [
        "run"
      ],
      "inputs": [
        "space-template_desc-preproc_bold"
      ],
      "outputs": [
        "desc-MeanSCA_timeseries",
        "space-template_desc-MeanSCA_correlations",
        "atlas_name"
      ]
    },
    "docstring": "Run Seed-Based Correlation Analysis.",
    "source_code": "def SCA_AVG(wf, cfg, strat_pool, pipe_num, opt=None):\n    '''Run Seed-Based Correlation Analysis.'''\n\n    # same workflow, except to run TSE and send it to the resource\n    # pool so that it will not get sent to SCA\n    resample_functional_roi_for_sca = pe.Node(\n        util.Function(input_names=['in_func',\n                                   'in_roi',\n                                   'realignment',\n                                   'identity_matrix'],\n                      output_names=['out_func', 'out_roi'],\n                      function=resample_func_roi,\n                      as_module=True),\n        name=f'resample_functional_roi_for_sca_{pipe_num}')\n\n    resample_functional_roi_for_sca.inputs.realignment = \\\n        cfg.timeseries_extraction['realignment']\n    resample_functional_roi_for_sca.inputs.identity_matrix = \\\n    cfg.registration_workflows['functional_registration'][\n        'func_registration_to_template']['FNIRT_pipelines']['identity_matrix']\n\n    roi_dataflow_for_sca = create_roi_mask_dataflow(\n        cfg.seed_based_correlation_analysis['sca_atlases']['Avg'],\n        f'roi_dataflow_for_sca_{pipe_num}'\n    )\n\n    roi_dataflow_for_sca.inputs.inputspec.set(\n        creds_path=cfg.pipeline_setup['input_creds_path'],\n        dl_dir=cfg.pipeline_setup['working_directory']['path']\n    )\n\n    roi_timeseries_for_sca = get_roi_timeseries(\n        f'roi_timeseries_for_sca_{pipe_num}')\n\n    node, out = strat_pool.get_data(\"space-template_desc-preproc_bold\")\n    # resample the input functional file to roi\n    wf.connect(node, out,\n                     resample_functional_roi_for_sca, 'in_func')\n    wf.connect(roi_dataflow_for_sca, 'outputspec.out_file',\n                     resample_functional_roi_for_sca, 'in_roi')\n\n    # connect it to the roi_timeseries\n    wf.connect(resample_functional_roi_for_sca, 'out_roi',\n                     roi_timeseries_for_sca, 'input_roi.roi')\n    wf.connect(resample_functional_roi_for_sca, 'out_func',\n                     roi_timeseries_for_sca, 'inputspec.rest')\n\n    sca_roi = create_sca(f'sca_roi_{pipe_num}')\n\n    node, out = strat_pool.get_data(\"space-template_desc-preproc_bold\")\n    wf.connect(node, out, sca_roi, 'inputspec.functional_file')\n\n    wf.connect(roi_timeseries_for_sca, 'outputspec.roi_csv',\n               #('outputspec.roi_outputs', extract_one_d),\n               sca_roi, 'inputspec.timeseries_one_d')\n\n    outputs = {\n        'desc-MeanSCA_timeseries':\n            (roi_timeseries_for_sca, 'outputspec.roi_csv'),\n                                    #('outputspec.roi_outputs',\n                                    # extract_one_d)),\n        'space-template_desc-MeanSCA_correlations':\n            (sca_roi, 'outputspec.correlation_stack'),\n        'atlas_name': (roi_dataflow_for_sca, 'outputspec.out_name')\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "dual_regression",
    "file": "CPAC/sca/sca.py",
    "line_number": 488,
    "decorator_args": {
      "name": "dual_regression",
      "config": [
        "seed_based_correlation_analysis"
      ],
      "switch": [
        "run"
      ],
      "inputs": [
        "space-template_desc-preproc_bold",
        "space-template_desc-bold_mask"
      ],
      "outputs": [
        "space-template_desc-DualReg_correlations",
        "desc-DualReg_statmap",
        "atlas_name"
      ]
    },
    "docstring": "Run Dual Regression - spatial regression and then temporal regression.",
    "source_code": "def dual_regression(wf, cfg, strat_pool, pipe_num, opt=None):\n    '''\n    Run Dual Regression - spatial regression and then temporal regression.\n    '''\n    resample_spatial_map_to_native_space_for_dr = pe.Node(\n        interface=fsl.FLIRT(),\n        name=f'resample_spatial_map_to_native_space_for_DR_{pipe_num}'\n    )\n    resample_spatial_map_to_native_space_for_dr.inputs.set(\n        interp='nearestneighbour',\n        apply_xfm=True,\n        in_matrix_file=\n        cfg.registration_workflows['functional_registration'][\n            'func_registration_to_template']['FNIRT_pipelines'][\n            'identity_matrix']\n    )\n\n    spatial_map_dataflow_for_dr = create_spatial_map_dataflow(\n        cfg.seed_based_correlation_analysis['sca_atlases']['DualReg'],\n        f'spatial_map_dataflow_for_DR_{pipe_num}'\n    )\n\n    spatial_map_dataflow_for_dr.inputs.inputspec.set(\n        creds_path=cfg.pipeline_setup['input_creds_path'],\n        dl_dir=cfg.pipeline_setup['working_directory']['path']\n    )\n\n    spatial_map_timeseries_for_dr = get_spatial_map_timeseries(\n        f'spatial_map_timeseries_for_DR_{pipe_num}'\n    )\n    spatial_map_timeseries_for_dr.inputs.inputspec.demean = True\n\n    # resample the input functional file and functional mask\n    # to spatial map\n    node, out = strat_pool.get_data(\"space-template_desc-preproc_bold\")\n    wf.connect(node, out,\n               resample_spatial_map_to_native_space_for_dr, 'reference')\n    wf.connect(node, out,\n               spatial_map_timeseries_for_dr, 'inputspec.subject_rest')\n\n    wf.connect(spatial_map_dataflow_for_dr, 'select_spatial_map.out_file',\n               resample_spatial_map_to_native_space_for_dr, 'in_file')\n\n    # connect it to the spatial_map_timeseries\n    wf.connect(resample_spatial_map_to_native_space_for_dr, 'out_file',\n               spatial_map_timeseries_for_dr, 'inputspec.spatial_map'\n    )\n\n    dr_temp_reg = create_temporal_reg(f'temporal_regression_{pipe_num}')\n    dr_temp_reg.inputs.inputspec.normalize = \\\n        cfg.seed_based_correlation_analysis['norm_timeseries_for_DR']\n    dr_temp_reg.inputs.inputspec.demean = True\n\n    wf.connect(spatial_map_timeseries_for_dr, 'outputspec.subject_timeseries',\n               dr_temp_reg, 'inputspec.subject_timeseries')\n\n    node, out = strat_pool.get_data(\"space-template_desc-preproc_bold\")\n    wf.connect(node, out, dr_temp_reg, 'inputspec.subject_rest')\n\n    node, out = strat_pool.get_data(\"space-template_desc-bold_mask\")\n    wf.connect(node, out, dr_temp_reg, 'inputspec.subject_mask')\n\n    outputs = {\n        'space-template_desc-DualReg_correlations':\n            (dr_temp_reg, 'outputspec.temp_reg_map'),\n        'desc-DualReg_statmap':\n            (dr_temp_reg, 'outputspec.temp_reg_map_z'),\n        'atlas_name':\n            (spatial_map_dataflow_for_dr, 'select_spatial_map.out_name')\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "multiple_regression",
    "file": "CPAC/sca/sca.py",
    "line_number": 574,
    "decorator_args": {
      "name": "multiple_regression",
      "config": [
        "seed_based_correlation_analysis"
      ],
      "switch": [
        "run"
      ],
      "inputs": [
        "space-template_desc-preproc_bold",
        "space-template_desc-bold_mask"
      ],
      "outputs": [
        "space-template_desc-MultReg_correlations",
        "desc-MultReg_statmap",
        "atlas_name"
      ]
    },
    "docstring": "Run Multiple Regression.",
    "source_code": "def multiple_regression(wf, cfg, strat_pool, pipe_num, opt=None):\n    '''Run Multiple Regression.'''\n\n    # same workflow, except to run TSE and send it to the resource\n    # pool so that it will not get sent to SCA\n    resample_functional_roi_for_multreg = pe.Node(\n        resample_function(),\n        name=f'resample_functional_roi_for_multreg_{pipe_num}')\n\n    resample_functional_roi_for_multreg.inputs.realignment = \\\n    cfg.timeseries_extraction['realignment']\n    resample_functional_roi_for_multreg.inputs.identity_matrix = \\\n    cfg.registration_workflows['functional_registration'][\n        'func_registration_to_template']['FNIRT_pipelines']['identity_matrix']\n\n    roi_dataflow_for_multreg = create_roi_mask_dataflow(\n        cfg.seed_based_correlation_analysis['sca_atlases']['MultReg'],\n        f'roi_dataflow_for_mult_reg_{pipe_num}')\n\n    roi_dataflow_for_multreg.inputs.inputspec.set(\n        creds_path=cfg.pipeline_setup['input_creds_path'],\n        dl_dir=cfg.pipeline_setup['working_directory']['path']\n    )\n\n    roi_timeseries_for_multreg = get_roi_timeseries(\n        f'roi_timeseries_for_mult_reg_{pipe_num}')\n\n    node, out = strat_pool.get_data(\"space-template_desc-preproc_bold\")\n    # resample the input functional file to roi\n    wf.connect(node, out, resample_functional_roi_for_multreg, 'in_func')\n    wf.connect(roi_dataflow_for_multreg,\n                     'outputspec.out_file',\n                     resample_functional_roi_for_multreg,\n                     'in_roi')\n\n    # connect it to the roi_timeseries\n    wf.connect(resample_functional_roi_for_multreg,\n                     'out_roi',\n                     roi_timeseries_for_multreg,\n                     'input_roi.roi')\n    wf.connect(resample_functional_roi_for_multreg,\n                     'out_func',\n                     roi_timeseries_for_multreg,\n                     'inputspec.rest')\n\n    sc_temp_reg = create_temporal_reg(\n        f'temporal_regression_sca_{pipe_num}',\n        which='RT')\n    sc_temp_reg.inputs.inputspec.normalize = \\\n    cfg.seed_based_correlation_analysis['norm_timeseries_for_DR']\n    sc_temp_reg.inputs.inputspec.demean = True\n\n    node, out = strat_pool.get_data([\"space-template_desc-cleaned_bold\",\n                                     \"space-template_desc-brain_bold\",\n                                     \"space-template_desc-motion_bold\",\n                                     \"space-template_desc-preproc_bold\",\n                                     \"space-template_bold\"])\n    wf.connect(node, out, sc_temp_reg, 'inputspec.subject_rest')\n\n    wf.connect(roi_timeseries_for_multreg, 'outputspec.roi_csv',\n                     #('outputspec.roi_outputs', extract_one_d),\n                     sc_temp_reg, 'inputspec.subject_timeseries')\n\n    node, out = strat_pool.get_data('space-template_desc-bold_mask')\n    wf.connect(node, out, sc_temp_reg, 'inputspec.subject_mask')\n\n    outputs = {\n        'space-template_desc-MultReg_correlations':\n            (sc_temp_reg, 'outputspec.temp_reg_map'),\n        'desc-MultReg_statmap':\n            (sc_temp_reg, 'outputspec.temp_reg_map_z'),\n        'atlas_name': (roi_dataflow_for_multreg, 'outputspec.out_name')\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "network_centrality",
    "file": "CPAC/network_centrality/pipeline.py",
    "line_number": 156,
    "decorator_args": {
      "name": "network_centrality",
      "config": [
        "network_centrality"
      ],
      "switch": [
        "run"
      ],
      "inputs": [
        [
          "space-template_desc-preproc_bold",
          "T1w-brain-template-funcreg"
        ],
        "template-specification-file"
      ],
      "outputs": "!UNSUPPORTED_TYPE:Dict!"
    },
    "docstring": "Run Network Centrality.\n    ",
    "source_code": "def network_centrality(wf, cfg, strat_pool, pipe_num, opt=None):\n    '''Run Network Centrality.\n    '''\n\n    # Resample the functional mni to the centrality mask resolution\n    resample_functional_to_template = pe.Node(\n        interface=fsl.FLIRT(),\n        name=f'resample_functional_to_template_{pipe_num}',\n        mem_gb=4.0)\n\n    resample_functional_to_template.inputs.set(\n        interp='trilinear',\n        in_matrix_file=cfg.registration_workflows['functional_registration'][\n            'func_registration_to_template']['FNIRT_pipelines'][\n            'identity_matrix'],\n        apply_xfm=True\n    )\n\n    node, out = strat_pool.get_data(\"space-template_desc-preproc_bold\")\n    wf.connect(node, out, resample_functional_to_template, 'in_file')\n\n    node, out = strat_pool.get_data(\"template-specification-file\")\n    wf.connect(node, out, resample_functional_to_template, 'reference')\n\n    merge_node = create_merge_node(pipe_num)\n    outputs = {}\n\n    for option in valid_options['centrality']['method_options']:\n        if cfg.network_centrality[option]['weight_options']:\n            connect_centrality_workflow(wf, cfg,\n                                        resample_functional_to_template,\n                                        node, out, merge_node,\n                                        option, pipe_num)\n            for weight in cfg.network_centrality[option]['weight_options']:\n                _option = option.lower()\n                _weight = weight.lower()\n                if 'degree' in _option:\n                    if 'weight' in _weight:\n                        outputs['space-template_dcw'] = (merge_node,\n                                                         'degree_weighted')\n                    elif 'binarize' in _weight:\n                        outputs['space-template_dcb'] = (merge_node,\n                                                         'degree_binarized')\n                elif 'eigen' in _option:\n                    if 'weight' in _weight:\n                        outputs['space-template_ecw'] = (merge_node,\n                                                         'eigen_weighted')\n                    elif 'binarize' in _weight:\n                        outputs['space-template_ecb'] = (merge_node,\n                                                         'eigen_binarized')\n                elif 'lfcd' in _option or 'local_functional' in _option:\n                    if 'weight' in _weight:\n                        outputs['space-template_lfcdw'] = (merge_node,\n                                                           'lfcd_weighted')\n                    elif 'binarize' in _weight:\n                        outputs['space-template_lfcdb'] = (merge_node,\n                                                           'lfcd_binarized')\n\n    return (wf, outputs)"
  },
  {
    "name": "alff_falff",
    "file": "CPAC/alff/alff.py",
    "line_number": 257,
    "decorator_args": {
      "name": "alff_falff",
      "config": [
        "amplitude_low_frequency_fluctuation"
      ],
      "switch": [
        "run"
      ],
      "inputs": [
        [
          [
            "desc-denoisedNofilt_bold",
            "desc-preproc_bold"
          ],
          "space-bold_desc-brain_mask"
        ]
      ],
      "outputs": [
        "alff",
        "falff"
      ]
    },
    "docstring": null,
    "source_code": "def alff_falff(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    alff = create_alff(f'alff_falff_{pipe_num}')\n\n    alff.inputs.hp_input.hp = \\\n        cfg.amplitude_low_frequency_fluctuation['highpass_cutoff']\n    alff.inputs.lp_input.lp = \\\n        cfg.amplitude_low_frequency_fluctuation['lowpass_cutoff']\n    alff.get_node('hp_input').iterables = ('hp', alff.inputs.hp_input.hp)\n    alff.get_node('lp_input').iterables = ('lp', alff.inputs.lp_input.lp)\n\n    node, out = strat_pool.get_data([\"desc-denoisedNofilt_bold\",\n                                     \"desc-preproc_bold\"])\n    wf.connect(node, out, alff, 'inputspec.rest_res')\n\n    node, out = strat_pool.get_data('space-bold_desc-brain_mask')\n    wf.connect(node, out, alff, 'inputspec.rest_mask')\n\n    outputs = {\n        'alff': (alff, 'outputspec.alff_img'),\n        'falff': (alff, 'outputspec.falff_img')\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "alff_falff_space_template",
    "file": "CPAC/alff/alff.py",
    "line_number": 306,
    "decorator_args": {
      "name": "alff_falff_space_template",
      "config": [
        "amplitude_low_frequency_fluctuation"
      ],
      "switch": [
        "run"
      ],
      "inputs": [
        [
          [
            "space-template_res-derivative_desc-denoisedNofilt_bold",
            "space-template_res-derivative_desc-preproc_bold",
            "space-template_desc-preproc_bold"
          ],
          [
            "space-template_res-derivative_desc-bold_mask",
            "space-template_desc-bold_mask"
          ],
          "desc-denoisedNofilt_bold",
          "from-bold_to-template_mode-image_xfm",
          "T1w-brain-template-deriv"
        ]
      ],
      "outputs": [
        "space-template_alff",
        "space-template_falff",
        "space-template_res-derivative_desc-denoisedNofilt_bold"
      ]
    },
    "docstring": null,
    "source_code": "def alff_falff_space_template(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    outputs = {}    \n    if strat_pool.check_rpool(\"desc-denoisedNofilt_bold\"):\n        xfm_prov = strat_pool.get_cpac_provenance(\n            'from-bold_to-template_mode-image_xfm')\n        reg_tool = check_prov_for_regtool(xfm_prov)\n\n        num_cpus = cfg.pipeline_setup['system_config'][\n            'max_cores_per_participant']\n\n        num_ants_cores = cfg.pipeline_setup['system_config']['num_ants_threads']\n\n        apply_xfm = apply_transform(f'warp_denoisedNofilt_to_T1template_{pipe_num}', reg_tool,\n                                    time_series=True, num_cpus=num_cpus,\n                                    num_ants_cores=num_ants_cores)\n\n        if reg_tool == 'ants':\n            apply_xfm.inputs.inputspec.interpolation = cfg.registration_workflows[\n                'functional_registration']['func_registration_to_template'][\n                'ANTs_pipelines']['interpolation']\n        elif reg_tool == 'fsl':\n            apply_xfm.inputs.inputspec.interpolation = cfg.registration_workflows[\n                'functional_registration']['func_registration_to_template'][\n                'FNIRT_pipelines']['interpolation']\n\n        node, out = strat_pool.get_data(\"desc-denoisedNofilt_bold\")\n        wf.connect(node, out, apply_xfm, 'inputspec.input_image')\n\n        node, out = strat_pool.get_data(\"T1w-brain-template-deriv\")\n        wf.connect(node, out, apply_xfm, 'inputspec.reference')\n\n        node, out = strat_pool.get_data(\"from-bold_to-template_mode-image_xfm\")\n        wf.connect(node, out, apply_xfm, 'inputspec.transform')\n\n        outputs = {\n            f'space-template_res-derivative_desc-denoisedNofilt_bold': (apply_xfm, 'outputspec.output_image')\n        }\n    alff = create_alff(f'alff_falff_{pipe_num}')\n\n    alff.inputs.hp_input.hp = \\\n        cfg.amplitude_low_frequency_fluctuation['highpass_cutoff']\n    alff.inputs.lp_input.lp = \\\n        cfg.amplitude_low_frequency_fluctuation['lowpass_cutoff']\n    alff.get_node('hp_input').iterables = ('hp', alff.inputs.hp_input.hp)\n    alff.get_node('lp_input').iterables = ('lp', alff.inputs.lp_input.lp)\n    node, out = strat_pool.get_data([\"space-template_res-derivative_desc-denoisedNofilt_bold\",\n                                     \"space-template_res-derivative_desc-preproc_bold\",\n                                     \"space-template_desc-preproc_bold\"])\n    wf.connect(node, out, alff, 'inputspec.rest_res')\n    node, out = strat_pool.get_data([\"space-template_res-derivative_desc-bold_mask\",\n                                     \"space-template_desc-bold_mask\"])\n    wf.connect(node, out, alff, 'inputspec.rest_mask')\n    \n    outputs.update({\n        'space-template_alff': (alff, 'outputspec.alff_img'),\n        'space-template_falff': (alff, 'outputspec.falff_img')\n    })\n\n    return (wf, outputs)"
  },
  {
    "name": "tissue_seg_fsl_fast",
    "file": "CPAC/seg_preproc/seg_preproc.py",
    "line_number": 461,
    "decorator_args": {
      "name": "tissue_seg_fsl_fast",
      "config": [
        "segmentation"
      ],
      "switch": [
        "run"
      ],
      "option_key": [
        "tissue_segmentation",
        "using"
      ],
      "option_val": "FSL-FAST",
      "inputs": [
        [
          [
            "desc-brain_T1w",
            "space-longitudinal_desc-brain_T1w"
          ],
          [
            "space-T1w_desc-brain_mask",
            "space-longitudinal_desc-brain_mask"
          ],
          [
            "from-template_to-T1w_mode-image_desc-linear_xfm",
            "from-template_to-longitudinal_mode-image_desc-linear_xfm"
          ]
        ],
        "CSF-path",
        "GM-path",
        "WM-path"
      ],
      "outputs": [
        "label-CSF_mask",
        "label-GM_mask",
        "label-WM_mask",
        "label-CSF_desc-preproc_mask",
        "label-GM_desc-preproc_mask",
        "label-WM_desc-preproc_mask",
        "label-CSF_probseg",
        "label-GM_probseg",
        "label-WM_probseg",
        "label-CSF_pveseg",
        "label-GM_pveseg",
        "label-WM_pveseg",
        "space-longitudinal_label-CSF_mask",
        "space-longitudinal_label-GM_mask",
        "space-longitudinal_label-WM_mask",
        "space-longitudinal_label-CSF_desc-preproc_mask",
        "space-longitudinal_label-GM_desc-preproc_mask",
        "space-longitudinal_label-WM_desc-preproc_mask",
        "space-longitudinal_label-CSF_probseg",
        "space-longitudinal_label-GM_probseg",
        "space-longitudinal_label-WM_probseg"
      ]
    },
    "docstring": null,
    "source_code": "def tissue_seg_fsl_fast(wf, cfg, strat_pool, pipe_num, opt=None):\n    # FSL-FAST\n    #  'tissue_class_files' output is a list of individual binary tissue masks\n    #      triggered by 'segments' boolean input (-g or --segments)\n    #  'probability_maps' output is a list of individual probability maps\n    #      triggered by 'probability_maps' boolean input (-p)\n\n    segment = pe.Node(interface=fsl.FAST(),\n                      name=f'segment_{pipe_num}',\n                      mem_gb=3.48,\n                      mem_x=(3444233104315183 / 19342813113834066795298816,\n                             'in_files'))\n    segment.inputs.img_type = 1\n    segment.inputs.segments = True\n    segment.inputs.probability_maps = True\n    segment.inputs.out_basename = 'segment'\n\n    check_wm = pe.Node(name='check_wm',\n                       interface=Function(function=check_if_file_is_empty,\n                                          input_names=['in_file'],\n                                          output_names=['out_file']))\n    check_gm = pe.Node(name='check_gm',\n                       interface=Function(function=check_if_file_is_empty,\n                                          input_names=['in_file'],\n                                          output_names=['out_file']))\n    check_csf = pe.Node(name='check_csf', interface=Function(\n        function=check_if_file_is_empty, input_names=['in_file'],\n        output_names=['out_file']))\n\n    connect, resource = \\\n        strat_pool.get_data([\"desc-brain_T1w\",\n                             \"space-longitudinal_desc-brain_T1w\"],\n                            report_fetched=True)\n    node, out = connect\n    wf.connect(node, out, segment, 'in_files')\n\n\n    use_custom_threshold = cfg['segmentation']['tissue_segmentation'][\n                               'FSL-FAST']['thresholding'][\n                               'use'] == 'Custom'\n\n    use_priors = cfg['segmentation']['tissue_segmentation'][\n        'FSL-FAST']['use_priors']['run']\n\n    long = ''\n    if 'space-longitudinal' in resource:\n        long = 'space-longitudinal_'\n\n    if use_priors:\n        xfm = 'from-template_to-T1w_mode-image_desc-linear_xfm'\n        if 'space-longitudinal' in resource:\n            xfm = 'from-template_to-longitudinal_mode-image_desc-linear_xfm'\n        xfm_prov = strat_pool.get_cpac_provenance(xfm)\n        reg_tool = check_prov_for_regtool(xfm_prov)\n    else:\n        xfm_prov = None\n        reg_tool = None\n        xfm = None\n\n\n    process_csf = process_segment_map(f'CSF_{pipe_num}', use_priors,\n                                      use_custom_threshold, reg_tool)\n    process_csf.inputs.inputspec.threshold = cfg['segmentation'][\n        'tissue_segmentation']['FSL-FAST']['thresholding']['Custom'][\n        'CSF_threshold_value']\n\n    get_pve_csf = pe.Node(interface=fsl.maths.MathsCommand(),\n                          name=f'get_pve_csf_{pipe_num}')\n    get_pve_csf.inputs.args = '-thr 0.5 -uthr 1.5 -bin'\n    wf.connect(segment, 'partial_volume_map', get_pve_csf, 'in_file')\n\n    get_pve_gm = pe.Node(interface=fsl.maths.MathsCommand(),\n                          name=f'get_pve_gm_{pipe_num}')\n    get_pve_gm.inputs.args = '-thr 1.5 -uthr 2.5 -bin'\n    wf.connect(segment, 'partial_volume_map', get_pve_gm, 'in_file')\n\n    get_pve_wm = pe.Node(interface=fsl.maths.MathsCommand(),\n                          name=f'get_pve_wm_{pipe_num}')\n    get_pve_wm.inputs.args = '-thr 2.5 -uthr 3.5 -bin'\n    wf.connect(segment, 'partial_volume_map', get_pve_wm, 'in_file')\n\n    if use_priors:\n        node, out = strat_pool.get_data('CSF-path')\n        wf.connect(node, out, process_csf, 'inputspec.tissue_prior')\n\n    process_gm = process_segment_map(f'GM_{pipe_num}', use_priors,\n                                     use_custom_threshold, reg_tool)\n    process_gm.inputs.inputspec.threshold = cfg['segmentation'][\n        'tissue_segmentation']['FSL-FAST']['thresholding']['Custom'][\n        'GM_threshold_value']\n\n    if use_priors:\n        node, out = strat_pool.get_data('GM-path')\n        wf.connect(node, out, process_gm, 'inputspec.tissue_prior')\n\n    process_wm = process_segment_map(f'WM_{pipe_num}', use_priors,\n                                     use_custom_threshold, reg_tool)\n    process_wm.inputs.inputspec.threshold = cfg['segmentation'][\n        'tissue_segmentation']['FSL-FAST']['thresholding']['Custom'][\n        'WM_threshold_value']\n\n    if use_priors:\n        node, out = strat_pool.get_data('WM-path')\n        wf.connect(node, out, process_wm, 'inputspec.tissue_prior')\n\n    node, out = strat_pool.get_data([\"desc-brain_T1w\",\n                                     \"space-longitudinal_desc-brain_T1w\"])\n    wf.connect(node, out, process_csf, 'inputspec.brain')\n    wf.connect(node, out, process_gm, 'inputspec.brain')\n    wf.connect(node, out, process_wm, 'inputspec.brain')\n\n    node, out = strat_pool.get_data([\"space-T1w_desc-brain_mask\",\n                                     \"space-longitudinal_desc-brain_mask\"])\n    wf.connect(node, out, process_csf, 'inputspec.brain_mask')\n    wf.connect(node, out, process_gm, 'inputspec.brain_mask')\n    wf.connect(node, out, process_wm, 'inputspec.brain_mask')\n\n    if use_priors:\n        node, out = strat_pool.get_data(xfm)\n        wf.connect(node, out, process_csf, 'inputspec.template_to_T1_xfm')\n        wf.connect(node, out, process_gm, 'inputspec.template_to_T1_xfm')\n        wf.connect(node, out, process_wm, 'inputspec.template_to_T1_xfm')\n\n    wf.connect(segment, ('tissue_class_files', pick_wm_class_0),\n               process_csf, 'inputspec.tissue_class_file')\n    wf.connect(segment, ('probability_maps', pick_wm_prob_0),\n               process_csf, 'inputspec.probability_tissue_map')\n\n    wf.connect(segment, ('tissue_class_files', pick_wm_class_1),\n               process_gm, 'inputspec.tissue_class_file')\n    wf.connect(segment, ('probability_maps', pick_wm_prob_1),\n               process_gm, 'inputspec.probability_tissue_map')\n\n    wf.connect(segment, ('tissue_class_files', pick_wm_class_2),\n               process_wm, 'inputspec.tissue_class_file')\n    wf.connect(segment, ('probability_maps', pick_wm_prob_2),\n               process_wm, 'inputspec.probability_tissue_map')\n\n    get_csf = pe.Node(util.Function(input_names=['probability_maps'],\n                                    output_names=['filename'],\n                                    function=pick_wm_prob_0),\n                      name=f'get_csf_{pipe_num}')\n\n    wf.connect(segment, 'probability_maps', get_csf, 'probability_maps')\n\n    outputs = {\n        f'{long}label-CSF_probseg': (get_csf, 'filename'),\n        f'{long}label-GM_probseg':\n            (segment, ('probability_maps', pick_wm_prob_1)),\n        f'{long}label-WM_probseg':\n            (segment, ('probability_maps', pick_wm_prob_2)),\n        f'{long}label-CSF_mask':\n            (segment, ('tissue_class_files', pick_wm_class_0)),\n        f'{long}label-GM_mask':\n            (segment, ('tissue_class_files', pick_wm_class_1)),\n        f'{long}label-WM_mask':\n            (segment, ('tissue_class_files', pick_wm_class_2)),\n        f'{long}label-CSF_desc-preproc_mask':\n            (process_csf, 'outputspec.segment_mask'),\n        f'{long}label-GM_desc-preproc_mask':\n            (process_gm, 'outputspec.segment_mask'),\n        f'{long}label-WM_desc-preproc_mask':\n            (process_wm, 'outputspec.segment_mask'),\n        f'{long}label-CSF_pveseg': (get_pve_csf, 'out_file'),\n        f'{long}label-GM_pveseg': (get_pve_gm, 'out_file'),\n        f'{long}label-WM_pveseg': (get_pve_wm, 'out_file'),\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "tissue_seg_T1_template_based",
    "file": "CPAC/seg_preproc/seg_preproc.py",
    "line_number": 641,
    "decorator_args": {
      "name": "tissue_seg_T1_template_based",
      "config": [
        "segmentation"
      ],
      "switch": [
        "run"
      ],
      "option_key": [
        "tissue_segmentation",
        "using"
      ],
      "option_val": "Template_Based",
      "inputs": [
        [
          "desc-brain_T1w",
          "from-template_to-T1w_mode-image_desc-linear_xfm"
        ]
      ],
      "outputs": [
        "label-CSF_mask",
        "label-GM_mask",
        "label-WM_mask"
      ]
    },
    "docstring": null,
    "source_code": "def tissue_seg_T1_template_based(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    xfm_prov = strat_pool.get_cpac_provenance(\n        'from-template_to-T1w_mode-image_desc-linear_xfm')\n    reg_tool = check_prov_for_regtool(xfm_prov)\n    use_ants = reg_tool == 'ants'\n\n    csf_template2t1 = tissue_mask_template_to_t1(f'CSF_{pipe_num}', \n                                                 use_ants)\n    csf_template2t1.inputs.inputspec.tissue_mask_template = cfg[\n        'segmentation']['tissue_segmentation']['Template_Based']['CSF']\n\n    gm_template2t1 = tissue_mask_template_to_t1(f'GM_{pipe_num}',\n                                                use_ants)\n    gm_template2t1.inputs.inputspec.tissue_mask_template = cfg[\n        'segmentation']['tissue_segmentation']['Template_Based']['GRAY']\n\n    wm_template2t1 = tissue_mask_template_to_t1(f'WM_{pipe_num}',\n                                                use_ants)\n    wm_template2t1.inputs.inputspec.tissue_mask_template = cfg[\n        'segmentation']['tissue_segmentation']['Template_Based']['WHITE']\n\n    node, out = strat_pool.get_data('desc-brain_T1w')\n    wf.connect(node, out, csf_template2t1, 'inputspec.brain')\n    wf.connect(node, out, gm_template2t1, 'inputspec.brain')\n    wf.connect(node, out, wm_template2t1, 'inputspec.brain')\n\n    node, out = \\\n        strat_pool.get_data('from-template_to-T1w_mode-image_desc-linear_xfm')\n    wf.connect(node, out,\n               csf_template2t1, 'inputspec.standard2highres_mat')\n    wf.connect(node, out,\n               wm_template2t1, 'inputspec.standard2highres_mat')\n    wf.connect(node, out,\n               gm_template2t1, 'inputspec.standard2highres_mat')\n\n    outputs = {\n        'label-CSF_mask': (\n        csf_template2t1, 'outputspec.segment_mask_temp2t1'),\n        'label-GM_mask': (gm_template2t1, 'outputspec.segment_mask_temp2t1'),\n        'label-WM_mask': (wm_template2t1, 'outputspec.segment_mask_temp2t1')\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "tissue_seg_EPI_template_based",
    "file": "CPAC/seg_preproc/seg_preproc.py",
    "line_number": 700,
    "decorator_args": {
      "name": "tissue_seg_EPI_template_based",
      "config": [
        "segmentation"
      ],
      "switch": [
        "run"
      ],
      "option_key": [
        "tissue_segmentation",
        "using"
      ],
      "option_val": "Template_Based",
      "inputs": [
        [
          "desc-mean_bold",
          "from-EPItemplate_to-bold_mode-image_desc-linear_xfm"
        ]
      ],
      "outputs": [
        "space-bold_label-CSF_mask",
        "space-bold_label-GM_mask",
        "space-bold_label-WM_mask"
      ]
    },
    "docstring": null,
    "source_code": "def tissue_seg_EPI_template_based(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    xfm_prov = strat_pool.get_cpac_provenance(\n        'from-EPItemplate_to-bold_mode-image_desc-linear_xfm')\n    reg_tool = check_prov_for_regtool(xfm_prov)\n    use_ants = reg_tool == 'ants'\n\n    csf_template2t1 = tissue_mask_template_to_t1('CSF', use_ants)\n    csf_template2t1.inputs.inputspec.tissue_mask_template = cfg[\n        'segmentation']['tissue_segmentation']['Template_Based']['CSF']\n\n    gm_template2t1 = tissue_mask_template_to_t1('GM', use_ants)\n    gm_template2t1.inputs.inputspec.tissue_mask_template = cfg[\n        'segmentation']['tissue_segmentation']['Template_Based']['GRAY']\n\n    wm_template2t1 = tissue_mask_template_to_t1('WM', use_ants)\n    wm_template2t1.inputs.inputspec.tissue_mask_template = cfg[\n        'segmentation']['tissue_segmentation']['Template_Based']['WHITE']\n\n    node, out = strat_pool.get_data('desc-mean_bold')\n    wf.connect(node, out, csf_template2t1, 'inputspec.brain')\n    wf.connect(node, out, gm_template2t1, 'inputspec.brain')\n    wf.connect(node, out, wm_template2t1, 'inputspec.brain')\n\n    node, out = \\\n        strat_pool.get_data(\n            'from-EPItemplate_to-bold_mode-image_desc-linear_xfm')\n    wf.connect(node, out,\n               csf_template2t1, 'inputspec.standard2highres_mat')\n    wf.connect(node, out,\n               wm_template2t1, 'inputspec.standard2highres_mat')\n    wf.connect(node, out,\n               gm_template2t1, 'inputspec.standard2highres_mat')\n\n    outputs = {\n        'space-bold_label-CSF_mask': (csf_template2t1,\n                                      'outputspec.segment_mask_temp2t1'),\n        'space-bold_label-GM_mask': (gm_template2t1,\n                                     'outputspec.segment_mask_temp2t1'),\n        'space-bold_label-WM_mask': (wm_template2t1,\n                                     'outputspec.segment_mask_temp2t1')\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "tissue_seg_ants_prior",
    "file": "CPAC/seg_preproc/seg_preproc.py",
    "line_number": 760,
    "decorator_args": {
      "name": "tissue_seg_ants_prior",
      "config": [
        "segmentation"
      ],
      "switch": [
        "run"
      ],
      "option_key": [
        "tissue_segmentation",
        "using"
      ],
      "option_val": "ANTs_Prior_Based",
      "inputs": [
        [
          "desc-brain_T1w",
          [
            "space-T1w_desc-brain_mask",
            "space-T1w_desc-acpcbrain_mask"
          ]
        ]
      ],
      "outputs": [
        "label-CSF_mask",
        "label-GM_mask",
        "label-WM_mask"
      ]
    },
    "docstring": null,
    "source_code": "def tissue_seg_ants_prior(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    seg_preproc_ants_prior_based = \\\n        create_seg_preproc_antsJointLabel_method(wf_name=f'seg_preproc_'\n                                                         f'ants_prior_'\n                                                         f'{pipe_num}')\n\n    seg_preproc_ants_prior_based.inputs.inputspec.template_brain_list = \\\n        cfg['segmentation']['tissue_segmentation']['ANTs_Prior_Based'][\n            'template_brain_list']\n    seg_preproc_ants_prior_based.inputs.inputspec.template_segmentation_list = \\\n        cfg['segmentation']['tissue_segmentation']['ANTs_Prior_Based'][\n            'template_segmentation_list']\n\n    seg_preproc_ants_prior_based.inputs.inputspec.csf_label = cfg[\n        'segmentation']['tissue_segmentation']['ANTs_Prior_Based'][\n        'CSF_label']\n\n    seg_preproc_ants_prior_based.inputs.inputspec.gm_label = cfg[\n        'segmentation']['tissue_segmentation']['ANTs_Prior_Based'][\n        'GM_label']\n\n    seg_preproc_ants_prior_based.inputs.inputspec.wm_label = cfg[\n        'segmentation']['tissue_segmentation']['ANTs_Prior_Based'][\n        'WM_label']\n\n    node, out = strat_pool.get_data('desc-brain_T1w')\n    wf.connect(node, out,\n               seg_preproc_ants_prior_based, 'inputspec.anatomical_brain')\n\n    node, out = strat_pool.get_data(['space-T1w_desc-brain_mask',\n                                     'space-T1w_desc-acpcbrain_mask'])\n    wf.connect(node, out, seg_preproc_ants_prior_based,\n               'inputspec.anatomical_brain_mask')\n\n    outputs = {\n        'label-CSF_mask': (\n        seg_preproc_ants_prior_based, 'outputspec.csf_mask'),\n        'label-GM_mask': (seg_preproc_ants_prior_based, 'outputspec.gm_mask'),\n        'label-WM_mask': (seg_preproc_ants_prior_based, 'outputspec.wm_mask')\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "tissue_seg_freesurfer",
    "file": "CPAC/seg_preproc/seg_preproc.py",
    "line_number": 838,
    "decorator_args": {
      "name": "tissue_seg_freesurfer",
      "config": [
        "segmentation"
      ],
      "switch": [
        "run"
      ],
      "option_key": [
        "tissue_segmentation",
        "using"
      ],
      "option_val": "FreeSurfer",
      "inputs": [
        "freesurfer-subject-dir",
        "pipeline-fs_raw-average",
        "pipeline-fs_subcortical-seg"
      ],
      "outputs": [
        "pipeline-fs_hemi-L_desc-surface_curv",
        "pipeline-fs_hemi-R_desc-surface_curv",
        "pipeline-fs_hemi-L_desc-surfaceMesh_pial",
        "pipeline-fs_hemi-R_desc-surfaceMesh_pial",
        "pipeline-fs_hemi-L_desc-surfaceMesh_smoothwm",
        "pipeline-fs_hemi-R_desc-surfaceMesh_smoothwm",
        "pipeline-fs_hemi-L_desc-surfaceMesh_sphere",
        "pipeline-fs_hemi-R_desc-surfaceMesh_sphere",
        "pipeline-fs_hemi-L_desc-surfaceMap_sulc",
        "pipeline-fs_hemi-R_desc-surfaceMap_sulc",
        "pipeline-fs_hemi-L_desc-surfaceMap_thickness",
        "pipeline-fs_hemi-R_desc-surfaceMap_thickness",
        "pipeline-fs_hemi-L_desc-surfaceMap_volume",
        "pipeline-fs_hemi-R_desc-surfaceMap_volume",
        "pipeline-fs_hemi-L_desc-surfaceMesh_white",
        "pipeline-fs_hemi-R_desc-surfaceMesh_white",
        "label-CSF_mask",
        "label-GM_mask",
        "label-WM_mask"
      ]
    },
    "docstring": null,
    "source_code": "def tissue_seg_freesurfer(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    node, out = strat_pool.get_data('freesurfer-subject-dir')\n\n    fs_aseg_to_native = pe.Node(interface=freesurfer.ApplyVolTransform(),\n                                name=f'fs_aseg_to_native_{pipe_num}')\n    fs_aseg_to_native.inputs.reg_header = True\n    fs_aseg_to_native.inputs.interp = 'nearest'\n\n    wf.connect(node, out, fs_aseg_to_native, 'subjects_dir')\n\n    node, out = strat_pool.get_data('pipeline-fs_subcortical-seg')\n    wf.connect(node, out, fs_aseg_to_native, 'source_file')\n\n    node, out = strat_pool.get_data('pipeline-fs_raw-average')\n    wf.connect(node, out, fs_aseg_to_native, 'target_file')\n\n    fs_aseg_to_nifti = pe.Node(util.Function(input_names=['in_file'],\n                                             output_names=['out_file'],\n                                             function=mri_convert),\n                               name=f'fs_aseg_to_nifti_{pipe_num}')\n    fs_aseg_to_nifti.inputs.args = '-rt nearest'\n\n    wf.connect(fs_aseg_to_native, 'transformed_file',\n               fs_aseg_to_nifti, 'in_file')\n\n    pick_tissue = pe.Node(pick_tissue_from_labels_file_interface(),\n                          name=f'select_fs_tissue_{pipe_num}')\n\n    pick_tissue.inputs.csf_label = cfg['segmentation'][\n        'tissue_segmentation']['FreeSurfer']['CSF_label']\n    pick_tissue.inputs.gm_label = cfg['segmentation'][\n        'tissue_segmentation']['FreeSurfer']['GM_label']\n    pick_tissue.inputs.wm_label = cfg['segmentation'][\n        'tissue_segmentation']['FreeSurfer']['WM_label']\n\n    wf.connect(fs_aseg_to_nifti, 'out_file', pick_tissue, 'multiatlas_Labels')\n\n    erode_tissues = {}\n    if cfg['segmentation']['tissue_segmentation']['FreeSurfer']['erode'] > 0:\n        for tissue in ['csf', 'wm', 'gm']:\n            erode_tissues[tissue] = pe.Node(\n                interface=freesurfer.model.Binarize(),\n                name=f'erode_{tissue}_{pipe_num}')\n            erode_tissues[tissue].inputs.match = [1]\n            erode_tissues[tissue].inputs.erode = cfg['segmentation'][\n                'tissue_segmentation']['FreeSurfer']['erode']\n            wf.connect(pick_tissue, f'{tissue}_mask', erode_tissues[tissue],\n                       'in_file')\n\n    if erode_tissues:\n        outputs = {\n            'label-CSF_mask': (erode_tissues['csf'], 'binary_file'), \n            'label-WM_mask': (erode_tissues['wm'], 'binary_file'),\n            'label-GM_mask': (erode_tissues['gm'], 'binary_file')\n            }\n\n    else:\n        outputs = {\n            'label-CSF_mask': (pick_tissue, 'csf_mask'),\n            'label-WM_mask': (pick_tissue, 'wm_mask'),\n            'label-GM_mask': (pick_tissue, 'gm_mask')\n        }\n\n    return (wf, outputs)"
  },
  {
    "name": "anatomical_init",
    "file": "CPAC/anat_preproc/anat_preproc.py",
    "line_number": 1273,
    "decorator_args": {
      "name": "anatomical_init",
      "config": [
        "anatomical_preproc"
      ],
      "switch": [
        "run"
      ],
      "inputs": [
        "T1w"
      ],
      "outputs": [
        "desc-preproc_T1w",
        "desc-reorient_T1w",
        "desc-head_T1w"
      ]
    },
    "docstring": null,
    "source_code": "def anatomical_init(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    anat_deoblique = pe.Node(interface=afni.Refit(),\n                             name=f'anat_deoblique_{pipe_num}')\n    anat_deoblique.inputs.deoblique = True\n\n    node, out = strat_pool.get_data('T1w')\n    wf.connect(node, out, anat_deoblique, 'in_file')\n\n    anat_reorient = pe.Node(interface=afni.Resample(),\n                            name=f'anat_reorient_{pipe_num}',\n                            mem_gb=0,\n                            mem_x=(0.0115, 'in_file', 't'))\n    anat_reorient.inputs.orientation = 'RPI'\n    anat_reorient.inputs.outputtype = 'NIFTI_GZ'\n\n    wf.connect(anat_deoblique, 'out_file', anat_reorient, 'in_file')\n\n    outputs = {'desc-preproc_T1w': (anat_reorient, 'out_file'),\n               'desc-reorient_T1w': (anat_reorient, 'out_file'),\n               'desc-head_T1w': (anat_reorient, 'out_file')}\n\n    return (wf, outputs)"
  },
  {
    "name": "acpc_align_head",
    "file": "CPAC/anat_preproc/anat_preproc.py",
    "line_number": 1310,
    "decorator_args": {
      "name": "acpc_alignment_head",
      "switch": [
        [
          "anatomical_preproc",
          "acpc_alignment",
          "run"
        ],
        [
          "anatomical_preproc",
          "run"
        ]
      ],
      "inputs": [
        "desc-head_T1w",
        "desc-preproc_T1w",
        "T1w-ACPC-template"
      ],
      "outputs": [
        "desc-head_T1w",
        "desc-preproc_T1w",
        "from-T1w_to-ACPC_mode-image_desc-aff2rig_xfm"
      ]
    },
    "docstring": null,
    "source_code": "def acpc_align_head(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    acpc_align = acpc_alignment(config=cfg,\n                                acpc_target=cfg.anatomical_preproc[\n                                    'acpc_alignment']['acpc_target'],\n                                mask=False,\n                                wf_name=f'acpc_align_{pipe_num}')\n\n    node, out = strat_pool.get_data(['desc-preproc_T1w','desc-head_T1w'])\n    wf.connect(node, out, acpc_align, 'inputspec.anat_leaf')\n\n    node, out = strat_pool.get_data('T1w-ACPC-template')\n    wf.connect(node, out, acpc_align, 'inputspec.template_head_for_acpc')\n\n    outputs = {\n        'desc-head_T1w': (acpc_align, 'outputspec.acpc_aligned_head'),\n        'desc-preproc_T1w': (acpc_align, 'outputspec.acpc_aligned_head'),\n        'from-T1w_to-ACPC_mode-image_desc-aff2rig_xfm': (\n            acpc_align,\n            'outputspec.from-T1w_to-ACPC_mode-image_desc-aff2rig_xfm')\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "acpc_align_head_with_mask",
    "file": "CPAC/anat_preproc/anat_preproc.py",
    "line_number": 1357,
    "decorator_args": {
      "name": "acpc_alignment_head_with_mask",
      "switch": [
        [
          "anatomical_preproc",
          "acpc_alignment",
          "run"
        ],
        [
          "anatomical_preproc",
          "run"
        ]
      ],
      "inputs": [
        [
          "desc-head_T1w",
          "desc-preproc_T1w",
          [
            "space-T1w_desc-brain_mask",
            "space-T1w_desc-brain_mask"
          ]
        ],
        "T1w-ACPC-template",
        "T1w-brain-ACPC-template"
      ],
      "outputs": [
        "desc-head_T1w",
        "desc-preproc_T1w",
        [
          "space-T1w_desc-brain_mask",
          "space-T1w_desc-brain_mask"
        ],
        "from-T1w_to-ACPC_mode-image_desc-aff2rig_xfm"
      ]
    },
    "docstring": null,
    "source_code": "def acpc_align_head_with_mask(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    acpc_align = acpc_alignment(config=cfg,\n                                acpc_target=cfg.anatomical_preproc[\n                                    'acpc_alignment']['acpc_target'],\n                                mask=True,\n                                wf_name=f'acpc_align_{pipe_num}')\n\n    node, out = strat_pool.get_data(['desc-head_T1w', 'desc-preproc_T1w'])\n    wf.connect(node, out, acpc_align, 'inputspec.anat_leaf')\n\n    node, out = strat_pool.get_data('T1w-ACPC-template')\n    wf.connect(node, out, acpc_align, 'inputspec.template_head_for_acpc')\n\n    if strat_pool.check_rpool(\"space-T1w_desc-brain_mask\"):\n        node, out = strat_pool.get_data(\"space-T1w_desc-brain_mask\")\n        wf.connect(node, out, acpc_align, 'inputspec.brain_mask')\n\n        node, out = strat_pool.get_data('T1w-brain-ACPC-template')\n        wf.connect(node, out, acpc_align, 'inputspec.template_brain_for_acpc')\n\n    outputs = {\n        'desc-head_T1w': (acpc_align, 'outputspec.acpc_aligned_head'),\n        'desc-preproc_T1w': (acpc_align, 'outputspec.acpc_aligned_head'),\n        'space-T1w_desc-brain_mask': (\n            acpc_align, 'outputspec.acpc_brain_mask'),\n        'from-T1w_to-ACPC_mode-image_desc-aff2rig_xfm': (\n            acpc_align, 'outputspec.from-T1w_to-ACPC_mode-image_desc-aff2rig_xfm')\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "acpc_align_brain",
    "file": "CPAC/anat_preproc/anat_preproc.py",
    "line_number": 1410,
    "decorator_args": {
      "name": "acpc_alignment_brain",
      "switch": [
        [
          "anatomical_preproc",
          "acpc_alignment",
          "run"
        ],
        [
          "anatomical_preproc",
          "run"
        ]
      ],
      "inputs": [
        [
          "desc-preproc_T1w",
          "desc-tempbrain_T1w",
          "T1w-ACPC-template",
          "T1w-brain-ACPC-template"
        ]
      ],
      "outputs": [
        "desc-preproc_T1w",
        "desc-acpcbrain_T1w",
        "from-T1w_to-ACPC_mode-image_desc-aff2rig_xfm"
      ]
    },
    "docstring": null,
    "source_code": "def acpc_align_brain(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    acpc_align = acpc_alignment(config=cfg,\n                                acpc_target=cfg.anatomical_preproc[\n                                    'acpc_alignment']['acpc_target'],\n                                mask=False,\n                                wf_name=f'acpc_align_{pipe_num}')\n\n    node, out = strat_pool.get_data('desc-preproc_T1w')\n    wf.connect(node, out, acpc_align, 'inputspec.anat_leaf')\n\n    node, out = strat_pool.get_data('desc-tempbrain_T1w')\n    wf.connect(node, out, acpc_align, 'inputspec.anat_brain')\n\n    node, out = strat_pool.get_data('T1w-ACPC-template') \n    wf.connect(node, out, acpc_align, 'inputspec.template_head_for_acpc')\n\n    node, out = strat_pool.get_data('T1w-brain-ACPC-template')\n    wf.connect(node, out, acpc_align, 'inputspec.template_brain_for_acpc')\n\n    outputs = {\n        'desc-preproc_T1w': (acpc_align, 'outputspec.acpc_aligned_head'),\n        'desc-acpcbrain_T1w': (acpc_align, 'outputspec.acpc_aligned_brain'),\n        'from-T1w_to-ACPC_mode-image_desc-aff2rig_xfm': (\n            acpc_align, 'outputspec.from-T1w_to-ACPC_mode-image_desc-aff2rig_xfm')\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "acpc_align_brain_with_mask",
    "file": "CPAC/anat_preproc/anat_preproc.py",
    "line_number": 1458,
    "decorator_args": {
      "name": "acpc_alignment_brain_with_mask",
      "switch": [
        [
          "anatomical_preproc",
          "acpc_alignment",
          "run"
        ],
        [
          "anatomical_preproc",
          "run"
        ]
      ],
      "inputs": [
        [
          "desc-preproc_T1w",
          "desc-tempbrain_T1w",
          "space-T1w_desc-brain_mask"
        ],
        "T1w-ACPC-template",
        "T1w-brain-ACPC-template"
      ],
      "outputs": [
        "desc-preproc_T1w",
        "desc-acpcbrain_T1w",
        "space-T1w_desc-brain_mask",
        "space-T1w_desc-prebrain_mask"
      ]
    },
    "docstring": null,
    "source_code": "def acpc_align_brain_with_mask(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    acpc_align = acpc_alignment(config=cfg,\n                                acpc_target=cfg.anatomical_preproc[\n                                    'acpc_alignment']['acpc_target'],\n                                mask=True,\n                                wf_name=f'acpc_align_{pipe_num}')\n\n    node, out = strat_pool.get_data('desc-preproc_T1w')\n    wf.connect(node, out, acpc_align, 'inputspec.anat_leaf')\n\n    node, out = strat_pool.get_data('desc-tempbrain_T1w')\n    wf.connect(node, out, acpc_align, 'inputspec.anat_brain')\n\n    node, out = strat_pool.get_data(\"space-T1w_desc-brain_mask\")\n    wf.connect(node, out, acpc_align, 'inputspec.brain_mask')\n\n    node, out = strat_pool.get_data('T1w-ACPC-template') \n    wf.connect(node, out, acpc_align, 'inputspec.template_head_for_acpc')\n\n    node, out = strat_pool.get_data('T1w-brain-ACPC-template')\n    wf.connect(node, out, acpc_align, 'inputspec.template_brain_for_acpc')\n\n    outputs = {\n        'desc-preproc_T1w': (acpc_align, 'outputspec.acpc_aligned_head'),\n        'desc-acpcbrain_T1w': (acpc_align, 'outputspec.acpc_aligned_brain'),\n        'space-T1w_desc-brain_mask': (acpc_align, 'outputspec.acpc_brain_mask'),\n        'space-T1w_desc-prebrain_mask': (strat_pool.get_data('space-T1_desc-brain_mask'))\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "registration_T2w_to_T1w",
    "file": "CPAC/anat_preproc/anat_preproc.py",
    "line_number": 1505,
    "decorator_args": {
      "name": "registration_T2w_to_T1w",
      "config": [
        "anatomical_preproc"
      ],
      "switch": [
        "run_t2"
      ],
      "inputs": [
        [
          "desc-preproc_T1w",
          "desc-preproc_T2w",
          "desc-acpcbrain_T1w",
          "desc-acpcbrain_T2w"
        ]
      ],
      "outputs": [
        "desc-preproc_T2w"
      ]
    },
    "docstring": null,
    "source_code": "def registration_T2w_to_T1w(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    T2_to_T1_reg = T2wToT1wReg(wf_name=f'T2w_to_T1w_Reg_{pipe_num}')\n\n    node, out = strat_pool.get_data('desc-preproc_T1w')\n    wf.connect(node, out, T2_to_T1_reg, 'inputspec.T1w')\n\n    node, out = strat_pool.get_data('desc-preproc_T2w')\n    wf.connect(node, out, T2_to_T1_reg, 'inputspec.T2w')\n\n    node, out = strat_pool.get_data(['desc-acpcbrain_T1w'])\n    wf.connect(node, out, T2_to_T1_reg, 'inputspec.T1w_brain')\n\n    node, out = strat_pool.get_data(['desc-acpcbrain_T2w'])\n    wf.connect(node, out, T2_to_T1_reg, 'inputspec.T2w_brain')\n\n    outputs = {\n        'desc-preproc_T2w': (T2_to_T1_reg, 'outputspec.T2w_to_T1w')\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "non_local_means",
    "file": "CPAC/anat_preproc/anat_preproc.py",
    "line_number": 1537,
    "decorator_args": {
      "name": "nlm_filtering",
      "switch": [
        [
          "anatomical_preproc",
          "non_local_means_filtering",
          "run"
        ],
        [
          "anatomical_preproc",
          "run"
        ]
      ],
      "inputs": [
        "desc-preproc_T1w"
      ],
      "outputs": [
        "desc-preproc_T1w"
      ]
    },
    "docstring": null,
    "source_code": "def non_local_means(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    denoise = pe.Node(interface=ants.DenoiseImage(),\n                      name=f'anat_denoise_{pipe_num}')\n\n    denoise.inputs.noise_model = cfg.anatomical_preproc['non_local_means_filtering']['noise_model']\n\n    node, out = strat_pool.get_data('desc-preproc_T1w')\n    wf.connect(node, out, denoise, 'input_image')\n\n    outputs = {\n        'desc-preproc_T1w': (denoise, 'output_image')\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "n4_bias_correction",
    "file": "CPAC/anat_preproc/anat_preproc.py",
    "line_number": 1570,
    "decorator_args": {
      "name": "n4_bias_correction",
      "switch": [
        [
          "anatomical_preproc",
          "n4_bias_field_correction",
          "run"
        ],
        [
          "anatomical_preproc",
          "run"
        ]
      ],
      "inputs": [
        "desc-preproc_T1w"
      ],
      "outputs": "!UNSUPPORTED_TYPE:Dict!"
    },
    "docstring": null,
    "source_code": "def n4_bias_correction(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    n4 = pe.Node(interface=ants.N4BiasFieldCorrection(dimension=3,\n                                                      copy_header=True),\n                 name=f'anat_n4_{pipe_num}')\n    n4.inputs.shrink_factor = cfg.anatomical_preproc['n4_bias_field_correction']['shrink_factor']\n\n    node, out = strat_pool.get_data('desc-preproc_T1w')\n    wf.connect(node, out, n4, 'input_image')\n\n    outputs = {\n        'desc-preproc_T1w': (n4, 'output_image'),\n        'desc-n4_T1w': (n4, 'output_image')\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "t1t2_bias_correction",
    "file": "CPAC/anat_preproc/anat_preproc.py",
    "line_number": 1601,
    "decorator_args": {
      "name": "t1t2_bias_correction",
      "config": [
        "anatomical_preproc",
        "t1t2_bias_field_correction"
      ],
      "switch": [
        "run"
      ],
      "inputs": [
        [
          "desc-preproc_T1w",
          "desc-preproc_T2w",
          "desc-acpcbrain_T1w"
        ]
      ],
      "outputs": [
        "desc-preproc_T1w",
        "desc-brain_T1w",
        "desc-preproc_T2w",
        "desc-brain_T2w",
        "desc-biasfield_T1wT2w"
      ]
    },
    "docstring": null,
    "source_code": "def t1t2_bias_correction(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    t1t2_bias_correction = BiasFieldCorrection_sqrtT1wXT1w(config=cfg, wf_name=f't1t2_bias_correction_{pipe_num}')\n\n    node, out = strat_pool.get_data('desc-preproc_T1w')\n    wf.connect(node, out, t1t2_bias_correction, 'inputspec.T1w')\n\n    node, out = strat_pool.get_data('desc-preproc_T2w')\n    wf.connect(node, out, t1t2_bias_correction, 'inputspec.T2w')\n\n    node, out = strat_pool.get_data(\"desc-acpcbrain_T1w\")\n    wf.connect(node, out, t1t2_bias_correction, 'inputspec.T1w_brain')\n\n    outputs = {\n        'desc-preproc_T1w': (t1t2_bias_correction, 'outputspec.T1w_biascorrected'),\n        'desc-brain_T1w': (t1t2_bias_correction, 'outputspec.T1w_brain_biascorrected'),\n        'desc-preproc_T2w': (t1t2_bias_correction, 'outputspec.T2w_biascorrected'),\n        'desc-brain_T2w': (t1t2_bias_correction, 'outputspec.T2w_brain_biascorrected'),\n        'desc-biasfield_T1wT2w': (t1t2_bias_correction, 'outputspec.biasfield'),\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "brain_mask_afni",
    "file": "CPAC/anat_preproc/anat_preproc.py",
    "line_number": 1636,
    "decorator_args": {
      "name": "brain_mask_afni",
      "switch": [
        [
          "anatomical_preproc",
          "brain_extraction",
          "run"
        ],
        [
          "anatomical_preproc",
          "run"
        ]
      ],
      "option_key": [
        "anatomical_preproc",
        "brain_extraction",
        "using"
      ],
      "option_val": "3dSkullStrip",
      "inputs": [
        "desc-preproc_T1w"
      ],
      "outputs": [
        "space-T1w_desc-brain_mask"
      ]
    },
    "docstring": null,
    "source_code": "def brain_mask_afni(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    wf, outputs = afni_brain_connector(wf, cfg, strat_pool, pipe_num, opt)\n\n    return (wf, outputs)"
  },
  {
    "name": "brain_mask_acpc_afni",
    "file": "CPAC/anat_preproc/anat_preproc.py",
    "line_number": 1654,
    "decorator_args": {
      "name": "brain_mask_acpc_afni",
      "switch": [
        [
          "anatomical_preproc",
          "brain_extraction",
          "run"
        ],
        [
          "anatomical_preproc",
          "run"
        ]
      ],
      "option_key": [
        "anatomical_preproc",
        "brain_extraction",
        "using"
      ],
      "option_val": "3dSkullStrip",
      "inputs": [
        "desc-preproc_T1w"
      ],
      "outputs": [
        "space-T1w_desc-acpcbrain_mask"
      ]
    },
    "docstring": null,
    "source_code": "def brain_mask_acpc_afni(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    wf, wf_outputs = afni_brain_connector(wf, cfg, strat_pool, pipe_num, opt)\n\n    outputs = {\n        'space-T1w_desc-acpcbrain_mask':\n            wf_outputs['space-T1w_desc-brain_mask']\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "brain_mask_fsl",
    "file": "CPAC/anat_preproc/anat_preproc.py",
    "line_number": 1677,
    "decorator_args": {
      "name": "brain_mask_fsl",
      "switch": [
        [
          "anatomical_preproc",
          "brain_extraction",
          "run"
        ],
        [
          "anatomical_preproc",
          "run"
        ]
      ],
      "option_key": [
        "anatomical_preproc",
        "brain_extraction",
        "using"
      ],
      "option_val": "BET",
      "inputs": [
        "desc-preproc_T1w"
      ],
      "outputs": [
        "space-T1w_desc-brain_mask"
      ]
    },
    "docstring": null,
    "source_code": "def brain_mask_fsl(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    wf, outputs = fsl_brain_connector(wf, cfg, strat_pool, pipe_num, opt)\n\n    return (wf, outputs)"
  },
  {
    "name": "brain_mask_acpc_fsl",
    "file": "CPAC/anat_preproc/anat_preproc.py",
    "line_number": 1695,
    "decorator_args": {
      "name": "brain_mask_acpc_fsl",
      "switch": [
        [
          "anatomical_preproc",
          "brain_extraction",
          "run"
        ],
        [
          "anatomical_preproc",
          "run"
        ]
      ],
      "option_key": [
        "anatomical_preproc",
        "brain_extraction",
        "using"
      ],
      "option_val": "BET",
      "inputs": [
        "desc-preproc_T1w"
      ],
      "outputs": [
        "space-T1w_desc-acpcbrain_mask"
      ]
    },
    "docstring": null,
    "source_code": "def brain_mask_acpc_fsl(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    wf, wf_outputs = fsl_brain_connector(wf, cfg, strat_pool, pipe_num, opt)\n\n    outputs = {\n        'space-T1w_desc-acpcbrain_mask':\n            wf_outputs['space-T1w_desc-brain_mask']\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "brain_mask_niworkflows_ants",
    "file": "CPAC/anat_preproc/anat_preproc.py",
    "line_number": 1718,
    "decorator_args": {
      "name": "brain_mask_niworkflows_ants",
      "switch": [
        [
          "anatomical_preproc",
          "brain_extraction",
          "run"
        ],
        [
          "anatomical_preproc",
          "run"
        ]
      ],
      "option_key": [
        "anatomical_preproc",
        "brain_extraction",
        "using"
      ],
      "option_val": "niworkflows-ants",
      "inputs": [
        "desc-preproc_T1w"
      ],
      "outputs": [
        "space-T1w_desc-brain_mask",
        "desc-preproc_T1w"
      ]
    },
    "docstring": null,
    "source_code": "def brain_mask_niworkflows_ants(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    wf, outputs = niworkflows_ants_brain_connector(wf, cfg, strat_pool,\n                                                   pipe_num, opt)\n\n    return (wf, outputs)"
  },
  {
    "name": "brain_mask_acpc_niworkflows_ants",
    "file": "CPAC/anat_preproc/anat_preproc.py",
    "line_number": 1737,
    "decorator_args": {
      "name": "brain_mask_acpc_niworkflows_ants",
      "switch": [
        [
          "anatomical_preproc",
          "brain_extraction",
          "run"
        ],
        [
          "anatomical_preproc",
          "run"
        ]
      ],
      "option_key": [
        "anatomical_preproc",
        "brain_extraction",
        "using"
      ],
      "option_val": "niworkflows-ants",
      "inputs": [
        "desc-preproc_T1w"
      ],
      "outputs": [
        "space-T1w_desc-acpcbrain_mask",
        "desc-preproc_T1w"
      ]
    },
    "docstring": null,
    "source_code": "def brain_mask_acpc_niworkflows_ants(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    wf, wf_outputs = niworkflows_ants_brain_connector(wf, cfg, strat_pool,\n                                                      pipe_num, opt)\n\n    outputs = {\n        'space-T1w_desc-acpcbrain_mask':\n            wf_outputs['space-T1w_desc-brain_mask'],\n        'desc-preproc_T1w':\n            wf_outputs['desc-preproc_T1w']\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "brain_mask_unet",
    "file": "CPAC/anat_preproc/anat_preproc.py",
    "line_number": 1763,
    "decorator_args": {
      "name": "brain_mask_unet",
      "switch": [
        [
          "anatomical_preproc",
          "brain_extraction",
          "run"
        ],
        [
          "anatomical_preproc",
          "run"
        ]
      ],
      "option_key": [
        "anatomical_preproc",
        "brain_extraction",
        "using"
      ],
      "option_val": "UNet",
      "inputs": [
        "desc-preproc_T1w",
        "T1w-brain-template",
        "T1w-template",
        "unet-model"
      ],
      "outputs": [
        "space-T1w_desc-brain_mask"
      ]
    },
    "docstring": null,
    "source_code": "def brain_mask_unet(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    wf, outputs = unet_brain_connector(wf, cfg, strat_pool, pipe_num, opt)\n\n    return (wf, outputs)"
  },
  {
    "name": "brain_mask_acpc_unet",
    "file": "CPAC/anat_preproc/anat_preproc.py",
    "line_number": 1781,
    "decorator_args": {
      "name": "brain_mask_acpc_unet",
      "switch": [
        [
          "anatomical_preproc",
          "brain_extraction",
          "run"
        ],
        [
          "anatomical_preproc",
          "run"
        ]
      ],
      "option_key": [
        "anatomical_preproc",
        "brain_extraction",
        "using"
      ],
      "option_val": "UNet",
      "inputs": [
        "desc-preproc_T1w",
        "T1w-brain-template",
        "T1w-template",
        "unet-model"
      ],
      "outputs": [
        "space-T1w_desc-acpcbrain_mask"
      ]
    },
    "docstring": null,
    "source_code": "def brain_mask_acpc_unet(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    wf, wf_outputs = unet_brain_connector(wf, cfg, strat_pool, pipe_num, opt)\n\n    outputs = {\n        'space-T1w_desc-acpcbrain_mask':\n            wf_outputs['space-T1w_desc-brain_mask']\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "brain_mask_freesurfer",
    "file": "CPAC/anat_preproc/anat_preproc.py",
    "line_number": 1808,
    "decorator_args": {
      "name": "brain_mask_freesurfer",
      "switch": [
        [
          "anatomical_preproc",
          "brain_extraction",
          "run"
        ],
        [
          "anatomical_preproc",
          "run"
        ]
      ],
      "option_key": [
        "anatomical_preproc",
        "brain_extraction",
        "using"
      ],
      "option_val": "FreeSurfer-Brainmask",
      "inputs": [
        "pipeline-fs_raw-average",
        "pipeline-fs_brainmask",
        "freesurfer-subject-dir"
      ],
      "outputs": [
        "space-T1w_desc-brain_mask"
      ]
    },
    "docstring": null,
    "source_code": "def brain_mask_freesurfer(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    wf, outputs = freesurfer_brain_connector(wf, cfg, strat_pool, pipe_num,\n                                             opt)\n\n    return (wf, outputs)"
  },
  {
    "name": "brain_mask_acpc_freesurfer",
    "file": "CPAC/anat_preproc/anat_preproc.py",
    "line_number": 1831,
    "decorator_args": {
      "name": "brain_mask_acpc_freesurfer",
      "switch": [
        [
          "anatomical_preproc",
          "brain_extraction",
          "run"
        ],
        [
          "anatomical_preproc",
          "run"
        ]
      ],
      "option_key": [
        "anatomical_preproc",
        "brain_extraction",
        "using"
      ],
      "option_val": "FreeSurfer-Brainmask",
      "inputs": [
        "space-T1w_desc-brain_mask",
        "pipeline-fs_raw-average",
        "freesurfer-subject-dir"
      ],
      "outputs": [
        "space-T1w_desc-acpcbrain_mask"
      ]
    },
    "docstring": null,
    "source_code": "def brain_mask_acpc_freesurfer(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    wf, wf_outputs = freesurfer_brain_connector(wf, cfg, strat_pool, pipe_num,\n                                                opt)\n\n    outputs = {'space-T1w_desc-acpcbrain_mask':\n                   wf_outputs['space-T1w_desc-brain_mask']}\n\n    return (wf, outputs)"
  },
  {
    "name": "brain_mask_freesurfer_abcd",
    "file": "CPAC/anat_preproc/anat_preproc.py",
    "line_number": 1859,
    "decorator_args": {
      "name": "brain_mask_freesurfer_abcd",
      "switch": [
        [
          "anatomical_preproc",
          "brain_extraction",
          "run"
        ],
        [
          "anatomical_preproc",
          "run"
        ]
      ],
      "option_key": [
        "anatomical_preproc",
        "brain_extraction",
        "using"
      ],
      "option_val": "FreeSurfer-ABCD",
      "inputs": [
        "desc-preproc_T1w",
        "pipeline-fs_wmparc",
        "pipeline-fs_raw-average",
        "pipeline-fs_xfm",
        "freesurfer-subject-dir"
      ],
      "outputs": [
        "space-T1w_desc-brain_mask"
      ]
    },
    "docstring": null,
    "source_code": "def brain_mask_freesurfer_abcd(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    wf, outputs = freesurfer_abcd_brain_connector(wf, cfg, strat_pool,\n                                                  pipe_num, opt)\n\n    return (wf, outputs)"
  },
  {
    "name": "brain_mask_freesurfer_fsl_tight",
    "file": "CPAC/anat_preproc/anat_preproc.py",
    "line_number": 1885,
    "decorator_args": {
      "name": "brain_mask_freesurfer_fsl_tight",
      "switch": [
        [
          "anatomical_preproc",
          "brain_extraction",
          "run"
        ],
        [
          "anatomical_preproc",
          "run"
        ]
      ],
      "option_key": [
        "anatomical_preproc",
        "brain_extraction",
        "using"
      ],
      "option_val": "FreeSurfer-BET-Tight",
      "inputs": [
        "pipeline-fs_brainmask",
        "pipeline-fs_T1",
        "pipeline-fs_raw-average",
        "freesurfer-subject-dir",
        "T1w-brain-template-mask-ccs",
        "T1w-ACPC-template"
      ],
      "outputs": [
        "space-T1w_desc-tight_brain_mask"
      ]
    },
    "docstring": null,
    "source_code": "def brain_mask_freesurfer_fsl_tight(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    wf, outputs = freesurfer_fsl_brain_connector(wf, cfg, strat_pool, pipe_num, opt)\n\n    return (wf, outputs)"
  },
  {
    "name": "brain_mask_acpc_freesurfer_abcd",
    "file": "CPAC/anat_preproc/anat_preproc.py",
    "line_number": 1909,
    "decorator_args": {
      "name": "brain_mask_acpc_freesurfer_abcd",
      "switch": [
        [
          "anatomical_preproc",
          "brain_extraction",
          "run"
        ],
        [
          "anatomical_preproc",
          "run"
        ]
      ],
      "option_key": [
        "anatomical_preproc",
        "brain_extraction",
        "using"
      ],
      "option_val": "FreeSurfer-ABCD",
      "inputs": [
        "desc-preproc_T1w",
        "pipeline-fs_wmparc",
        "pipeline-fs_raw-average",
        "pipeline-fs_xfm",
        "freesurfer-subject-dir"
      ],
      "outputs": [
        "space-T1w_desc-acpcbrain_mask"
      ]
    },
    "docstring": null,
    "source_code": "def brain_mask_acpc_freesurfer_abcd(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    wf, wf_outputs = freesurfer_abcd_brain_connector(wf, cfg, strat_pool, pipe_num, opt)\n\n    outputs = {'space-T1w_desc-acpcbrain_mask':\n                wf_outputs['space-T1w_desc-brain_mask']}\n\n    return (wf, outputs)"
  },
  {
    "name": "brain_mask_freesurfer_fsl_loose",
    "file": "CPAC/anat_preproc/anat_preproc.py",
    "line_number": 1937,
    "decorator_args": {
      "name": "brain_mask_freesurfer_fsl_loose",
      "switch": [
        [
          "anatomical_preproc",
          "brain_extraction",
          "run"
        ],
        [
          "anatomical_preproc",
          "run"
        ]
      ],
      "option_key": [
        "anatomical_preproc",
        "brain_extraction",
        "using"
      ],
      "option_val": "FreeSurfer-BET-Loose",
      "inputs": [
        "pipeline-fs_brainmask",
        "pipeline-fs_T1",
        "pipeline-fs_raw-average",
        "freesurfer-subject-dir",
        "T1w-brain-template-mask-ccs",
        "T1w-ACPC-template"
      ],
      "outputs": [
        "space-T1w_desc-loose_brain_mask"
      ]
    },
    "docstring": null,
    "source_code": "def brain_mask_freesurfer_fsl_loose(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    wf, outputs = freesurfer_fsl_brain_connector(wf, cfg, strat_pool, pipe_num, opt)\n\n    return (wf, outputs)"
  },
  {
    "name": "brain_mask_acpc_freesurfer_fsl_tight",
    "file": "CPAC/anat_preproc/anat_preproc.py",
    "line_number": 1960,
    "decorator_args": {
      "name": "brain_mask_acpc_freesurfer_fsl_tight",
      "switch": [
        [
          "anatomical_preproc",
          "brain_extraction",
          "run"
        ],
        [
          "anatomical_preproc",
          "run"
        ]
      ],
      "option_key": [
        "anatomical_preproc",
        "brain_extraction",
        "using"
      ],
      "option_val": "FreeSurfer-BET-Tight",
      "inputs": [
        "pipeline-fs_brainmask",
        "pipeline-fs_T1",
        "T1w-brain-template-mask-ccs",
        "T1w-ACPC-template"
      ],
      "outputs": [
        "space-T1w_desc-tight_acpcbrain_mask"
      ]
    },
    "docstring": null,
    "source_code": "def brain_mask_acpc_freesurfer_fsl_tight(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    wf, wf_outputs = freesurfer_fsl_brain_connector(wf, cfg, strat_pool,\n                                                    pipe_num, opt)\n\n    outputs = {'space-T1w_desc-tight_acpcbrain_mask':\n        wf_outputs['space-T1w_desc-tight_brain_mask']}\n\n    return (wf, outputs)"
  },
  {
    "name": "brain_mask_acpc_freesurfer_fsl_loose",
    "file": "CPAC/anat_preproc/anat_preproc.py",
    "line_number": 1987,
    "decorator_args": {
      "name": "brain_mask_acpc_freesurfer_fsl_loose",
      "switch": [
        [
          "anatomical_preproc",
          "brain_extraction",
          "run"
        ],
        [
          "anatomical_preproc",
          "run"
        ]
      ],
      "option_key": [
        "anatomical_preproc",
        "brain_extraction",
        "using"
      ],
      "option_val": "FreeSurfer-BET-Loose",
      "inputs": [
        "pipeline-fs_brainmask",
        "pipeline-fs_T1",
        "T1w-brain-template-mask-ccs",
        "T1w-ACPC-template"
      ],
      "outputs": [
        "space-T1w_desc-loose_acpcbrain_mask"
      ]
    },
    "docstring": null,
    "source_code": "def brain_mask_acpc_freesurfer_fsl_loose(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    wf, wf_outputs = freesurfer_fsl_brain_connector(wf, cfg, strat_pool, pipe_num, opt)\n\n    outputs = {'space-T1w_desc-loose_acpcbrain_mask':\n        wf_outputs['space-T1w_desc-loose_brain_mask']}\n\n    return (wf, outputs)"
  },
  {
    "name": "brain_extraction",
    "file": "CPAC/anat_preproc/anat_preproc.py",
    "line_number": 2016,
    "decorator_args": {
      "name": "brain_extraction",
      "switch": [
        [
          "anatomical_preproc",
          "brain_extraction",
          "run"
        ],
        [
          "anatomical_preproc",
          "run"
        ]
      ],
      "inputs": [
        [
          "desc-head_T1w",
          "desc-preproc_T1w",
          [
            "space-T1w_desc-brain_mask",
            "space-T1w_desc-acpcbrain_mask"
          ]
        ]
      ],
      "outputs": "!UNSUPPORTED_TYPE:Dict!"
    },
    "docstring": "brain_mask_deoblique = pe.Node(interface=afni.Refit(),\n                               name='brain_mask_deoblique')\nbrain_mask_deoblique.inputs.deoblique = True\nwf.connect(inputnode, 'brain_mask',\n                brain_mask_deoblique, 'in_file')\n\nbrain_mask_reorient = pe.Node(interface=afni.Resample(),\n                              name='brain_mask_reorient',\n                              mem_gb=0,\n                              mem_x=(0.0115, 'in_file', 't'))\nbrain_mask_reorient.inputs.orientation = 'RPI'\nbrain_mask_reorient.inputs.outputtype = 'NIFTI_GZ'\nwf.connect(brain_mask_deoblique, 'out_file',\n                brain_mask_reorient, 'in_file')",
    "source_code": "def brain_extraction(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    '''\n    brain_mask_deoblique = pe.Node(interface=afni.Refit(),\n                                   name='brain_mask_deoblique')\n    brain_mask_deoblique.inputs.deoblique = True\n    wf.connect(inputnode, 'brain_mask',\n                    brain_mask_deoblique, 'in_file')\n\n    brain_mask_reorient = pe.Node(interface=afni.Resample(),\n                                  name='brain_mask_reorient',\n                                  mem_gb=0,\n                                  mem_x=(0.0115, 'in_file', 't'))\n    brain_mask_reorient.inputs.orientation = 'RPI'\n    brain_mask_reorient.inputs.outputtype = 'NIFTI_GZ'\n    wf.connect(brain_mask_deoblique, 'out_file',\n                    brain_mask_reorient, 'in_file')\n    '''\n\n    anat_skullstrip_orig_vol = pe.Node(interface=afni.Calc(),\n                                       name=f'brain_extraction_{pipe_num}')\n\n    anat_skullstrip_orig_vol.inputs.expr = 'a*step(b)'\n    anat_skullstrip_orig_vol.inputs.outputtype = 'NIFTI_GZ'\n\n    node_T1w, out_T1w = strat_pool.get_data('desc-head_T1w')\n    wf.connect(node_T1w, out_T1w, anat_skullstrip_orig_vol, 'in_file_a')\n\n    node, out = strat_pool.get_data(['space-T1w_desc-brain_mask',\n                                     'space-T1w_desc-acpcbrain_mask'])\n    wf.connect(node, out, anat_skullstrip_orig_vol, 'in_file_b')\n\n    outputs = {\n        'desc-preproc_T1w': (anat_skullstrip_orig_vol, 'out_file'),\n        'desc-brain_T1w': (anat_skullstrip_orig_vol, 'out_file'),\n        'desc-head_T1w': (node_T1w, out_T1w)\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "brain_extraction_temp",
    "file": "CPAC/anat_preproc/anat_preproc.py",
    "line_number": 2070,
    "decorator_args": {
      "name": "brain_extraction_temp",
      "inputs": [
        [
          "desc-preproc_T1w",
          [
            "space-T1w_desc-brain_mask",
            "space-T1w_desc-acpcbrain_mask"
          ]
        ]
      ],
      "outputs": "!UNSUPPORTED_TYPE:Dict!"
    },
    "docstring": null,
    "source_code": "def brain_extraction_temp(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    anat_skullstrip_orig_vol = pe.Node(interface=afni.Calc(),\n                                       name=f'brain_extraction_temp_{pipe_num}')\n\n    anat_skullstrip_orig_vol.inputs.expr = 'a*step(b)'\n    anat_skullstrip_orig_vol.inputs.outputtype = 'NIFTI_GZ'\n\n    node, out = strat_pool.get_data('desc-preproc_T1w')\n    wf.connect(node, out, anat_skullstrip_orig_vol, 'in_file_a')\n\n    node, out = strat_pool.get_data(['space-T1w_desc-brain_mask',\n                                     'space-T1w_desc-acpcbrain_mask'])\n    wf.connect(node, out, anat_skullstrip_orig_vol, 'in_file_b')\n\n    outputs = {\n        'desc-preproc_T1w': (anat_skullstrip_orig_vol, 'out_file'),\n        'desc-tempbrain_T1w': (anat_skullstrip_orig_vol, 'out_file')\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "anatomical_init_T2",
    "file": "CPAC/anat_preproc/anat_preproc.py",
    "line_number": 2100,
    "decorator_args": {
      "name": "anatomical_init_T2",
      "config": [
        "anatomical_preproc"
      ],
      "switch": [
        "run_t2"
      ],
      "inputs": [
        "T2w"
      ],
      "outputs": [
        "desc-preproc_T2w",
        "desc-reorient_T2w",
        "desc-head_T2w"
      ]
    },
    "docstring": null,
    "source_code": "def anatomical_init_T2(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    T2_deoblique = pe.Node(interface=afni.Refit(),\n                             name=f'T2_deoblique_{pipe_num}')\n    T2_deoblique.inputs.deoblique = True\n\n    node, out = strat_pool.get_data('T2w')\n    wf.connect(node, out, T2_deoblique, 'in_file')\n\n    T2_reorient = pe.Node(interface=afni.Resample(),\n                          name=f'T2_reorient_{pipe_num}',\n                          mem_gb=0,\n                          mem_x=(0.0115, 'in_file', 't'))\n    T2_reorient.inputs.orientation = 'RPI'\n    T2_reorient.inputs.outputtype = 'NIFTI_GZ'\n\n    wf.connect(T2_deoblique, 'out_file', T2_reorient, 'in_file')\n\n    outputs = {'desc-preproc_T2w': (T2_reorient, 'out_file'),\n               'desc-reorient_T2w': (T2_reorient, 'out_file'),\n               'desc-head_T2w': (T2_reorient, 'out_file')}\n\n    return (wf, outputs)"
  },
  {
    "name": "acpc_align_head_T2",
    "file": "CPAC/anat_preproc/anat_preproc.py",
    "line_number": 2134,
    "decorator_args": {
      "name": "acpc_alignment_head_T2",
      "switch": [
        [
          "anatomical_preproc",
          "acpc_alignment",
          "run"
        ],
        [
          "anatomical_preproc",
          "run_t2"
        ]
      ],
      "inputs": [
        "desc-preproc_T2w",
        "T2w-ACPC-template"
      ],
      "outputs": [
        "desc-preproc_T2w"
      ]
    },
    "docstring": null,
    "source_code": "def acpc_align_head_T2(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    acpc_align = acpc_alignment(config=cfg,\n                                acpc_target=cfg.anatomical_preproc[\n                                    'acpc_alignment']['acpc_target'],\n                                mask=False,\n                                wf_name=f'acpc_align_T2_{pipe_num}')\n\n    node, out = strat_pool.get_data('desc-preproc_T2w')\n    wf.connect(node, out, acpc_align, 'inputspec.anat_leaf')\n\n    node, out = strat_pool.get_data('T2w-ACPC-template') \n    wf.connect(node, out, acpc_align, 'inputspec.template_head_for_acpc')\n\n    outputs = {\n        'desc-preproc_T2w': (acpc_align, 'outputspec.acpc_aligned_head')\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "acpc_align_head_with_mask_T2",
    "file": "CPAC/anat_preproc/anat_preproc.py",
    "line_number": 2164,
    "decorator_args": {
      "name": "acpc_alignment_head_with_mask_T2",
      "switch": [
        [
          "anatomical_preproc",
          "acpc_alignment",
          "run"
        ],
        [
          "anatomical_preproc",
          "run_t2"
        ]
      ],
      "inputs": [
        [
          "desc-preproc_T2w",
          "space-T2w_desc-brain_mask"
        ],
        "T2w-ACPC-template"
      ],
      "outputs": [
        "desc-preproc_T2w",
        "space-T2w_desc-brain_mask"
      ]
    },
    "docstring": null,
    "source_code": "def acpc_align_head_with_mask_T2(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    acpc_align = acpc_alignment(config=cfg,\n                                acpc_target=cfg.anatomical_preproc[\n                                    'acpc_alignment']['acpc_target'],\n                                mask=True,\n                                wf_name=f'acpc_align_T2_{pipe_num}')\n\n    node, out = strat_pool.get_data('desc-preproc_T2w')\n    wf.connect(node, out, acpc_align, 'inputspec.anat_leaf')\n\n    node, out = strat_pool.get_data('T2w-ACPC-template') \n    wf.connect(node, out, acpc_align, 'inputspec.template_head_for_acpc')\n\n    outputs = {\n        'desc-preproc_T2w': (acpc_align, 'outputspec.acpc_aligned_head'),\n        'space-T2w_desc-brain_mask': (\n        acpc_align, 'outputspec.acpc_brain_mask')\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "acpc_align_brain_T2",
    "file": "CPAC/anat_preproc/anat_preproc.py",
    "line_number": 2203,
    "decorator_args": {
      "name": "acpc_alignment_brain_T2",
      "switch": [
        [
          "anatomical_preproc",
          "acpc_alignment",
          "run"
        ],
        [
          "anatomical_preproc",
          "run_t2"
        ]
      ],
      "inputs": [
        [
          "desc-preproc_T2w",
          "desc-tempbrain_T2w",
          "T2w-ACPC-template",
          "T2w-brain-ACPC-template"
        ]
      ],
      "outputs": [
        "desc-preproc_T2w",
        "desc-acpcbrain_T2w"
      ]
    },
    "docstring": null,
    "source_code": "def acpc_align_brain_T2(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    acpc_align = acpc_alignment(config=cfg,\n                                acpc_target=cfg.anatomical_preproc[\n                                    'acpc_alignment']['acpc_target'],\n                                mask=False,\n                                wf_name=f'acpc_align_T2_{pipe_num}')\n\n    node, out = strat_pool.get_data('desc-preproc_T2w')\n    wf.connect(node, out, acpc_align, 'inputspec.anat_leaf')\n\n    node, out = strat_pool.get_data('desc-tempbrain_T2w')\n    wf.connect(node, out, acpc_align, 'inputspec.anat_brain')\n\n    node, out = strat_pool.get_data('T2w-ACPC-template') \n    wf.connect(node, out, acpc_align, 'inputspec.template_head_for_acpc')\n\n    node, out = strat_pool.get_data('T2w-brain-ACPC-template') \n    wf.connect(node, out, acpc_align, 'inputspec.template_brain_for_acpc')\n\n    outputs = {\n        'desc-preproc_T2w': (acpc_align, 'outputspec.acpc_aligned_head'),\n        'desc-acpcbrain_T2w': (acpc_align, 'outputspec.acpc_aligned_brain')\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "acpc_align_brain_with_mask_T2",
    "file": "CPAC/anat_preproc/anat_preproc.py",
    "line_number": 2244,
    "decorator_args": {
      "name": "acpc_alignment_T2_brain_with_mask",
      "switch": [
        [
          "anatomical_preproc",
          "acpc_alignment",
          "run"
        ],
        [
          "anatomical_preproc",
          "run_t2"
        ]
      ],
      "inputs": [
        [
          "desc-preproc_T2w",
          "desc-tempbrain_T2w",
          "space-T2w_desc-brain_mask"
        ],
        "T2w-ACPC-template",
        "T2w-brain-ACPC-template"
      ],
      "outputs": [
        "desc-preproc_T2w",
        "desc-acpcbrain_T2w",
        "space-T2w_desc-brain_mask"
      ]
    },
    "docstring": null,
    "source_code": "def acpc_align_brain_with_mask_T2(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    acpc_align = acpc_alignment(config=cfg,\n                                acpc_target=cfg.anatomical_preproc[\n                                    'acpc_alignment']['acpc_target'],\n                                mask=True,\n                                wf_name=f'acpc_align_T2_{pipe_num}')\n\n    node, out = strat_pool.get_data('desc-preproc_T2w')\n    wf.connect(node, out, acpc_align, 'inputspec.anat_leaf')\n\n    node, out = strat_pool.get_data('desc-tempbrain_T2w')\n    wf.connect(node, out, acpc_align, 'inputspec.anat_brain')\n\n    node, out = strat_pool.get_data('space-T2w_desc-brain_mask')\n    wf.connect(node, out, acpc_align, 'inputspec.brain_mask')\n\n    node, out = strat_pool.get_data('T2w-ACPC-template') \n    wf.connect(node, out, acpc_align, 'inputspec.template_head_for_acpc')\n\n    node, out = strat_pool.get_data('T2w-brain-ACPC-template')  \n    wf.connect(node, out, acpc_align, 'inputspec.template_brain_for_acpc')\n\n    outputs = {\n        'desc-preproc_T2w': (acpc_align, 'outputspec.acpc_aligned_head'),\n        'desc-acpcbrain_T2w': (acpc_align, 'outputspec.acpc_aligned_brain'),\n        'space-T2w_desc-brain_mask': (\n        acpc_align, 'outputspec.acpc_brain_mask')\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "non_local_means_T2",
    "file": "CPAC/anat_preproc/anat_preproc.py",
    "line_number": 2286,
    "decorator_args": {
      "name": "nlm_filtering_T2",
      "switch": [
        [
          "anatomical_preproc",
          "non_local_means_filtering",
          "run"
        ],
        [
          "anatomical_preproc",
          "run_t2"
        ]
      ],
      "inputs": [
        "desc-preproc_T2w"
      ],
      "outputs": [
        "desc-preproc_T2w"
      ]
    },
    "docstring": null,
    "source_code": "def non_local_means_T2(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    denoise = pe.Node(interface=ants.DenoiseImage(),\n                      name=f'anat_denoise_T2_{pipe_num}')\n\n    node, out = strat_pool.get_data('desc-preproc_T2w')\n    wf.connect(node, out, denoise, 'input_image')\n\n    outputs = {\n        'desc-preproc_T2w': (denoise, 'output_image')\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "n4_bias_correction_T2",
    "file": "CPAC/anat_preproc/anat_preproc.py",
    "line_number": 2310,
    "decorator_args": {
      "name": "n4_bias_correction_T2",
      "switch": [
        [
          "anatomical_preproc",
          "n4_bias_field_correction",
          "run"
        ],
        [
          "anatomical_preproc",
          "run_t2"
        ]
      ],
      "inputs": [
        "desc-preproc_T2w"
      ],
      "outputs": [
        "desc-preproc_T2w"
      ]
    },
    "docstring": null,
    "source_code": "def n4_bias_correction_T2(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    n4 = pe.Node(interface=ants.N4BiasFieldCorrection(dimension=3,\n                                                      shrink_factor=2,\n                                                      copy_header=True),\n                 name=f'anat_n4_T2_{pipe_num}')\n\n    node, out = strat_pool.get_data('desc-preproc_T2w')\n    wf.connect(node, out, n4, 'input_image')\n\n    outputs = {\n        'desc-preproc_T2w': (n4, 'output_image')\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "brain_mask_afni_T2",
    "file": "CPAC/anat_preproc/anat_preproc.py",
    "line_number": 2335,
    "decorator_args": {
      "name": "brain_mask_afni_T2",
      "config": [
        "anatomical_preproc",
        "brain_extraction"
      ],
      "option_key": "using",
      "option_val": "3dSkullStrip",
      "inputs": [
        "desc-preproc_T2w"
      ],
      "outputs": [
        "space-T2w_desc-brain_mask"
      ]
    },
    "docstring": null,
    "source_code": "def brain_mask_afni_T2(wf, cfg, strat_pool, pipe_num, opt=None):\n    wf, outputs = afni_brain_connector(wf, cfg, strat_pool, pipe_num, opt)\n\n    return (wf, outputs)"
  },
  {
    "name": "brain_mask_acpc_afni_T2",
    "file": "CPAC/anat_preproc/anat_preproc.py",
    "line_number": 2349,
    "decorator_args": {
      "name": "brain_mask_acpc_afni_T2",
      "config": [
        "anatomical_preproc",
        "brain_extraction"
      ],
      "option_key": "using",
      "option_val": "3dSkullStrip",
      "inputs": [
        "desc-preproc_T2w"
      ],
      "outputs": [
        "space-T2w_desc-acpcbrain_mask"
      ]
    },
    "docstring": null,
    "source_code": "def brain_mask_acpc_afni_T2(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    wf, wf_outputs = afni_brain_connector(wf, cfg, strat_pool, pipe_num, opt)\n\n    outputs = {\n        'space-T2w_desc-acpcbrain_mask':\n            wf_outputs['space-T2w_desc-brain_mask']\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "brain_mask_fsl_T2",
    "file": "CPAC/anat_preproc/anat_preproc.py",
    "line_number": 2369,
    "decorator_args": {
      "name": "brain_mask_fsl_T2",
      "config": [
        "anatomical_preproc",
        "brain_extraction"
      ],
      "option_key": "using",
      "option_val": "BET",
      "inputs": [
        "desc-preproc_T2w"
      ],
      "outputs": [
        "space-T2w_desc-brain_mask"
      ]
    },
    "docstring": null,
    "source_code": "def brain_mask_fsl_T2(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    wf, outputs = fsl_brain_connector(wf, cfg, strat_pool, pipe_num, opt)\n\n    return (wf, outputs)"
  },
  {
    "name": "brain_mask_acpc_fsl_T2",
    "file": "CPAC/anat_preproc/anat_preproc.py",
    "line_number": 2384,
    "decorator_args": {
      "name": "brain_mask_acpc_fsl_T2",
      "config": [
        "anatomical_preproc",
        "brain_extraction"
      ],
      "option_key": "using",
      "option_val": "BET",
      "inputs": [
        "desc-preproc_T2w"
      ],
      "outputs": [
        "space-T2w_desc-acpcbrain_mask"
      ]
    },
    "docstring": null,
    "source_code": "def brain_mask_acpc_fsl_T2(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    wf, wf_outputs = fsl_brain_connector(wf, cfg, strat_pool, pipe_num, opt)\n\n    outputs = {\n        'space-T2w_desc-acpcbrain_mask':\n            wf_outputs['space-T2w_desc-brain_mask']\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "brain_mask_niworkflows_ants_T2",
    "file": "CPAC/anat_preproc/anat_preproc.py",
    "line_number": 2404,
    "decorator_args": {
      "name": "brain_mask_niworkflows_ants_T2",
      "config": [
        "anatomical_preproc",
        "brain_extraction"
      ],
      "option_key": "using",
      "option_val": "niworkflows-ants",
      "inputs": [
        "desc-preproc_T2w"
      ],
      "outputs": [
        "space-T2w_desc-brain_mask"
      ]
    },
    "docstring": null,
    "source_code": "def brain_mask_niworkflows_ants_T2(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    wf, outputs = niworkflows_ants_brain_connector(wf, cfg, strat_pool,\n                                                   pipe_num, opt)\n\n    return (wf, outputs)"
  },
  {
    "name": "brain_mask_acpc_niworkflows_ants_T2",
    "file": "CPAC/anat_preproc/anat_preproc.py",
    "line_number": 2420,
    "decorator_args": {
      "name": "brain_mask_acpc_niworkflows_ants_T2",
      "config": [
        "anatomical_preproc",
        "brain_extraction"
      ],
      "option_key": "using",
      "option_val": "niworkflows-ants",
      "inputs": [
        "desc-preproc_T2w"
      ],
      "outputs": [
        "space-T2w_desc-acpcbrain_mask"
      ]
    },
    "docstring": null,
    "source_code": "def brain_mask_acpc_niworkflows_ants_T2(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    wf, wf_outputs = niworkflows_ants_brain_connector(wf, cfg, strat_pool,\n                                                      pipe_num, opt)\n\n    outputs = {\n        'space-T2w_desc-acpcbrain_mask':\n            wf_outputs['space-T2w_desc-brain_mask']\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "brain_mask_unet_T2",
    "file": "CPAC/anat_preproc/anat_preproc.py",
    "line_number": 2441,
    "decorator_args": {
      "name": "brain_mask_unet_T2",
      "config": [
        "anatomical_preproc",
        "brain_extraction"
      ],
      "option_key": "using",
      "option_val": "UNet",
      "inputs": [
        "desc-preproc_T2w",
        "T1w-brain-template",
        "T1w-template",
        "unet_model"
      ],
      "outputs": [
        "space-T2w_desc-brain_mask"
      ]
    },
    "docstring": null,
    "source_code": "def brain_mask_unet_T2(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    wf, outputs = unet_brain_connector(wf, cfg, strat_pool, pipe_num, opt)\n\n    return (wf, outputs)"
  },
  {
    "name": "brain_mask_acpc_unet_T2",
    "file": "CPAC/anat_preproc/anat_preproc.py",
    "line_number": 2456,
    "decorator_args": {
      "name": "brain_mask_acpc_unet_T2",
      "config": [
        "anatomical_preproc",
        "brain_extraction"
      ],
      "option_key": "using",
      "option_val": "UNet",
      "inputs": [
        "desc-preproc_T2w",
        "T1w-brain-template",
        "T1w-template",
        "unet_model"
      ],
      "outputs": [
        "space-T2w_desc-acpcbrain_mask"
      ]
    },
    "docstring": null,
    "source_code": "def brain_mask_acpc_unet_T2(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    wf, wf_outputs = unet_brain_connector(wf, cfg, strat_pool, pipe_num, opt)\n\n    outputs = {\n        'space-T2w_desc-acpcbrain_mask':\n            wf_outputs['space-T2w_desc-brain_mask']\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "brain_mask_T2",
    "file": "CPAC/anat_preproc/anat_preproc.py",
    "line_number": 2482,
    "decorator_args": {
      "name": "brain_mask_T2",
      "config": [
        "anatomical_preproc"
      ],
      "switch": [
        "run_t2"
      ],
      "inputs": [
        [
          [
            "desc-reorient_T1w",
            "T1w",
            "desc-preproc_T1w"
          ],
          [
            "desc-reorient_T2w",
            "T2w",
            "desc-preproc_T2w"
          ],
          [
            "space-T1w_desc-brain_mask",
            "space-T1w_desc-acpcbrain_mask"
          ],
          "space-T2w_desc-acpcbrain_mask"
        ]
      ],
      "outputs": [
        "space-T2w_desc-brain_mask"
      ]
    },
    "docstring": null,
    "source_code": "def brain_mask_T2(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    brain_mask_T2 = mask_T2(wf_name=f'brain_mask_T2_{pipe_num}')\n\n    if not cfg.anatomical_preproc['acpc_alignment']['run']:\n        node, out = strat_pool.get_data(['desc-reorient_T1w','T1w','desc-preproc_T1w'])\n        wf.connect(node, out, brain_mask_T2, 'inputspec.T1w')\n\n        node, out = strat_pool.get_data(['desc-reorient_T2w', 'T2w', 'desc-preproc_T2w'])\n        wf.connect(node, out, brain_mask_T2, 'inputspec.T2w')\n\n    else:\n        node, out = strat_pool.get_data(['desc-preproc_T1w','desc-reorient_T1w','T1w'])\n        wf.connect(node, out, brain_mask_T2, 'inputspec.T1w')\n\n        node, out = strat_pool.get_data(['desc-preproc_T2w','desc-reorient_T2w', 'T2w'])\n        wf.connect(node, out, brain_mask_T2, 'inputspec.T2w')\n\n    node, out = strat_pool.get_data([\"space-T1w_desc-brain_mask\",\n                                     \"space-T1w_desc-acpcbrain_mask\"])\n    wf.connect(node, out, brain_mask_T2, 'inputspec.T1w_mask')\n    \n    outputs = {\n        'space-T2w_desc-brain_mask': (brain_mask_T2, 'outputspec.T2w_mask')\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "brain_mask_acpc_T2",
    "file": "CPAC/anat_preproc/anat_preproc.py",
    "line_number": 2522,
    "decorator_args": {
      "name": "brain_mask_acpc_T2",
      "config": [
        "anatomical_preproc"
      ],
      "switch": [
        "run_t2"
      ],
      "inputs": [
        "desc-reorient_T1w",
        "desc-reorient_T2w",
        [
          "space-T1w_desc-acpcbrain_mask",
          "space-T1w_desc-prebrain_mask"
        ]
      ],
      "outputs": [
        "space-T2w_desc-acpcbrain_mask"
      ]
    },
    "docstring": null,
    "source_code": "def brain_mask_acpc_T2(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    brain_mask_T2 = mask_T2(wf_name=f'brain_mask_acpc_T2_{pipe_num}')\n\n    node, out = strat_pool.get_data('desc-reorient_T1w')\n    wf.connect(node, out, brain_mask_T2, 'inputspec.T1w')\n\n    node, out = strat_pool.get_data('desc-reorient_T2w')\n    wf.connect(node, out, brain_mask_T2, 'inputspec.T2w')\n\n    node, out = strat_pool.get_data([\"space-T1w_desc-acpcbrain_mask\", \"space-T1w_desc-prebrain_mask\"])\n    wf.connect(node, out, brain_mask_T2, 'inputspec.T1w_mask')\n\n    outputs = {\n        'space-T2w_desc-acpcbrain_mask': (brain_mask_T2, 'outputspec.T2w_mask')\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "brain_extraction_T2",
    "file": "CPAC/anat_preproc/anat_preproc.py",
    "line_number": 2555,
    "decorator_args": {
      "name": "brain_extraction_T2",
      "config": [
        "anatomical_preproc"
      ],
      "switch": [
        "run_t2"
      ],
      "inputs": [
        [
          "desc-acpcbrain_T2w",
          "desc-preproc_T2w",
          [
            "space-T2w_desc-brain_mask",
            "space-T2w_desc-acpcbrain_mask"
          ]
        ]
      ],
      "outputs": [
        "desc-brain_T2w"
      ]
    },
    "docstring": null,
    "source_code": "def brain_extraction_T2(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    if cfg.anatomical_preproc['acpc_alignment']['run'] and cfg.anatomical_preproc['acpc_alignment']['acpc_target'] == 'brain':\n        outputs = {\n            'desc-brain_T2w': (strat_pool.get_data([\"desc-acpcbrain_T2w\"]))\n        }\n    else:\n        anat_skullstrip_orig_vol = pe.Node(interface=afni.Calc(),\n                                        name=f'brain_extraction_T2_{pipe_num}')\n\n        anat_skullstrip_orig_vol.inputs.expr = 'a*step(b)'\n        anat_skullstrip_orig_vol.inputs.outputtype = 'NIFTI_GZ'\n\n        node, out = strat_pool.get_data('desc-preproc_T2w')\n        wf.connect(node, out, anat_skullstrip_orig_vol, 'in_file_a')\n\n        node, out = strat_pool.get_data(['space-T2w_desc-brain_mask'])\n        wf.connect(node, out, anat_skullstrip_orig_vol, 'in_file_b')\n\n        outputs = {\n            'desc-brain_T2w': (anat_skullstrip_orig_vol, 'out_file')\n        }\n\n    return (wf, outputs)"
  },
  {
    "name": "brain_extraction_temp_T2",
    "file": "CPAC/anat_preproc/anat_preproc.py",
    "line_number": 2593,
    "decorator_args": {
      "name": "brain_extraction_temp_T2",
      "config": [
        "anatomical_preproc"
      ],
      "switch": [
        "run_t2"
      ],
      "inputs": [
        [
          "desc-preproc_T2w",
          [
            "space-T2w_desc-brain_mask",
            "space-T2w_desc-acpcbrain_mask"
          ]
        ]
      ],
      "outputs": [
        "desc-tempbrain_T2w"
      ]
    },
    "docstring": null,
    "source_code": "def brain_extraction_temp_T2(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    anat_skullstrip_orig_vol = pe.Node(interface=afni.Calc(),\n                                       name=f'brain_extraction_temp_T2_{pipe_num}')\n\n    anat_skullstrip_orig_vol.inputs.expr = 'a*step(b)'\n    anat_skullstrip_orig_vol.inputs.outputtype = 'NIFTI_GZ'\n\n    node, out = strat_pool.get_data('desc-preproc_T2w')\n    wf.connect(node, out, anat_skullstrip_orig_vol, 'in_file_a')\n\n    node, out = strat_pool.get_data(['space-T2w_desc-brain_mask',\n                                     'space-T2w_desc-acpcbrain_mask'])\n    wf.connect(node, out, anat_skullstrip_orig_vol, 'in_file_b')\n\n    outputs = {\n        'desc-tempbrain_T2w': (anat_skullstrip_orig_vol, 'out_file')\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "freesurfer_abcd_preproc",
    "file": "CPAC/anat_preproc/anat_preproc.py",
    "line_number": 2651,
    "decorator_args": {
      "name": "freesurfer_abcd_preproc",
      "config": [
        "surface_analysis",
        "abcd_prefreesurfer_prep"
      ],
      "switch": [
        "run"
      ],
      "inputs": [
        "desc-preproc_T1w",
        "T1w-template",
        "T1w-brain-template-mask",
        "template-ref-mask-res-2",
        "T1w-template-res-2",
        "freesurfer-subject-dir"
      ],
      "outputs": [
        "desc-restore_T1w",
        "desc-restore-brain_T1w",
        "desc-ABCDpreproc_T1w",
        "pipeline-fs_desc-fast_biasfield",
        "pipeline-fs_hemi-L_desc-surface_curv",
        "pipeline-fs_hemi-R_desc-surface_curv",
        "pipeline-fs_hemi-L_desc-surfaceMesh_pial",
        "pipeline-fs_hemi-R_desc-surfaceMesh_pial",
        "pipeline-fs_hemi-L_desc-surfaceMesh_smoothwm",
        "pipeline-fs_hemi-R_desc-surfaceMesh_smoothwm",
        "pipeline-fs_hemi-L_desc-surfaceMesh_sphere",
        "pipeline-fs_hemi-R_desc-surfaceMesh_sphere",
        "pipeline-fs_hemi-L_desc-surfaceMap_sulc",
        "pipeline-fs_hemi-R_desc-surfaceMap_sulc",
        "pipeline-fs_hemi-L_desc-surfaceMap_thickness",
        "pipeline-fs_hemi-R_desc-surfaceMap_thickness",
        "pipeline-fs_hemi-L_desc-surfaceMap_volume",
        "pipeline-fs_hemi-R_desc-surfaceMap_volume",
        "pipeline-fs_hemi-L_desc-surfaceMesh_white",
        "pipeline-fs_hemi-R_desc-surfaceMesh_white",
        "pipeline-fs_wmparc",
        "freesurfer-subject-dir"
      ]
    },
    "docstring": null,
    "source_code": "def freesurfer_abcd_preproc(wf, cfg, strat_pool, pipe_num, opt=None):\n    # fnirt-based brain extraction\n    brain_extraction = fnirt_based_brain_extraction(config=cfg,\n                                                    wf_name=f'fnirt_based_brain_extraction_{pipe_num}')\n\n    node, out = strat_pool.get_data('desc-preproc_T1w')\n    wf.connect(node, out, brain_extraction, 'inputspec.anat_data')\n\n    node, out = strat_pool.get_data('template-ref-mask-res-2')\n    wf.connect(node, out, brain_extraction, 'inputspec.template-ref-mask-res-2')\n\n    node, out = strat_pool.get_data('T1w-template')\n    wf.connect(node, out, brain_extraction, 'inputspec.template_skull_for_anat')\n\n    node, out = strat_pool.get_data('T1w-template-res-2')\n    wf.connect(node, out, brain_extraction, 'inputspec.template_skull_for_anat_2mm')\n\n    node, out = strat_pool.get_data('T1w-brain-template-mask')\n    wf.connect(node, out, brain_extraction, 'inputspec.template_brain_mask_for_anat')\n\n    # fast bias field correction\n    fast_correction = fast_bias_field_correction(config=cfg,\n                                                 wf_name=f'fast_bias_field_correction_{pipe_num}')\n\n    node, out = strat_pool.get_data('desc-preproc_T1w')\n    wf.connect(node, out, fast_correction, 'inputspec.anat_data')\n\n    wf.connect(brain_extraction, 'outputspec.anat_brain', fast_correction, 'inputspec.anat_brain')\n\n    wf.connect(brain_extraction, 'outputspec.anat_brain_mask', fast_correction, 'inputspec.anat_brain_mask')\n\n    ### ABCD Harmonization ###\n    # Ref: https://github.com/DCAN-Labs/DCAN-HCP/blob/master/FreeSurfer/FreeSurferPipeline.sh#L140-L144\n\n    # flirt -interp spline -in \"$T1wImage\" -ref \"$T1wImage\" -applyisoxfm 1 -out \"$T1wImageFile\"_1mm.nii.gz\n    resample_head_1mm = pe.Node(interface=fsl.FLIRT(),\n                                name=f'resample_anat_head_1mm_{pipe_num}')\n    resample_head_1mm.inputs.interp = 'spline'\n    resample_head_1mm.inputs.apply_isoxfm = 1\n\n    node, out = strat_pool.get_data('desc-preproc_T1w')\n    wf.connect(node, out, resample_head_1mm, 'in_file')\n\n    wf.connect(node, out, resample_head_1mm, 'reference')\n\n    # applywarp --rel --interp=spline -i \"$T1wImage\" -r \"$T1wImageFile\"_1mm.nii.gz --premat=$FSLDIR/etc/flirtsch/ident.mat -o \"$T1wImageFile\"_1mm.nii.gz\n    applywarp_head_to_head_1mm = pe.Node(interface=fsl.ApplyWarp(),\n                                         name=f'applywarp_head_to_head_1mm_{pipe_num}')\n    applywarp_head_to_head_1mm.inputs.relwarp = True\n    applywarp_head_to_head_1mm.inputs.interp = 'spline'\n    applywarp_head_to_head_1mm.inputs.premat = cfg.registration_workflows['anatomical_registration']['registration']['FSL-FNIRT']['identity_matrix']\n\n    wf.connect(node, out, applywarp_head_to_head_1mm, 'in_file')\n\n    wf.connect(resample_head_1mm, 'out_file',\n               applywarp_head_to_head_1mm, 'ref_file')\n\n    # applywarp --rel --interp=nn -i \"$T1wImageBrain\" -r \"$T1wImageFile\"_1mm.nii.gz --premat=$FSLDIR/etc/flirtsch/ident.mat -o \"$T1wImageBrainFile\"_1mm.nii.gz\n    applywarp_brain_to_head_1mm = pe.Node(interface=fsl.ApplyWarp(),\n                name=f'applywarp_brain_to_head_1mm_{pipe_num}')\n    applywarp_brain_to_head_1mm.inputs.relwarp = True\n    applywarp_brain_to_head_1mm.inputs.interp = 'nn'\n    applywarp_brain_to_head_1mm.inputs.premat = cfg.registration_workflows['anatomical_registration']['registration']['FSL-FNIRT']['identity_matrix']\n\n    wf.connect(fast_correction, 'outputspec.anat_brain_restore',\n                    applywarp_brain_to_head_1mm, 'in_file')\n\n    wf.connect(resample_head_1mm, 'out_file',\n                    applywarp_brain_to_head_1mm, 'ref_file')\n\n    # fslstats $T1wImageBrain -M\n    average_brain = pe.Node(interface=fsl.ImageStats(),\n                name=f'average_brain_{pipe_num}')\n    average_brain.inputs.op_string = '-M'\n    average_brain.inputs.output_type = 'NIFTI_GZ'\n\n    wf.connect(fast_correction, 'outputspec.anat_brain_restore',\n               average_brain, 'in_file')\n\n    # fslmaths \"$T1wImageFile\"_1mm.nii.gz -div $Mean -mul 150 -abs \"$T1wImageFile\"_1mm.nii.gz\n    normalize_head = pe.Node(util.Function(input_names=['in_file', 'number', 'out_file_suffix'],\n                                           output_names=['out_file'],\n                                           function=fslmaths_command),\n                             name=f'normalize_head_{pipe_num}')\n    normalize_head.inputs.out_file_suffix = '_norm'\n\n    wf.connect(applywarp_head_to_head_1mm, 'out_file', \n               normalize_head, 'in_file')\n\n    wf.connect(average_brain, 'out_stat',\n               normalize_head, 'number')\n\n    outputs = {\n            'desc-restore_T1w': (fast_correction, 'outputspec.anat_restore'),\n            'desc-restore-brain_T1w': (fast_correction,\n                                       'outputspec.anat_brain_restore'),\n            'pipeline-fs_desc-fast_biasfield': (fast_correction, 'outputspec.bias_field'),\n            'desc-ABCDpreproc_T1w': (normalize_head, 'out_file')\n            }\n    return (wf, outputs)"
  },
  {
    "name": "freesurfer_reconall",
    "file": "CPAC/anat_preproc/anat_preproc.py",
    "line_number": 2769,
    "decorator_args": {
      "name": "freesurfer_reconall",
      "config": [
        "surface_analysis",
        "freesurfer"
      ],
      "switch": [
        "run_reconall"
      ],
      "inputs": [
        [
          "desc-ABCDpreproc_T1w",
          "desc-preproc_T1w"
        ]
      ],
      "outputs": [
        "freesurfer-subject-dir",
        "pipeline-fs_raw-average",
        "pipeline-fs_subcortical-seg",
        "pipeline-fs_brainmask",
        "pipeline-fs_wmparc",
        "pipeline-fs_T1",
        "*freesurfer_abcd_preproc.outputs"
      ]
    },
    "docstring": null,
    "source_code": "def freesurfer_reconall(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    reconall = pe.Node(interface=freesurfer.ReconAll(),\n                       name=f'anat_freesurfer_{pipe_num}',\n                       mem_gb=2.7)\n    reconall.skip_timeout = True  # this Node could take > 24 hours\n\n    freesurfer_subject_dir = os.path.join(\n        cfg.pipeline_setup['working_directory']['path'],\n        'cpac_'+cfg['subject_id'],\n        f'anat_preproc_freesurfer_{pipe_num}',\n        'anat_freesurfer')\n\n    if not os.path.exists(freesurfer_subject_dir):\n        os.makedirs(freesurfer_subject_dir)\n\n    reconall.inputs.directive = 'all'\n    reconall.inputs.subjects_dir = freesurfer_subject_dir\n    reconall.inputs.openmp = cfg.pipeline_setup['system_config'][\n        'num_OMP_threads']\n\n    if cfg.surface_analysis['freesurfer']['reconall_args'] is not None:\n        reconall.inputs.args = cfg.surface_analysis['freesurfer'][\n            'reconall_args']\n\n    node, out = strat_pool.get_data([\"desc-ABCDpreproc_T1w\",\"desc-preproc_T1w\"])\n    wf.connect(node, out, reconall, 'T1_files')\n\n    wf, hemisphere_outputs = freesurfer_hemispheres(wf, reconall, pipe_num)\n\n    outputs = {\n        'freesurfer-subject-dir': (reconall, 'subjects_dir'),\n        **hemisphere_outputs,\n        'pipeline-fs_raw-average': (reconall, 'rawavg'),\n        'pipeline-fs_subcortical-seg': (reconall, 'aseg'),\n        'pipeline-fs_brainmask': (reconall, 'brainmask'),\n        'pipeline-fs_wmparc': (reconall, 'wmparc'),\n        'pipeline-fs_T1': (reconall, 'T1')\n    }\n\n    # for label, connection in outputs.items():\n    #     strat_pool.set_data(label, connection[0], connection[1],\n    #                         deepcopy(strat_pool.get('json')),\n    #                         pipe_num, 'freesurfer_reconall', fork=False)\n    # Run postproc if we ran reconall\n    # wf, post_outputs = freesurfer_postproc(wf, cfg, strat_pool, pipe_num, opt)\n    # Update the outputs to include the postproc outputs\n    # outputs.update(post_outputs)\n\n    return wf, outputs"
  },
  {
    "name": "correct_restore_brain_intensity_abcd",
    "file": "CPAC/anat_preproc/anat_preproc.py",
    "line_number": 3045,
    "decorator_args": {
      "name": "correct_restore_brain_intensity_abcd",
      "config": [
        "anatomical_preproc",
        "brain_extraction"
      ],
      "option_key": "using",
      "option_val": "FreeSurfer-ABCD",
      "inputs": [
        [
          "desc-preproc_T1w",
          "desc-n4_T1w",
          "space-T1w_desc-brain_mask",
          "pipeline-fs_desc-fast_biasfield",
          "from-T1w_to-ACPC_mode-image_desc-aff2rig_xfm",
          "from-T1w_to-template_mode-image_xfm",
          "desc-restore-brain_T1w"
        ]
      ],
      "outputs": [
        "desc-restore-brain_T1w"
      ]
    },
    "docstring": null,
    "source_code": "def correct_restore_brain_intensity_abcd(wf, cfg, strat_pool, pipe_num,\n                                         opt=None):\n\n    ### ABCD Harmonization - Myelin Map ###\n    # Ref: https://github.com/DCAN-Labs/DCAN-HCP/blob/master/PreFreeSurfer/PreFreeSurferPipeline.sh#L655-L656\n    # fslmerge -t ${T1wFolder}/xfms/${T1wImage}_dc ${T1wFolder}/${T1wImage}_acpc ${T1wFolder}/${T1wImage}_acpc ${T1wFolder}/${T1wImage}_acpc\n    merge_t1_acpc_to_list = pe.Node(util.Merge(3),\n                                    name=f'merge_t1_acpc_to_list_{pipe_num}')\n\n    node, out = strat_pool.get_data('desc-preproc_T1w')\n    wf.connect(node, out, merge_t1_acpc_to_list, 'in1')\n    wf.connect(node, out, merge_t1_acpc_to_list, 'in2')\n    wf.connect(node, out, merge_t1_acpc_to_list, 'in3')\n\n    merge_t1_acpc = pe.Node(interface=fslMerge(),\n                            name=f'merge_t1_acpc_{pipe_num}')\n\n    merge_t1_acpc.inputs.dimension = 't'\n\n    wf.connect(merge_t1_acpc_to_list, 'out',\n        merge_t1_acpc, 'in_files')\n\n    # fslmaths ${T1wFolder}/xfms/${T1wImage}_dc -mul 0 ${T1wFolder}/xfms/${T1wImage}_dc\n    multiply_t1_acpc_by_zero = pe.Node(interface=fsl.ImageMaths(),\n                                       name=f'multiply_t1_acpc_by_zero_{pipe_num}')\n    \n    multiply_t1_acpc_by_zero.inputs.op_string = '-mul 0'\n\n    wf.connect(merge_t1_acpc, 'merged_file', \n        multiply_t1_acpc_by_zero, 'in_file')\n\n    # Ref: https://github.com/DCAN-Labs/DCAN-HCP/blob/master/PostFreeSurfer/PostFreeSurferPipeline.sh#L157\n    # convertwarp --relout --rel --ref=\"$T1wFolder\"/\"$T1wImageBrainMask\" --premat=\"$T1wFolder\"/xfms/\"$InitialT1wTransform\" \\\n    # --warp1=\"$T1wFolder\"/xfms/\"$dcT1wTransform\" --out=\"$T1wFolder\"/xfms/\"$OutputOrigT1wToT1w\"\n    convertwarp_orig_t1_to_t1 = pe.Node(interface=fsl.ConvertWarp(), \n                                        name=f'convertwarp_orig_t1_to_t1_{pipe_num}')\n\n    convertwarp_orig_t1_to_t1.inputs.out_relwarp = True\n    convertwarp_orig_t1_to_t1.inputs.relwarp = True\n    \n    node, out = strat_pool.get_data(\"space-T1w_desc-brain_mask\")\n    wf.connect(node, out, convertwarp_orig_t1_to_t1, 'reference')\n\n    node, out = strat_pool.get_data('from-T1w_to-ACPC_mode-image_desc-aff2rig_xfm')\n    wf.connect(node, out, convertwarp_orig_t1_to_t1, 'premat')\n    wf.connect(multiply_t1_acpc_by_zero, 'out_file',\n        convertwarp_orig_t1_to_t1, 'warp1')\n\n    # Ref: https://github.com/DCAN-Labs/DCAN-HCP/blob/master/PostFreeSurfer/scripts/CreateMyelinMaps.sh#L72-L73\n    # applywarp --rel --interp=spline -i \"$BiasField\" -r \"$T1wImageBrain\" -w \"$AtlasTransform\" -o \"$BiasFieldOutput\"\n    applywarp_biasfield = pe.Node(interface=fsl.ApplyWarp(), \n                                  name=f'applywarp_biasfield_{pipe_num}')\n\n    applywarp_biasfield.inputs.relwarp = True\n    applywarp_biasfield.inputs.interp = 'spline'\n\n    node, out = strat_pool.get_data('pipeline-fs_desc-fast_biasfield')\n    wf.connect(node, out, applywarp_biasfield, 'in_file')\n\n    node, out = strat_pool.get_data(\"space-T1w_desc-brain_mask\")\n    wf.connect(node, out, applywarp_biasfield, 'ref_file')\n\n    node, out = strat_pool.get_data('from-T1w_to-template_mode-image_xfm')\n    wf.connect(node, out, applywarp_biasfield, 'field_file')\n\n    # fslmaths \"$BiasFieldOutput\" -thr 0.1 \"$BiasFieldOutput\"\n    threshold_biasfield = pe.Node(interface=fsl.ImageMaths(),\n                                  name=f'threshold_biasfield_{pipe_num}')\n\n    threshold_biasfield.inputs.op_string = '-thr 0.1'\n    wf.connect(applywarp_biasfield, 'out_file', \n        threshold_biasfield, 'in_file')\n\n    # Ref: https://github.com/DCAN-Labs/DCAN-HCP/blob/master/PostFreeSurfer/scripts/CreateMyelinMaps.sh#L67-L70\n    # applywarp --rel --interp=spline -i \"$OrginalT1wImage\" -r \"$T1wImageBrain\" -w \"$OutputOrigT1wToT1w\" -o \"$OutputT1wImage\"\n    applywarp_t1 = pe.Node(interface=fsl.ApplyWarp(), \n                           name=f'applywarp_t1_{pipe_num}')\n    \n    applywarp_t1.inputs.relwarp = True\n    applywarp_t1.inputs.interp = 'spline'\n    \n    node, out = strat_pool.get_data('desc-n4_T1w')\n    wf.connect(node, out, applywarp_t1, 'in_file')\n    \n    node, out = strat_pool.get_data(\"space-T1w_desc-brain_mask\")\n    wf.connect(node, out, applywarp_t1, 'ref_file')\n    \n    wf.connect(convertwarp_orig_t1_to_t1, 'out_file',\n        applywarp_t1, 'field_file')\n\n    # fslmaths \"$OutputT1wImage\" -abs \"$OutputT1wImage\" -odt float\n    abs_t1 = pe.Node(interface=fsl.ImageMaths(),\n                     name=f'abs_t1_{pipe_num}')\n\n    abs_t1.inputs.op_string = '-abs'\n    wf.connect(applywarp_t1, 'out_file', abs_t1, 'in_file')\n\n    # fslmaths \"$OutputT1wImage\" -div \"$BiasField\" \"$OutputT1wImageRestore\"\n    div_t1_by_biasfield = pe.Node(interface=fsl.ImageMaths(),\n                                  name=f'div_t1_by_biasfield_{pipe_num}')\n\n    div_t1_by_biasfield.inputs.op_string = '-div'\n\n    wf.connect(abs_t1, 'out_file', div_t1_by_biasfield, 'in_file')\n\n    node, out = strat_pool.get_data('pipeline-fs_desc-fast_biasfield')\n    wf.connect(node, out, div_t1_by_biasfield, 'in_file2')\n\n    # fslmaths \"$OutputT1wImageRestore\" -mas \"$T1wImageBrain\" \"$OutputT1wImageRestoreBrain\"\n    apply_mask = pe.Node(interface=fsl.maths.ApplyMask(),\n                         name=f'get_restored_corrected_brain_{pipe_num}')\n\n    wf.connect(div_t1_by_biasfield, 'out_file',\n        apply_mask, 'in_file')\n\n    node, out = strat_pool.get_data(\"space-T1w_desc-brain_mask\")\n    wf.connect(node, out, apply_mask, 'mask_file')\n\n    outputs = {\n        'desc-restore-brain_T1w': (apply_mask, 'out_file')\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "distcor_phasediff_fsl_fugue",
    "file": "CPAC/distortion_correction/distortion_correction.py",
    "line_number": 72,
    "decorator_args": {
      "name": "distcor_phasediff_fsl_fugue",
      "config": [
        "functional_preproc",
        "distortion_correction"
      ],
      "switch": [
        "run"
      ],
      "option_key": "using",
      "option_val": "PhaseDiff",
      "inputs": [
        "phasediff",
        "phase1",
        "phase2",
        "magnitude",
        "magnitude1",
        "magnitude2",
        "deltaTE",
        "effectiveEchoSpacing",
        "ees-asym-ratio"
      ],
      "outputs": [
        "despiked-fieldmap",
        "fieldmap-mask"
      ]
    },
    "docstring": "Fieldmap correction takes in an input magnitude image which is\nSkull Stripped (Tight).\nThe magnitude images are obtained from each echo series. It also\nrequires a phase image\nas an input, the phase image is a subtraction of the two phase\nimages from each echo.\n\nCreated on Thu Nov  9 10:44:47 2017\n@author: nrajamani\n\nOrder of commands and inputs:\n\n-- SkullStrip:   3d-SkullStrip (or FSL-BET) is used to strip the\n                 non-brain (tissue) regions from the fMRI\n                 Parameters: -f, default: 0.5\n                 in_file: fmap_mag\n-- fslmath_mag:  Magnitude image is eroded using the -ero option in\n                 fslmath, in order to remove the non-zero voxels\n                 Parameters: -ero\n                 in_file:fmap_mag\n-- bet_anat:     Brain extraction of the anat file to provide as an\n                 input for the epi-registration interface\n                 Parameters: -f, default: 0.5\n                 in_file: anat_file\n-- fast_anat:    Fast segmentation to provide partial volume files\n                 of the anat file, which is further processed to\n                 provide the white mater segmentation input for the\n                 epi-registration interface.\n                 The most important output required from this is\n                 the second segment, (e.g.,'T1_brain_pve_2.nii.gz')\n                 Parameters: -img_type = 1\n                             -bias_iters = 10 (-I)\n                             -bias_lowpass = 10 (-l)\n                 in_file: brain_extracted anat_file\n-- fslmath_anat: The output of the FAST interface is then analyzed\n                 to select all the voxels with more than 50%\n                 partial volume into the binary mask\n                 Parameters: -thr = 0.5\n                 in_file : T1_brain_pve_2\n-- fslmath_wmseg:The selected voxels are now used to create a\n                 binary mask which would can then be sent as the\n                 white matter segmentation (wm_seg)\n                 Parameters: -bin\n                 in_file: T1_brain_pve_2\n-- Prepare:      Preparing the fieldmap.\n                 Parameters: -deltaTE = default, 2.46 ms\n                             -Scanner = SIEMENS\n                 in_files: fmap_phase\n                           fmap_magnitude\n                 For more details, check:\n                 https://fsl.fmrib.ox.ac.uk/fsl/fslwiki/FUGUE/Guide\n-- FUGUE:        One of the steps in EPI-DistCorrection toolbox, it\n                 unwarps the fieldmaps\n                 Parameters: dwell_to_asymm ratio =                                      (0.77e-3 * 3)/(2.46e-3)\n                             dwell time = 0.0005 ms\n                             in_file = field map which is a 4D\n                                       image (containing 2\n                                       unwarped image)",
    "source_code": "def distcor_phasediff_fsl_fugue(wf, cfg, strat_pool, pipe_num, opt=None):\n    '''\n    Fieldmap correction takes in an input magnitude image which is\n    Skull Stripped (Tight).\n    The magnitude images are obtained from each echo series. It also\n    requires a phase image\n    as an input, the phase image is a subtraction of the two phase\n    images from each echo.\n\n    Created on Thu Nov  9 10:44:47 2017\n    @author: nrajamani\n\n    Order of commands and inputs:\n\n    -- SkullStrip:   3d-SkullStrip (or FSL-BET) is used to strip the\n                     non-brain (tissue) regions from the fMRI\n                     Parameters: -f, default: 0.5\n                     in_file: fmap_mag\n    -- fslmath_mag:  Magnitude image is eroded using the -ero option in\n                     fslmath, in order to remove the non-zero voxels\n                     Parameters: -ero\n                     in_file:fmap_mag\n    -- bet_anat:     Brain extraction of the anat file to provide as an\n                     input for the epi-registration interface\n                     Parameters: -f, default: 0.5\n                     in_file: anat_file\n    -- fast_anat:    Fast segmentation to provide partial volume files\n                     of the anat file, which is further processed to\n                     provide the white mater segmentation input for the\n                     epi-registration interface.\n                     The most important output required from this is\n                     the second segment, (e.g.,'T1_brain_pve_2.nii.gz')\n                     Parameters: -img_type = 1\n                                 -bias_iters = 10 (-I)\n                                 -bias_lowpass = 10 (-l)\n                     in_file: brain_extracted anat_file\n    -- fslmath_anat: The output of the FAST interface is then analyzed\n                     to select all the voxels with more than 50%\n                     partial volume into the binary mask\n                     Parameters: -thr = 0.5\n                     in_file : T1_brain_pve_2\n    -- fslmath_wmseg:The selected voxels are now used to create a\n                     binary mask which would can then be sent as the\n                     white matter segmentation (wm_seg)\n                     Parameters: -bin\n                     in_file: T1_brain_pve_2\n    -- Prepare:      Preparing the fieldmap.\n                     Parameters: -deltaTE = default, 2.46 ms\n                                 -Scanner = SIEMENS\n                     in_files: fmap_phase\n                               fmap_magnitude\n                     For more details, check:\n                     https://fsl.fmrib.ox.ac.uk/fsl/fslwiki/FUGUE/Guide\n    -- FUGUE:        One of the steps in EPI-DistCorrection toolbox, it\n                     unwarps the fieldmaps\n                     Parameters: dwell_to_asymm ratio = \\\n                                     (0.77e-3 * 3)/(2.46e-3)\n                                 dwell time = 0.0005 ms\n                                 in_file = field map which is a 4D\n                                           image (containing 2\n                                           unwarped image)\n    '''\n\n    # Skull-strip, outputs a masked image file\n    if cfg.functional_preproc['distortion_correction']['PhaseDiff'][\n            'fmap_skullstrip_option'] == 'AFNI':\n\n        skullstrip_args = pe.Node(util.Function(input_names=['shrink_fac'],\n                                                output_names=['expr'],\n                                                function=create_afni_arg),\n                                  name=f'distcorr_skullstrip_arg_{pipe_num}')\n        skullstrip_args.inputs.shrink_fac = cfg.functional_preproc[\n            'distortion_correction']['PhaseDiff'][\n            'fmap_skullstrip_AFNI_threshold']\n\n        afni = pe.Node(interface=afni.SkullStrip(), name=f'distcor_phasediff_'\n                                                         f'afni_skullstrip_'\n                                                         f'{pipe_num}')\n        afni.inputs.outputtype = 'NIFTI_GZ'\n        wf.connect(skullstrip_args, 'expr', afni, 'args')\n\n        if strat_pool.check_rpool('magnitude'):\n            node, out = strat_pool.get_data('magnitude')\n        elif strat_pool.check_rpool('magnitude1'):\n            node, out = strat_pool.get_data('magnitude1')\n\n        wf.connect(node, out, afni, 'in_file')\n\n        brain_node, brain_out = (afni, 'out_file')\n\n    elif cfg.functional_preproc['distortion_correction']['PhaseDiff'][\n            'fmap_skullstrip_option'] == 'BET':\n\n        bet = pe.Node(interface=fsl.BET(), name='distcor_phasediff_bet_'\n                                                f'skullstrip_{pipe_num}')\n        bet.inputs.output_type = 'NIFTI_GZ'\n        bet.inputs.frac = cfg.functional_preproc['distortion_correction'][\n            'PhaseDiff']['fmap_skullstrip_BET_frac']\n\n        if strat_pool.check_rpool('magnitude'):\n            node, out = strat_pool.get_data('magnitude')\n        elif strat_pool.check_rpool('magnitude1'):\n            node, out = strat_pool.get_data('magnitude1')\n        wf.connect(node, out, bet, 'in_file')\n\n        brain_node, brain_out = (bet, 'out_file')\n\n    # Prepare Fieldmap\n\n    # prepare the field map\n    prepare = pe.Node(interface=fsl.epi.PrepareFieldmap(), name='prepare')\n    prepare.inputs.output_type = \"NIFTI_GZ\"\n\n    node, out = strat_pool.get_data('deltaTE')\n    wf.connect(node, out, prepare, 'delta_TE')\n\n    if strat_pool.check_rpool('phase1') and strat_pool.check_rpool('phase2'):\n        fslmaths_sub = pe.Node(interface=fsl.BinaryMaths(), \n                               name='fugue_phase_subtraction')\n        fslmaths_sub.inputs.operation = 'sub'\n\n        node, out = strat_pool.get_data('phase1')\n        wf.connect(node, out, fslmaths_sub, 'in_file')\n    \n        node, out = strat_pool.get_data('phase2')\n        wf.connect(node, out, fslmaths_sub, 'operand_file')\n\n        node, out = (fslmaths_sub, 'out_file')\n\n    elif strat_pool.check_rpool('phasediff'):\n        node, out = strat_pool.get_data('phasediff')\n    \n    wf.connect(node, out, prepare, 'in_phase')\n    wf.connect(brain_node, brain_out, prepare, 'in_magnitude')\n\n    # erode the masked magnitude image\n    fslmath_mag = pe.Node(interface=fsl.ErodeImage(), name='fslmath_mag')\n    wf.connect(brain_node, brain_out, fslmath_mag, 'in_file')\n\n    # calculate the absolute value of the eroded and masked magnitude\n    # image\n    fslmath_abs = pe.Node(interface=fsl.UnaryMaths(), name='fslmath_abs')\n    fslmath_abs.inputs.operation = 'abs'\n    wf.connect(fslmath_mag, 'out_file', fslmath_abs, 'in_file')\n\n    # binarize the absolute value of the eroded and masked magnitude\n    # image\n    fslmath_bin = pe.Node(interface=fsl.UnaryMaths(), name='fslmath_bin')\n    fslmath_bin.inputs.operation = 'bin'\n    wf.connect(fslmath_abs, 'out_file', fslmath_bin, 'in_file')\n\n    # take the absolute value of the fieldmap calculated in the prepare step\n    fslmath_mask_1 = pe.Node(interface=fsl.UnaryMaths(),\n                             name='fslmath_mask_1')\n    fslmath_mask_1.inputs.operation = 'abs'\n    wf.connect(prepare, 'out_fieldmap', fslmath_mask_1, 'in_file')\n\n    # binarize the absolute value of the fieldmap calculated in the\n    # prepare step\n    fslmath_mask_2 = pe.Node(interface=fsl.UnaryMaths(),\n                             name='fslmath_mask_2')\n    fslmath_mask_2.inputs.operation = 'bin'\n    wf.connect(fslmath_mask_1, 'out_file', fslmath_mask_2, 'in_file')\n\n    # multiply together the binarized magnitude and fieldmap images\n    fslmath_mask = pe.Node(interface=fsl.BinaryMaths(),\n                           name='fslmath_mask')\n    fslmath_mask.inputs.operation = 'mul'\n    wf.connect(fslmath_mask_2, 'out_file', fslmath_mask, 'in_file')\n    wf.connect(fslmath_bin, 'out_file', fslmath_mask, 'operand_file')\n\n    # Note for the user. Ensure the phase image is within 0-4096 (upper\n    # threshold is 90% of 4096), fsl_prepare_fieldmap will only work in the\n    # case of the SIEMENS format. #Maybe we could use deltaTE also as an\n    # option in the GUI.\n\n    # fugue\n    fugue1 = pe.Node(interface=fsl.FUGUE(), name='fsl_fugue')\n    fugue1.inputs.save_fmap = True\n    fugue1.outputs.fmap_out_file = 'fmap_rads'\n\n    wf.connect(fslmath_mask, 'out_file', fugue1, 'mask_file')\n\n    # FSL calls EffectiveEchoSpacing \"dwell_time\"\n    node, out = strat_pool.get_data('effectiveEchoSpacing')\n    wf.connect(node, out, fugue1, 'dwell_time')\n    node, out = strat_pool.get_data('ees-asym-ratio')\n    wf.connect(node, out, fugue1, 'dwell_to_asym_ratio')\n\n    wf.connect(prepare, 'out_fieldmap', fugue1, 'fmap_in_file')\n\n    outputs = {\n        'despiked-fieldmap': (fugue1, 'fmap_out_file'),\n        'fieldmap-mask': (fslmath_mask, 'out_file')\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "distcor_blip_afni_qwarp",
    "file": "CPAC/distortion_correction/distortion_correction.py",
    "line_number": 360,
    "decorator_args": {
      "name": "distcor_blip_afni_qwarp",
      "config": [
        "functional_preproc",
        "distortion_correction"
      ],
      "switch": [
        "run"
      ],
      "option_key": "using",
      "option_val": "Blip",
      "inputs": [
        [
          "sbref",
          "space-bold_desc-brain_mask"
        ],
        "epi-1",
        "epi-1-scan-params",
        "epi-2",
        "epi-2-scan-params",
        "pe-direction"
      ],
      "outputs": [
        "sbref",
        "space-bold_desc-brain_mask",
        "ants-blip-warp"
      ]
    },
    "docstring": "Execute AFNI 3dQWarp to calculate the distortion \"unwarp\" for\nphase encoding direction EPI field map distortion correction.\n\n    1. Skull-strip the opposite-direction phase encoding EPI.\n    2. Transform the opposite-direction phase encoding EPI to the\n       skull-stripped functional and pass this as the base_file to\n       AFNI 3dQWarp (plus-minus).\n    3. If there is a same-direction phase encoding EPI, also\n       skull-strip this, and transform it to the skull-stripped\n       functional. Then, pass this as the in_file to AFNI 3dQWarp\n       (plus-minus).\n    4. If there isn't a same-direction, pass the functional in as\n       the in_file of AFNI 3dQWarp (plus-minus).\n    5. Convert the 3dQWarp transforms to ANTs/ITK format.\n    6. Use antsApplyTransforms, with the original functional as\n       both the input and the reference, and apply the warp from\n       3dQWarp. The output of this can then proceed to\n       func_preproc.",
    "source_code": "def distcor_blip_afni_qwarp(wf, cfg, strat_pool, pipe_num, opt=None):\n    '''Execute AFNI 3dQWarp to calculate the distortion \"unwarp\" for\n    phase encoding direction EPI field map distortion correction.\n\n        1. Skull-strip the opposite-direction phase encoding EPI.\n        2. Transform the opposite-direction phase encoding EPI to the\n           skull-stripped functional and pass this as the base_file to\n           AFNI 3dQWarp (plus-minus).\n        3. If there is a same-direction phase encoding EPI, also\n           skull-strip this, and transform it to the skull-stripped\n           functional. Then, pass this as the in_file to AFNI 3dQWarp\n           (plus-minus).\n        4. If there isn't a same-direction, pass the functional in as\n           the in_file of AFNI 3dQWarp (plus-minus).\n        5. Convert the 3dQWarp transforms to ANTs/ITK format.\n        6. Use antsApplyTransforms, with the original functional as\n           both the input and the reference, and apply the warp from\n           3dQWarp. The output of this can then proceed to\n           func_preproc.\n    '''\n\n    match_epi_imports = ['import json']\n    match_epi_fmaps_node = \\\n        pe.Node(Function(input_names=['bold_pedir',\n                                      'epi_fmap_one',\n                                      'epi_fmap_params_one',\n                                      'epi_fmap_two',\n                                      'epi_fmap_params_two'],\n                         output_names=['opposite_pe_epi',\n                                       'same_pe_epi'],\n                         function=match_epi_fmaps,\n                         imports=match_epi_imports,\n                         as_module=True),\n                name=f'match_epi_fmaps_{pipe_num}')\n\n    node, out = strat_pool.get_data('epi-1')\n    wf.connect(node, out, match_epi_fmaps_node, 'epi_fmap_one')\n\n    node, out = strat_pool.get_data('epi-1-scan-params')\n    wf.connect(node, out, match_epi_fmaps_node, 'epi_fmap_params_one')\n\n    if strat_pool.check_rpool('epi-2'):\n        node, out = strat_pool.get_data('epi-2')\n        wf.connect(node, out, match_epi_fmaps_node, 'epi_fmap_two')\n\n        node, out = strat_pool.get_data('epi-2-scan-params')\n        wf.connect(node, out, match_epi_fmaps_node, 'epi_fmap_params_two')\n\n    node, out = strat_pool.get_data('pe-direction')\n    wf.connect(node, out, match_epi_fmaps_node, 'bold_pedir')\n\n    #interface = {'bold': (match_epi_fmaps_node, 'opposite_pe_epi'),\n    #             'desc-brain_bold': 'opposite_pe_epi_brain'}\n    #wf, strat_pool = wrap_block([bold_mask_afni, bold_masking],\n    #                            interface, wf, cfg, strat_pool, pipe_num, opt)\n\n    func_get_brain_mask = pe.Node(interface=preprocess.Automask(),\n                                  name=f'afni_mask_opposite_pe_{pipe_num}')\n    func_get_brain_mask.inputs.outputtype = 'NIFTI_GZ'\n\n    wf.connect(match_epi_fmaps_node, 'opposite_pe_epi', func_get_brain_mask, 'in_file')\n\n    func_edge_detect = pe.Node(interface=afni_utils.Calc(),\n                               name=f'skullstrip_opposite_pe_{pipe_num}')\n\n    func_edge_detect.inputs.expr = 'a*b'\n    func_edge_detect.inputs.outputtype = 'NIFTI_GZ'\n \n    wf.connect(match_epi_fmaps_node, 'opposite_pe_epi', func_edge_detect, 'in_file_a')\n    wf.connect(func_get_brain_mask, 'out_file', func_edge_detect, 'in_file_b')\n\n    opp_pe_to_func = pe.Node(interface=fsl.FLIRT(), name='opp_pe_to_func')\n    opp_pe_to_func.inputs.cost = 'corratio'\n \n    wf.connect(func_edge_detect, 'out_file',  opp_pe_to_func, 'in_file')\n\n    node, out = strat_pool.get_data('sbref')\n    wf.connect(node, out, opp_pe_to_func, 'reference')\n\n    prep_qwarp_input_imports = ['import os', 'import subprocess']\n    prep_qwarp_input = \\\n        pe.Node(function.Function(input_names=['same_pe_epi',\n                                               'func_mean'],\n                                  output_names=['qwarp_input'],\n                                  function=same_pe_direction_prep,\n                                  imports=prep_qwarp_input_imports),\n                name='prep_qwarp_input')\n\n    wf.connect(match_epi_fmaps_node, 'same_pe_epi',\n               prep_qwarp_input, 'same_pe_epi')\n\n    node, out = strat_pool.get_data('sbref')\n    wf.connect(node, out, prep_qwarp_input, 'func_mean')\n\n    calculate_blip_warp_imports = ['import os', 'import subprocess']\n    calc_blip_warp = pe.Node(function.Function(\n        input_names=['opp_pe', 'same_pe'],\n        output_names=['out_warp'],\n        function=calculate_blip_warp,\n        imports=calculate_blip_warp_imports),\n                             name='calc_blip_warp')\n\n    wf.connect(opp_pe_to_func, 'out_file', calc_blip_warp, 'opp_pe')\n    wf.connect(prep_qwarp_input, 'qwarp_input', calc_blip_warp, 'same_pe')\n\n    convert_afni_warp_imports = ['import os', 'import nibabel as nb']\n    convert_afni_warp = \\\n        pe.Node(function.Function(input_names=['afni_warp'],\n                                  output_names=['ants_warp'],\n                                  function=convert_afni_to_ants,\n                                  imports=convert_afni_warp_imports),\n                name='convert_afni_warp')\n\n    wf.connect(calc_blip_warp, 'out_warp', convert_afni_warp, 'afni_warp')\n\n    # TODO: inverse source_warp (node:source_warp_inverse)\n    #       wf.connect(###\n    #                  output_node, 'blip_warp_inverse')\n\n    undistort_func_mean = pe.Node(interface=ants.ApplyTransforms(),\n                                  name='undistort_func_mean', mem_gb=.1)\n\n    undistort_func_mean.inputs.out_postfix = '_antswarp'\n    undistort_func_mean.interface.num_threads = 1\n    undistort_func_mean.inputs.interpolation = \"LanczosWindowedSinc\"\n    undistort_func_mean.inputs.dimension = 3\n    undistort_func_mean.inputs.input_image_type = 0\n\n    node, out = strat_pool.get_data('sbref')\n    wf.connect(node, out, undistort_func_mean, 'input_image')\n    wf.connect(node, out, undistort_func_mean, 'reference_image')\n    wf.connect(convert_afni_warp, 'ants_warp',\n               undistort_func_mean, 'transforms')\n\n    #interface = {'desc-preproc_bold': (undistort_func_mean, 'output_image')}\n    #wf, strat_pool = wrap_block([bold_mask_afni],\n    #                            interface, wf, cfg, strat_pool, pipe_num, opt)\n\n    remask = pe.Node(interface=preprocess.Automask(),\n                     name=f'afni_remask_boldmask_{pipe_num}')\n    remask.inputs.outputtype = 'NIFTI_GZ'\n\n    wf.connect(undistort_func_mean, 'output_image', remask, 'in_file')\n\n    outputs = {\n        'ants-blip-warp': (convert_afni_warp, 'ants_warp'),\n        #'inv-blip-warp': None,  # TODO\n        'sbref': (undistort_func_mean, 'output_image'),\n        'space-bold_desc-brain_mask': (remask, 'out_file')\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "distcor_blip_fsl_topup",
    "file": "CPAC/distortion_correction/distortion_correction.py",
    "line_number": 536,
    "decorator_args": {
      "name": "distcor_blip_fsl_topup",
      "config": [
        "functional_preproc",
        "distortion_correction"
      ],
      "switch": [
        "run"
      ],
      "option_key": "using",
      "option_val": "Blip-FSL-TOPUP",
      "inputs": [
        [
          "sbref",
          "space-bold_desc-brain_mask"
        ],
        "pe-direction",
        "epi-1",
        "epi-1-pedir",
        "epi-1-TE",
        "epi-1-dwell",
        "epi-1-total-readout",
        "epi-2",
        "epi-2-pedir",
        "epi-2-TE",
        "epi-2-dwell",
        "epi-2-total-readout"
      ],
      "outputs": [
        "sbref",
        "space-bold_desc-brain_mask",
        "fsl-blip-warp"
      ]
    },
    "docstring": "Execute FSL TOPUP to calculate the distortion \"unwarp\" for\nphase encoding direction EPI field map distortion correction.",
    "source_code": "def distcor_blip_fsl_topup(wf, cfg, strat_pool, pipe_num, opt=None):\n    '''Execute FSL TOPUP to calculate the distortion \"unwarp\" for\n    phase encoding direction EPI field map distortion correction.\n    '''\n\n    # TODO: re-integrate gradient distortion coefficient usage at a later date\n    '''\n    GradientDistortionCoeffs = None\n    if GradientDistortionCoeffs != None:\n        grad_outs = []\n        gdc_phase_outs = []\n        for idx, phase_img in enumerate(phase_imgs):\n            wf, out_warpmask, out_applywarp = gradient_distortion_correction(\n                wf, phase_img, f\"phase-{idx}\"\n            )\n            grad_outs.append(out_warpmask)\n            gdc_phase_outs.append(out_applywarp)\n            phaseone_gdc = gdc_phase_outs[0][1]\n            phasetwo_gdc = gdc_phase_outs[1][1]\n\n        # Make a conservative (eroded) intersection of the two masks\n        Mask = pe.Node(interface=fsl.maths.ApplyMask(), name=\"Mask\")\n        Mask.inputs.args = \"-bin -ero\"\n\n        wf.connect(grad_outs[0][0], grad_outs[0][1], Mask, \"in_file\")\n        wf.connect(grad_outs[1][0], grad_outs[1][1], Mask, \"mask_file\")\n\n        # Merge both sets of images\n        create_list = pe.Node(interface=util.Merge(2), name=\"create_list\")\n\n        wf.connect(gdc_phase_outs[0][0], gdc_phase_outs[0][1], create_list, \"in1\")\n        wf.connect(gdc_phase_outs[1][0], gdc_phase_outs[1][1], create_list, \"in2\")\n\n        merge_image = pe.Node(interface=fsl.Merge(), name=\"merge_image\")\n        merge_image.inputs.dimension = \"t\"\n        merge_image.inputs.output_type = \"NIFTI_GZ\"\n\n        wf.connect(create_list, \"out\", merge_image, \"in_files\")\n\n    else:\n    '''\n\n    create_list = pe.Node(interface=util.Merge(2), name=\"create_list\")\n\n    node, out = strat_pool.get_data('epi-1')\n    wf.connect(node, out, create_list, 'in1')\n\n    node, out = strat_pool.get_data('epi-2')\n    wf.connect(node, out, create_list, 'in2')\n\n    merge_image = pe.Node(interface=fsl.Merge(), name=\"merge_image\")\n    merge_image.inputs.dimension = \"t\"\n    merge_image.inputs.output_type = \"NIFTI_GZ\"\n\n    wf.connect(create_list, \"out\", merge_image, \"in_files\")\n\n    Mask = pe.Node(interface=fsl.maths.BinaryMaths(), name=\"Mask\")\n    Mask.inputs.operand_value = 0\n    Mask.inputs.operation = \"mul\"\n    Mask.inputs.args = \"-add 1\"\n\n    node, out = strat_pool.get_data('epi-1')\n    wf.connect(node, out, Mask, 'in_file')\n\n    # zpad_phases = z_pad(\"zpad_phases\")\n    # wf.connect(merge_image, \"merged_file\", zpad_phases, \"inputspec.input_image\")\n\n    # zpad_mask = z_pad(\"zpad_mask\")\n    # wf.connect(Mask, \"out_file\", zpad_mask, \"inputspec.input_image\")\n\n    # extrapolate existing values beyond the mask\n    extrap_vals = pe.Node(interface=fsl.maths.BinaryMaths(),\n                          name=\"extrap_vals\")\n    extrap_vals.inputs.operation = \"add\"\n    extrap_vals.inputs.operand_value = 1\n    extrap_vals.inputs.args = \"-abs -dilM -dilM -dilM -dilM -dilM\"\n\n    # wf.connect(zpad_phases, \"outputspec.output_image\",\n    #            extrap_vals,  \"in_file\")\n    # wf.connect(zpad_mask, \"outputspec.output_image\",\n    #            extrap_vals, \"operand_file\")\n\n    wf.connect(merge_image, \"merged_file\", extrap_vals, \"in_file\")\n    wf.connect(Mask, \"out_file\", extrap_vals, \"operand_file\")\n\n    # phase encoding\n    phase_encode_imports = [\n        \"import os\",\n        \"import subprocess\",\n        \"import numpy as np\",\n        \"import nibabel\",\n        \"import sys\"\n    ]\n    phase_encoding = pe.Node(\n        util.Function(\n            input_names=[\n                \"unwarp_dir\",\n                \"phase_one\",\n                \"phase_two\",\n                \"dwell_time_one\",\n                \"dwell_time_two\",\n                \"ro_time_one\",\n                \"ro_time_two\"\n            ],\n            output_names=[\"acq_params\"],\n            function=phase_encode,\n            imports=phase_encode_imports,\n        ),\n        name=\"phase_encoding\",\n    )\n    node, out = strat_pool.get_data('epi-1')\n    wf.connect(node, out, phase_encoding, 'phase_one')\n\n    node, out = strat_pool.get_data('epi-2')\n    wf.connect(node, out, phase_encoding, 'phase_two')\n\n    node, out = strat_pool.get_data('pe-direction')\n    wf.connect(node, out, phase_encoding, 'unwarp_dir')\n    \n    if strat_pool.check_rpool('epi-1-dwell') and \\\n            strat_pool.check_rpool('epi-2-dwell'):\n\n        node, out = strat_pool.get_data('epi-1-dwell')\n        wf.connect(node, out, phase_encoding, 'dwell_time_one')\n\n        node, out = strat_pool.get_data('epi-2-dwell')\n        wf.connect(node, out, phase_encoding, 'dwell_time_two')\n\n    if strat_pool.check_rpool('epi-1-total-readout') and \\\n            strat_pool.check_rpool('epi-2-total-readout'):\n\n        node, out = strat_pool.get_data('epi-1-total-readout')\n        wf.connect(node, out, phase_encoding, 'ro_time_one')\n    \n        node, out = strat_pool.get_data('epi-2-total-readout')\n        wf.connect(node, out, phase_encoding, 'ro_time_two')\n\n    topup_imports = [\"import os\",\n                     \"import subprocess\"]\n    run_topup = pe.Node(util.Function(input_names=[\"merged_file\", \n                                                   \"acqparams\"],\n                                      output_names=[\"out_fieldcoef\", \n                                                    \"out_movpar\",\n                                                    \"corrected_outfile\",\n                                                    \"field_out\",\n                                                    \"out_jacs\",\n                                                    \"log_out\",\n                                                    \"out_xfms\",\n                                                    \"out_warps\"],\n                                      function=run_fsl_topup,\n                                      imports=topup_imports),\n                        name=\"topup\")\n\n    wf.connect(extrap_vals, \"out_file\", run_topup, \"merged_file\")\n    wf.connect(phase_encoding, \"acq_params\", run_topup, \"acqparams\")\n\n    choose_phase = pe.Node(\n        util.Function(\n            input_names=[\"phase_imgs\",\n                         \"unwarp_dir\"],\n            output_names=[\"out_phase_image\",\n                          \"vnum\"],\n            function=choose_phase_image\n        ), name=\"choose_phase\",\n    )\n\n    wf.connect(create_list, 'out', choose_phase, 'phase_imgs')\n\n    node, out = strat_pool.get_data(\"pe-direction\")\n    wf.connect(node, out, choose_phase, \"unwarp_dir\")\n\n    vnum_base = pe.Node(\n        util.Function(\n            input_names=[\"vnum\",\n                         \"motion_mat_list\",\n                         \"jac_matrix_list\",\n                         \"warp_field_list\"],\n            output_names=[\"out_motion_mat\",\n                          \"out_jacobian\",\n                          \"out_warp_field\"],\n            function=find_vnum_base\n        ), name=\"Motion_Jac_Warp_matrices\",\n    )\n\n    wf.connect(choose_phase, 'vnum', vnum_base, 'vnum')\n    wf.connect(run_topup, 'out_xfms', vnum_base, 'motion_mat_list')\n    wf.connect(run_topup, 'out_jacs', vnum_base, 'jac_matrix_list')\n    wf.connect(run_topup, 'out_warps', vnum_base, 'warp_field_list')\n\n    mean_bold = strat_pool.node_data(\"sbref\")\n\n    flirt = pe.Node(interface=fsl.FLIRT(), name=\"flirt\")\n    flirt.inputs.dof = 6\n    flirt.inputs.interp = 'spline'\n    flirt.inputs.out_matrix_file = 'SBRef2PhaseTwo_gdc.mat'\n\n    wf.connect(mean_bold.node, mean_bold.out, flirt, 'in_file')\n    wf.connect(choose_phase, 'out_phase_image', flirt, 'reference')\n\n    # fsl_convert_xfm\n    convert_xfm = pe.Node(interface=fsl.ConvertXFM(), name=\"convert_xfm\")\n    convert_xfm.inputs.concat_xfm = True\n    convert_xfm.inputs.out_file = 'SBRef2WarpField.mat'\n\n    wf.connect(flirt, 'out_matrix_file', convert_xfm, 'in_file')\n    wf.connect(vnum_base, 'out_motion_mat', convert_xfm, 'in_file2')\n\n    # fsl_convert_warp\n    convert_warp = pe.Node(interface=fsl.ConvertWarp(),\n                           name=\"convert_warp\")\n    convert_warp.inputs.relwarp = True\n    convert_warp.inputs.out_relwarp = True\n    convert_warp.inputs.out_file = 'WarpField.nii.gz'\n\n    wf.connect(choose_phase, 'out_phase_image', convert_warp, 'reference')\n    wf.connect(vnum_base, 'out_warp_field', convert_warp, 'warp1')\n    wf.connect(convert_xfm, 'out_file', convert_warp, 'premat')\n\n    VolumeNumber = 1 + 1\n    vnum = str(VolumeNumber).zfill(2)\n    name = \"PhaseTwo_aw\"\n\n    vnum_base_two = pe.Node(\n        util.Function(\n            input_names=[\"vnum\",\n                         \"motion_mat_list\",\n                         \"jac_matrix_list\",\n                         \"warp_field_list\"],\n            output_names=[\"out_motion_mat\",\n                          \"out_jacobian\",\n                          \"out_warp_field\"],\n            function=find_vnum_base\n        ), name=f\"Motion_Jac_Warp_matrices_{name}\",\n    )\n    vnum_base_two.inputs.vnum = vnum\n\n    wf.connect(run_topup, 'out_xfms', vnum_base_two, 'motion_mat_list')\n    wf.connect(run_topup, 'out_jacs', vnum_base_two, 'jac_matrix_list')\n    wf.connect(run_topup, 'out_warps', vnum_base_two, 'warp_field_list')\n\n    # fsl_applywarp\n    aw_two = pe.Node(interface=fsl.ApplyWarp(), name=\"aw_two\")\n    aw_two.inputs.relwarp = True\n    aw_two.inputs.interp = 'spline'\n\n    node, out = strat_pool.get_data('epi-2')\n    wf.connect(node, out, aw_two, 'in_file')\n    wf.connect(node, out, aw_two, 'ref_file')\n\n    wf.connect(vnum_base_two, 'out_motion_mat', aw_two, 'premat')\n    wf.connect(vnum_base_two, 'out_warp_field', aw_two, 'field_file')\n\n    mul_phase_two = pe.Node(interface=fsl.BinaryMaths(),\n                            name=\"mul_phase_two\")\n    mul_phase_two.inputs.operation = 'mul'\n\n    wf.connect(aw_two, 'out_file', mul_phase_two, 'in_file')\n    wf.connect(vnum_base_two, 'out_jacobian', mul_phase_two, 'operand_file')\n\n    # PhaseOne (first vol) - warp and Jacobian modulate to get\n    # distortion corrected output\n    VolumeNumber = 0 + 1\n    vnum = str(VolumeNumber).zfill(2)\n    name = \"PhaseOne_aw\"\n\n    vnum_base_one = pe.Node(\n        util.Function(\n            input_names=[\"vnum\",\n                         \"motion_mat_list\",\n                         \"jac_matrix_list\",\n                         \"warp_field_list\"],\n            output_names=[\"out_motion_mat\",\n                          \"out_jacobian\",\n                          \"out_warp_field\"],\n            function=find_vnum_base\n        ), name=f\"Motion_Jac_Warp_matrices_{name}\",\n    )\n    vnum_base_one.inputs.vnum = vnum\n\n    wf.connect(run_topup, 'out_xfms', vnum_base_one, 'motion_mat_list')\n    wf.connect(run_topup, 'out_jacs', vnum_base_one, 'jac_matrix_list')\n    wf.connect(run_topup, 'out_warps', vnum_base_one, 'warp_field_list')\n\n    # fsl_applywarp to phaseOne\n    aw_one = pe.Node(interface=fsl.ApplyWarp(), name=\"aw_one\")\n    aw_one.inputs.relwarp = True\n    aw_one.inputs.interp = 'spline'\n\n    node, out = strat_pool.get_data('epi-1')\n    wf.connect(node, out, aw_one, 'in_file')\n    wf.connect(node, out, aw_one, 'ref_file')\n\n    wf.connect(vnum_base_one, 'out_motion_mat', aw_one, 'premat')\n    wf.connect(vnum_base_one, 'out_warp_field', aw_one, 'field_file')\n\n    mul_phase_one = pe.Node(interface=fsl.BinaryMaths(), name=\"mul_phase_one\")\n    mul_phase_one.inputs.operation = 'mul'\n\n    wf.connect(aw_one, 'out_file', mul_phase_one, 'in_file')\n    wf.connect(vnum_base_one, 'out_jacobian', mul_phase_one, 'operand_file')\n\n    # Scout - warp and Jacobian modulate to get distortion corrected output\n    aw_jac = pe.Node(interface=fsl.ApplyWarp(), name=\"aw_jac\")\n    aw_jac.inputs.relwarp = True\n    aw_jac.inputs.interp = 'spline'\n\n    wf.connect(mean_bold.node, mean_bold.out, aw_jac, 'in_file') # SBRef.nii.gz\n    wf.connect(mean_bold.node, mean_bold.out,\n               aw_jac, 'ref_file') # SBRef.nii.gz\n    wf.connect(convert_warp, 'out_file', aw_jac, 'field_file')\n\n    mul_jac = pe.Node(interface=fsl.BinaryMaths(), name=\"mul_jac\")\n    mul_jac.inputs.operation = 'mul'\n    mul_jac.inputs.out_file = \"SBRef_dc_jac.nii.gz\"\n\n    wf.connect(aw_jac, 'out_file', mul_jac, 'in_file')\n    wf.connect(vnum_base, 'out_jacobian', mul_jac, 'operand_file')\n\n    # Calculate Equivalent Field Map\n    tp_field_map = pe.Node(interface=fsl.BinaryMaths(), name=\"tp_field_map\")\n    tp_field_map.inputs.operation = 'mul'\n    tp_field_map.inputs.operand_value = 6.283\n\n    wf.connect(run_topup, 'out_fieldcoef', tp_field_map, 'in_file')\n\n    mag_field_map = pe.Node(interface=fsl.MeanImage(),\n                            name=\"mag_field_map\")\n    mag_field_map.inputs.dimension = 'T'\n    mag_field_map.inputs.out_file = 'Magnitude.nii.gz'\n\n    wf.connect(run_topup, 'corrected_outfile', mag_field_map, 'in_file')\n\n    # fsl_bet\n    bet = pe.Node(interface=fsl.BET(), name=\"bet\")\n    bet.inputs.frac = 0.35\n    bet.inputs.mask = True\n\n    wf.connect(mag_field_map, 'out_file', bet, 'in_file')\n\n    outputs = {\n        'sbref': (mul_jac, 'out_file'),\n        'fsl-blip-warp': (convert_warp, 'out_file')\n        #'space-bold_desc-brain_mask': (mask_sbref, 'out_file')\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "ICA_AROMA_FSLreg",
    "file": "CPAC/nuisance/nuisance.py",
    "line_number": 1798,
    "decorator_args": {
      "name": "ICA_AROMA_FSLreg",
      "config": [
        "nuisance_corrections",
        "1-ICA-AROMA"
      ],
      "switch": [
        "run"
      ],
      "inputs": [
        "desc-preproc_bold",
        "from-bold_to-T1w_mode-image_desc-linear_xfm",
        "from-T1w_to-template_mode-image_xfm"
      ],
      "outputs": [
        "desc-preproc_bold",
        "desc-cleaned_bold"
      ]
    },
    "docstring": null,
    "source_code": "def ICA_AROMA_FSLreg(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    xfm_prov = strat_pool.get_cpac_provenance('from-T1w_to-template_mode-image_xfm')\n    reg_tool = check_prov_for_regtool(xfm_prov)\n\n    if reg_tool != 'fsl':\n        return (wf, None)\n\n    aroma_preproc = create_aroma(tr=None, wf_name=f'create_aroma_{pipe_num}')\n\n    aroma_preproc.inputs.params.denoise_type = \\\n        cfg.nuisance_corrections['1-ICA-AROMA']['denoising_type']\n\n    node, out = strat_pool.get_data(\"desc-preproc_bold\")\n    wf.connect(node, out, aroma_preproc, 'inputspec.denoise_file')\n\n    node, out = strat_pool.get_data(\n        \"from-bold_to-T1w_mode-image_desc-linear_xfm\")\n    wf.connect(node, out, aroma_preproc, 'inputspec.mat_file')\n\n    node, out = strat_pool.get_data(\"from-T1w_to-template_mode-image_xfm\")\n    wf.connect(node, out, aroma_preproc, 'inputspec.fnirt_warp_file')\n\n    if cfg.nuisance_corrections['1-ICA-AROMA']['denoising_type'] == 'nonaggr':\n        node, out = (aroma_preproc, 'outputspec.nonaggr_denoised_file')\n    elif cfg.nuisance_corrections['1-ICA-AROMA']['denoising_type'] == 'aggr':\n        node, out = (aroma_preproc, 'outputspec.aggr_denoised_file')\n\n    outputs = {\n        'desc-preproc_bold': (node, out),\n        'desc-cleaned_bold': (node, out)\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "ICA_AROMA_ANTsreg",
    "file": "CPAC/nuisance/nuisance.py",
    "line_number": 1849,
    "decorator_args": {
      "name": "ICA_AROMA_ANTsreg",
      "config": [
        "nuisance_corrections",
        "1-ICA-AROMA"
      ],
      "switch": [
        "run"
      ],
      "inputs": [
        [
          "desc-preproc_bold",
          "sbref",
          "from-bold_to-template_mode-image_xfm",
          "from-template_to-bold_mode-image_xfm"
        ],
        "T1w-brain-template-funcreg"
      ],
      "outputs": [
        "desc-preproc_bold",
        "desc-cleaned_bold"
      ]
    },
    "docstring": null,
    "source_code": "def ICA_AROMA_ANTsreg(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    xfm_prov = strat_pool.get_cpac_provenance(\n        'from-bold_to-template_mode-image_xfm')\n    reg_tool = check_prov_for_regtool(xfm_prov)\n\n    if reg_tool != 'ants':\n        return (wf, None)\n\n    num_cpus = cfg.pipeline_setup['system_config'][\n        'max_cores_per_participant']\n\n    num_ants_cores = cfg.pipeline_setup['system_config']['num_ants_threads']\n\n    aroma_preproc = create_aroma(tr=None, wf_name=f'create_aroma_{pipe_num}')\n    aroma_preproc.inputs.params.denoise_type = \\\n        cfg.nuisance_corrections['1-ICA-AROMA']['denoising_type']\n\n    wf, outputs = warp_timeseries_to_T1template(wf, cfg, strat_pool, pipe_num)\n    for key, val in outputs.items():\n        node, out = val\n\n    wf.connect(node, out, aroma_preproc, 'inputspec.denoise_file')\n\n    apply_xfm = apply_transform(f'ICA-AROMA_ANTs_template_to_bold_{pipe_num}',\n                                reg_tool=reg_tool, time_series=True,\n                                num_cpus=num_cpus,\n                                num_ants_cores=num_ants_cores)\n    apply_xfm.inputs.inputspec.interpolation = cfg.registration_workflows[\n            'functional_registration']['func_registration_to_template'][\n            'ANTs_pipelines']['interpolation']\n\n    if cfg.nuisance_corrections['1-ICA-AROMA']['denoising_type'] == 'nonaggr':\n        node, out = (aroma_preproc, 'outputspec.nonaggr_denoised_file')\n    elif cfg.nuisance_corrections['1-ICA-AROMA']['denoising_type'] == 'aggr':\n        node, out = (aroma_preproc, 'outputspec.aggr_denoised_file')\n\n    wf.connect(node, out, apply_xfm, 'inputspec.input_image')\n\n    node, out = strat_pool.get_data(\"sbref\")\n    wf.connect(node, out, apply_xfm, 'inputspec.reference')\n\n    node, out = strat_pool.get_data('from-template_to-bold_mode-image_xfm')\n    wf.connect(node, out, apply_xfm, 'inputspec.transform')\n\n    outputs = {\n        'desc-preproc_bold': (apply_xfm, 'outputspec.output_image'),\n        'desc-cleaned_bold': (apply_xfm, 'outputspec.output_image')\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "ICA_AROMA_FSLEPIreg",
    "file": "CPAC/nuisance/nuisance.py",
    "line_number": 1919,
    "decorator_args": {
      "name": "ICA_AROMA_FSLEPIreg",
      "switch": [
        [
          "nuisance_corrections",
          "1-ICA-AROMA",
          "run"
        ],
        [
          "registration_workflows",
          "functional_registration",
          "EPI_registration",
          "run"
        ]
      ],
      "inputs": [
        [
          "desc-brain_bold",
          "desc-motion_bold",
          "desc-preproc_bold",
          "bold"
        ],
        "from-bold_to-EPItemplate_mode-image_xfm"
      ],
      "outputs": [
        "desc-preproc_bold",
        "desc-cleaned_bold"
      ]
    },
    "docstring": null,
    "source_code": "def ICA_AROMA_FSLEPIreg(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    xfm_prov = strat_pool.get_cpac_provenance('from-bold_to-EPItemplate_mode-image_xfm')\n    reg_tool = check_prov_for_regtool(xfm_prov)\n\n    if reg_tool != 'fsl':\n        return (wf, None)\n\n    aroma_preproc = create_aroma(tr=None, wf_name=f'create_aroma_{pipe_num}')\n\n    aroma_preproc.inputs.params.denoise_type = \\\n        cfg.nuisance_corrections['1-ICA-AROMA']['denoising_type']\n\n    node, out = strat_pool.get_data([\"desc-brain_bold\", \"desc-motion_bold\",\n                                     \"desc-preproc_bold\", \"bold\"])\n    wf.connect(node, out, aroma_preproc, 'inputspec.denoise_file')\n\n    node, out = strat_pool.get_data(\"from-bold_to-EPItemplate_mode-image_xfm\")\n    wf.connect(node, out, aroma_preproc, 'inputspec.fnirt_warp_file')\n\n    if cfg.nuisance_corrections['1-ICA-AROMA']['denoising_type'] == 'nonaggr':\n        node, out = (aroma_preproc, 'outputspec.nonaggr_denoised_file')\n    elif cfg.nuisance_corrections['1-ICA-AROMA']['denoising_type'] == 'aggr':\n        node, out = (aroma_preproc, 'outputspec.aggr_denoised_file')\n\n    outputs = {\n        'desc-preproc_bold': (node, out),\n        'desc-cleaned_bold': (node, out)\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "ICA_AROMA_ANTsEPIreg",
    "file": "CPAC/nuisance/nuisance.py",
    "line_number": 1974,
    "decorator_args": {
      "name": "ICA_AROMA_ANTsEPIreg",
      "switch": [
        [
          "nuisance_corrections",
          "1-ICA-AROMA",
          "run"
        ],
        [
          "registration_workflows",
          "functional_registration",
          "EPI_registration",
          "run"
        ]
      ],
      "inputs": [
        [
          "desc-preproc_bold",
          "sbref",
          "from-bold_to-EPItemplate_mode-image_xfm",
          "from-EPItemplate_to-bold_mode-image_xfm"
        ],
        "EPI-template"
      ],
      "outputs": [
        "desc-preproc_bold",
        "desc-cleaned_bold"
      ]
    },
    "docstring": null,
    "source_code": "def ICA_AROMA_ANTsEPIreg(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    xfm_prov = strat_pool.get_cpac_provenance(\n        'from-bold_to-EPItemplate_mode-image_xfm')\n    reg_tool = check_prov_for_regtool(xfm_prov)\n\n    if reg_tool != 'ants':\n        return (wf, None)\n\n    num_cpus = cfg.pipeline_setup['system_config'][\n        'max_cores_per_participant']\n\n    num_ants_cores = cfg.pipeline_setup['system_config']['num_ants_threads']\n\n    aroma_preproc = create_aroma(tr=None, wf_name=f'create_aroma_{pipe_num}')\n    aroma_preproc.inputs.params.denoise_type = \\\n        cfg.nuisance_corrections['1-ICA-AROMA']['denoising_type']\n\n    wf, outputs = warp_timeseries_to_EPItemplate(wf, cfg, strat_pool,\n                                                 pipe_num)\n    for key, val in outputs.items():\n        node, out = val\n\n    wf.connect(node, out, aroma_preproc, 'inputspec.denoise_file')\n\n    apply_xfm = apply_transform(f'ICA-AROMA_ANTs_EPItemplate_to_bold_{pipe_num}',\n                                reg_tool=reg_tool, time_series=True,\n                                num_cpus=num_cpus,\n                                num_ants_cores=num_ants_cores)\n    apply_xfm.inputs.inputspec.interpolation = cfg.registration_workflows[\n            'functional_registration']['func_registration_to_template'][\n            'ANTs_pipelines']['interpolation']\n\n    if cfg.nuisance_corrections['1-ICA-AROMA']['denoising_type'] == 'nonaggr':\n        node, out = (aroma_preproc, 'outputspec.nonaggr_denoised_file')\n    elif cfg.nuisance_corrections['1-ICA-AROMA']['denoising_type'] == 'aggr':\n        node, out = (aroma_preproc, 'outputspec.aggr_denoised_file')\n\n    wf.connect(node, out, apply_xfm, 'inputspec.input_image')\n\n    node, out = strat_pool.get_data(\"sbref\")\n    wf.connect(node, out, apply_xfm, 'inputspec.reference')\n\n    node, out = strat_pool.get_data('from-EPItemplate_to-bold_mode-image_xfm')\n    wf.connect(node, out, apply_xfm, 'inputspec.transform')\n\n    outputs = {\n        'desc-preproc_bold': (apply_xfm, 'outputspec.output_image'),\n        'desc-cleaned_bold': (apply_xfm, 'outputspec.output_image')\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "erode_mask_T1w",
    "file": "CPAC/nuisance/nuisance.py",
    "line_number": 2045,
    "decorator_args": {
      "name": "erode_mask_T1w",
      "switch": [
        [
          "nuisance_corrections",
          "2-nuisance_regression",
          "create_regressors"
        ],
        [
          "nuisance_corrections",
          "2-nuisance_regression",
          "regressor_masks",
          "erode_anatomical_brain_mask",
          "run"
        ]
      ],
      "inputs": [
        [
          "space-T1w_desc-brain_mask",
          [
            "label-CSF_desc-preproc_mask",
            "label-CSF_mask"
          ]
        ]
      ],
      "outputs": [
        "space-T1w_desc-eroded_mask"
      ]
    },
    "docstring": null,
    "source_code": "def erode_mask_T1w(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    erode = erode_mask(f'erode_T1w_mask_{pipe_num}', segmentmap=False)\n    erode.inputs.inputspec.mask_erode_mm = cfg.nuisance_corrections[\n        '2-nuisance_regression']['regressor_masks'][\n        'erode_anatomical_brain_mask']['brain_mask_erosion_mm']\n    erode.inputs.inputspec.erode_prop = cfg.nuisance_corrections[\n        '2-nuisance_regression']['regressor_masks'][\n        'erode_anatomical_brain_mask']['brain_mask_erosion_prop']\n\n    node, out = strat_pool.get_data('space-T1w_desc-brain_mask')\n    wf.connect(node, out, erode, 'inputspec.brain_mask')\n\n    node, out = strat_pool.get_data(['label-CSF_desc-preproc_mask',\n                                     'label-CSF_mask'])\n    wf.connect(node, out, erode, 'inputspec.mask')\n\n    outputs = {\n        'space-T1w_desc-eroded_mask': (erode, 'outputspec.eroded_mask')\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "erode_mask_CSF",
    "file": "CPAC/nuisance/nuisance.py",
    "line_number": 2086,
    "decorator_args": {
      "name": "erode_mask_CSF",
      "switch": [
        [
          "nuisance_corrections",
          "2-nuisance_regression",
          "create_regressors"
        ],
        [
          "nuisance_corrections",
          "2-nuisance_regression",
          "regressor_masks",
          "erode_csf",
          "run"
        ]
      ],
      "inputs": [
        [
          [
            "label-CSF_desc-preproc_mask",
            "label-CSF_mask"
          ],
          "space-T1w_desc-brain_mask"
        ]
      ],
      "outputs": [
        "label-CSF_desc-eroded_mask"
      ]
    },
    "docstring": null,
    "source_code": "def erode_mask_CSF(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    erode = erode_mask(f'erode_CSF_mask_{pipe_num}')\n    erode.inputs.inputspec.erode_mm = cfg.nuisance_corrections[\n        '2-nuisance_regression']['regressor_masks']['erode_csf'][\n        'csf_erosion_mm']\n    erode.inputs.inputspec.erode_prop = cfg.nuisance_corrections[\n        '2-nuisance_regression']['regressor_masks']['erode_csf'][\n        'csf_erosion_prop']\n\n    erode.inputs.inputspec.mask_erode_mm = cfg.nuisance_corrections[\n        '2-nuisance_regression']['regressor_masks']['erode_csf'][\n        'csf_mask_erosion_mm']\n\n    node, out = strat_pool.get_data(['label-CSF_desc-preproc_mask',\n                                     'label-CSF_mask'])\n    wf.connect(node, out, erode, 'inputspec.mask')\n\n    node, out = strat_pool.get_data('space-T1w_desc-brain_mask')\n    wf.connect(node, out, erode, 'inputspec.brain_mask')\n\n    outputs = {\n        'label-CSF_desc-eroded_mask': (erode, 'outputspec.eroded_mask')\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "erode_mask_GM",
    "file": "CPAC/nuisance/nuisance.py",
    "line_number": 2129,
    "decorator_args": {
      "name": "erode_mask_GM",
      "switch": [
        [
          "nuisance_corrections",
          "2-nuisance_regression",
          "create_regressors"
        ],
        [
          "nuisance_corrections",
          "2-nuisance_regression",
          "regressor_masks",
          "erode_gm",
          "run"
        ]
      ],
      "inputs": [
        [
          "label-GM_desc-preproc",
          "label-GM_mask"
        ]
      ],
      "outputs": [
        "label-GM_desc-eroded_mask"
      ]
    },
    "docstring": null,
    "source_code": "def erode_mask_GM(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    erode = erode_mask(f'erode_GM_mask_{pipe_num}')\n    erode.inputs.inputspec.erode_mm = cfg.nuisance_corrections[\n        '2-nuisance_regression']['regressor_masks']['erode_gm'][\n        'gm_erosion_mm']\n    erode.inputs.inputspec.erode_prop = cfg.nuisance_corrections[\n        '2-nuisance_regression']['regressor_masks']['erode_gm'][\n        'gm_erosion_prop']\n\n    erode.inputs.inputspec.mask_erode_mm = cfg.nuisance_corrections[\n        '2-nuisance_regression']['regressor_masks']['erode_gm'][\n        'gm_mask_erosion_mm']\n\n    node, out = strat_pool.get_data(['label-GM_desc-preproc_mask',\n                                     'label-GM_mask'])\n    wf.connect(node, out, erode, 'inputspec.mask')\n\n    outputs = {\n        'label-GM_desc-eroded_mask': (erode, 'outputspec.eroded_mask')\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "erode_mask_WM",
    "file": "CPAC/nuisance/nuisance.py",
    "line_number": 2171,
    "decorator_args": {
      "name": "erode_mask_WM",
      "switch": [
        [
          "nuisance_corrections",
          "2-nuisance_regression",
          "create_regressors"
        ],
        [
          "nuisance_corrections",
          "2-nuisance_regression",
          "regressor_masks",
          "erode_wm",
          "run"
        ]
      ],
      "inputs": [
        [
          [
            "label-WM_desc-preproc_mask",
            "label-WM_mask"
          ],
          "space-T1w_desc-brain_mask"
        ]
      ],
      "outputs": [
        "label-WM_desc-eroded_mask"
      ]
    },
    "docstring": null,
    "source_code": "def erode_mask_WM(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    erode = erode_mask(f'erode_WM_mask_{pipe_num}')\n    erode.inputs.inputspec.erode_mm = cfg.nuisance_corrections[\n        '2-nuisance_regression']['regressor_masks']['erode_wm'][\n        'wm_erosion_mm']\n    erode.inputs.inputspec.erode_prop = cfg.nuisance_corrections[\n        '2-nuisance_regression']['regressor_masks']['erode_wm'][\n        'wm_erosion_prop']\n\n    erode.inputs.inputspec.mask_erode_mm = cfg.nuisance_corrections[\n        '2-nuisance_regression']['regressor_masks']['erode_wm'][\n        'wm_mask_erosion_mm']\n\n    node, out = strat_pool.get_data(['label-WM_desc-preproc_mask',\n                                     'label-WM_mask'])\n    wf.connect(node, out, erode, 'inputspec.mask')\n\n    node, out = strat_pool.get_data('space-T1w_desc-brain_mask')\n    wf.connect(node, out, erode, 'inputspec.brain_mask')\n\n    outputs = {\n        'label-WM_desc-eroded_mask': (erode, 'outputspec.eroded_mask')\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "nuisance_regressors_generation_EPItemplate",
    "file": "CPAC/nuisance/nuisance.py",
    "line_number": 2239,
    "decorator_args": {
      "name": "nuisance_regressors_generation_EPItemplate",
      "config": [
        "nuisance_corrections",
        "2-nuisance_regression"
      ],
      "switch": [
        "create_regressors"
      ],
      "option_key": "Regressors",
      "option_val": "USER-DEFINED",
      "inputs": [
        [
          "desc-preproc_bold",
          "desc-brain_bold",
          "space-bold_desc-brain_mask",
          "desc-movementParameters_motion",
          "framewise-displacement-jenkinson",
          "framewise-displacement-power",
          "dvars",
          [
            "space-bold_desc-eroded_mask",
            "space-bold_desc-brain_mask"
          ],
          [
            "space-bold_label-CSF_desc-eroded_mask",
            "space-bold_label-CSF_desc-preproc_mask",
            "space-bold_label-CSF_mask"
          ],
          [
            "space-bold_label-WM_desc-eroded_mask",
            "space-bold_label-WM_desc-preproc_mask",
            "space-bold_label-WM_mask"
          ],
          [
            "space-bold_label-GM_desc-eroded_mask",
            "space-bold_label-GM_desc-preproc_mask",
            "space-bold_label-GM_mask"
          ],
          "from-EPItemplate_to-bold_mode-image_desc-linear_xfm",
          "from-bold_to-EPItemplate_mode-image_desc-linear_xfm"
        ],
        "lateral-ventricles-mask",
        "TR"
      ],
      "outputs": [
        "desc-confounds_timeseries",
        "censor-indices"
      ]
    },
    "docstring": null,
    "source_code": "def nuisance_regressors_generation_EPItemplate(wf, cfg, strat_pool, pipe_num,\n                                               opt=None):\n    return nuisance_regressors_generation(wf, cfg, strat_pool, pipe_num, opt,\n                                          'bold')"
  },
  {
    "name": "nuisance_regressors_generation_T1w",
    "file": "CPAC/nuisance/nuisance.py",
    "line_number": 2284,
    "decorator_args": {
      "name": "nuisance_regressors_generation_T1w",
      "config": [
        "nuisance_corrections",
        "2-nuisance_regression"
      ],
      "switch": [
        "create_regressors"
      ],
      "option_key": "Regressors",
      "option_val": "USER-DEFINED",
      "inputs": [
        [
          "desc-preproc_bold",
          "space-bold_desc-brain_mask",
          "from-bold_to-T1w_mode-image_desc-linear_xfm",
          "desc-movementParameters_motion",
          "framewise-displacement-jenkinson",
          "framewise-displacement-power",
          "dvars",
          "desc-brain_T1w",
          [
            "space-T1w_desc-eroded_mask",
            "space-T1w_desc-brain_mask"
          ],
          [
            "label-CSF_desc-eroded_mask",
            "label-CSF_desc-preproc_mask",
            "label-CSF_mask"
          ],
          [
            "label-WM_desc-eroded_mask",
            "label-WM_desc-preproc_mask",
            "label-WM_mask"
          ],
          [
            "label-GM_desc-eroded_mask",
            "label-GM_desc-preproc_mask",
            "label-GM_mask"
          ],
          "from-template_to-T1w_mode-image_desc-linear_xfm",
          "from-T1w_to-template_mode-image_desc-linear_xfm"
        ],
        "lateral-ventricles-mask",
        "TR"
      ],
      "outputs": [
        "desc-confounds_timeseries",
        "censor-indices"
      ]
    },
    "docstring": null,
    "source_code": "def nuisance_regressors_generation_T1w(wf, cfg, strat_pool, pipe_num, opt=None\n                                       ):\n    return nuisance_regressors_generation(wf, cfg, strat_pool, pipe_num, opt,\n                                          'T1w')"
  },
  {
    "name": "ingress_regressors",
    "file": "CPAC/nuisance/nuisance.py",
    "line_number": 2659,
    "decorator_args": {
      "name": "ingress_regressors",
      "switch": [
        [
          "nuisance_corrections",
          "2-nuisance_regression",
          "run"
        ],
        [
          "nuisance_corrections",
          "2-nuisance_regression",
          "ingress_regressors",
          "run"
        ]
      ],
      "inputs": [
        "pipeline-ingress_desc-confounds_timeseries"
      ],
      "outputs": [
        "parsed_regressors"
      ]
    },
    "docstring": null,
    "source_code": "def ingress_regressors(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    regressors_list = cfg.nuisance_corrections['2-nuisance_regression']['ingress_regressors'][\n        'Regressors']['Columns']\n    \n    # Will need to generalize the name\n    node, out = strat_pool.get_data('pipeline-ingress_desc-confounds_timeseries')\n    if not regressors_list:\n        logger.warning(\"\\n[!] Ingress regressors is on, but no regressors provided. \"  \n                                            \"The whole regressors file will be applied, but it may be\" \n                                            \"too large for the timeseries data!\")\n        outputs = {\n            'parsed_regressors': (node, out)\n        }\n    else:\n        ingress_imports = ['import numpy as np',\n                   'import numpy as np', 'import os',\n                   'import CPAC', 'from nipype import logging',\n                   'logger = logging.getLogger(\"nipype.workflow\")']\n        ingress_regressors = pe.Node(Function(\n                input_names=['regressors_file',\n                            'regressors_list'],\n                output_names=['parsed_regressors'],\n                function=parse_regressors,\n                imports=ingress_imports\n            ), name=\"parse_regressors_file\")\n\n        wf.connect(node, out, ingress_regressors, 'regressors_file')\n        ingress_regressors.inputs.regressors_list = regressors_list\n\n        outputs = {\n            'parsed_regressors': (ingress_regressors, 'parsed_regressors')\n        }\n    \n    return wf, outputs"
  },
  {
    "name": "nuisance_regression_native",
    "file": "CPAC/nuisance/nuisance.py",
    "line_number": 2777,
    "decorator_args": {
      "name": "nuisance_regression_native",
      "config": [
        "nuisance_corrections",
        "2-nuisance_regression"
      ],
      "switch": [
        "run"
      ],
      "option_key": "space",
      "option_val": "native",
      "inputs": [
        [
          "desc-preproc_bold",
          [
            "desc-confounds_timeseries",
            "parsed_regressors"
          ],
          "space-bold_desc-brain_mask",
          "framewise-displacement-jenkinson",
          "framewise-displacement-power",
          "dvars"
        ],
        "TR"
      ],
      "outputs": "!UNSUPPORTED_TYPE:Dict!"
    },
    "docstring": null,
    "source_code": "def nuisance_regression_native(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    return nuisance_regression(wf, cfg, strat_pool, pipe_num, opt, 'native')"
  },
  {
    "name": "nuisance_regression_template",
    "file": "CPAC/nuisance/nuisance.py",
    "line_number": 2824,
    "decorator_args": {
      "name": "nuisance_regression_template",
      "config": [
        "nuisance_corrections",
        "2-nuisance_regression"
      ],
      "switch": [
        "run"
      ],
      "option_key": "space",
      "option_val": "template",
      "inputs": [
        [
          "desc-stc_bold",
          "space-template_desc-preproc_bold",
          "space-template_res-derivative_desc-preproc_bold",
          "desc-movementParameters_motion",
          [
            "desc-confounds_timeseries",
            "parsed_regressors"
          ],
          "FSL-AFNI-brain-mask",
          "framewise-displacement-jenkinson",
          "framewise-displacement-power",
          "dvars"
        ],
        "TR"
      ],
      "outputs": "!UNSUPPORTED_TYPE:Dict!"
    },
    "docstring": "Apply nuisance regression to template-space image",
    "source_code": "def nuisance_regression_template(wf, cfg, strat_pool, pipe_num, opt=None):\n    '''Apply nuisance regression to template-space image'''\n    wf, outputs = nuisance_regression(wf, cfg, strat_pool, pipe_num, opt,\n                                      'template')\n    if strat_pool.check_rpool(\n        'space-template_res-derivative_desc-preproc_bold'\n    ):\n        wf, res_outputs = nuisance_regression(wf, cfg, strat_pool, pipe_num,\n                                              opt, 'template', 'derivative')\n        outputs.update(res_outputs)\n    return (wf, outputs)"
  },
  {
    "name": "erode_mask_bold",
    "file": "CPAC/nuisance/nuisance.py",
    "line_number": 2862,
    "decorator_args": {
      "name": "erode_mask_bold",
      "switch": [
        [
          "nuisance_corrections",
          "2-nuisance_regression",
          "regressor_masks",
          "erode_anatomical_brain_mask",
          "run"
        ],
        [
          "registration_workflows",
          "functional_registration",
          "EPI_registration",
          "run"
        ]
      ],
      "inputs": [
        [
          "space-bold_desc-brain_mask",
          [
            "space-bold_label-CSF_desc-preproc_mask",
            "space-bold_label-CSF_mask"
          ]
        ]
      ],
      "outputs": [
        "space-bold_desc-eroded_mask"
      ]
    },
    "docstring": null,
    "source_code": "def erode_mask_bold(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    erode = erode_mask(f'erode_T1w_mask_{pipe_num}', segmentmap=False)\n    erode.inputs.inputspec.mask_erode_mm = cfg.nuisance_corrections[\n        '2-nuisance_regression']['regressor_masks'][\n        'erode_anatomical_brain_mask']['brain_mask_erosion_mm']\n    erode.inputs.inputspec.erode_prop = cfg.nuisance_corrections[\n        '2-nuisance_regression']['regressor_masks'][\n        'erode_anatomical_brain_mask']['brain_mask_erosion_prop']\n\n    node, out = strat_pool.get_data('space-bold_desc-brain_mask')\n    wf.connect(node, out, erode, 'inputspec.brain_mask')\n\n    node, out = strat_pool.get_data(['space-bold_label-CSF_desc-preproc_mask',\n                                     'space-bold_label-CSF_mask'])\n    wf.connect(node, out, erode, 'inputspec.mask')\n\n    outputs = {\n        'space-bold_desc-eroded_mask': (erode, 'outputspec.eroded_mask')\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "erode_mask_boldCSF",
    "file": "CPAC/nuisance/nuisance.py",
    "line_number": 2911,
    "decorator_args": {
      "name": "erode_mask_boldCSF",
      "switch": [
        [
          "nuisance_corrections",
          "2-nuisance_regression",
          "regressor_masks",
          "erode_csf",
          "run"
        ],
        [
          "registration_workflows",
          "functional_registration",
          "EPI_registration",
          "run"
        ]
      ],
      "inputs": [
        [
          [
            "space-bold_label-CSF_desc-preproc_mask",
            "space-bold_label-CSF_mask"
          ],
          "space-bold_desc-brain_mask"
        ]
      ],
      "outputs": [
        "space-bold_label-CSF_desc-eroded_mask"
      ]
    },
    "docstring": null,
    "source_code": "def erode_mask_boldCSF(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    erode = erode_mask(f'erode_CSF_mask_{pipe_num}')\n    erode.inputs.inputspec.erode_mm = cfg.nuisance_corrections[\n        '2-nuisance_regression']['regressor_masks']['erode_csf'][\n        'csf_erosion_mm']\n    erode.inputs.inputspec.erode_prop = cfg.nuisance_corrections[\n        '2-nuisance_regression']['regressor_masks']['erode_csf'][\n        'csf_erosion_prop']\n\n    erode.inputs.inputspec.mask_erode_mm = cfg.nuisance_corrections[\n        '2-nuisance_regression']['regressor_masks']['erode_csf'][\n        'csf_mask_erosion_mm']\n\n    node, out = strat_pool.get_data(['space-bold_label-CSF_desc-preproc_mask',\n                                     'space-bold_label-CSF_mask'])\n    wf.connect(node, out, erode, 'inputspec.mask')\n\n    node, out = strat_pool.get_data('space-bold_desc-brain_mask')\n    wf.connect(node, out, erode, 'inputspec.brain_mask')\n\n    outputs = {\n        'space-bold_label-CSF_desc-eroded_mask': (erode, 'outputspec.eroded_mask')\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "erode_mask_boldGM",
    "file": "CPAC/nuisance/nuisance.py",
    "line_number": 2959,
    "decorator_args": {
      "name": "erode_mask_boldGM",
      "switch": [
        [
          "nuisance_corrections",
          "2-nuisance_regression",
          "regressor_masks",
          "erode_gm",
          "run"
        ],
        [
          "registration_workflows",
          "functional_registration",
          "EPI_registration",
          "run"
        ]
      ],
      "inputs": [
        [
          "space-bold_label-GM_desc-preproc",
          "space-bold_label-GM_mask"
        ]
      ],
      "outputs": [
        "space-bold_label-GM_desc-eroded_mask"
      ]
    },
    "docstring": null,
    "source_code": "def erode_mask_boldGM(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    erode = erode_mask(f'erode_GM_mask_{pipe_num}')\n    erode.inputs.inputspec.erode_mm = cfg.nuisance_corrections[\n        '2-nuisance_regression']['regressor_masks']['erode_gm'][\n        'gm_erosion_mm']\n    erode.inputs.inputspec.erode_prop = cfg.nuisance_corrections[\n        '2-nuisance_regression']['regressor_masks']['erode_gm'][\n        'gm_erosion_prop']\n\n    erode.inputs.inputspec.mask_erode_mm = cfg.nuisance_corrections[\n        '2-nuisance_regression']['regressor_masks']['erode_gm'][\n        'gm_mask_erosion_mm']\n\n    node, out = strat_pool.get_data(['space-bold_label-GM_desc-preproc_mask',\n                                     'space-bold_label-GM_mask'])\n    wf.connect(node, out, erode, 'inputspec.mask')\n\n    outputs = {\n        'space-bold_label-GM_desc-eroded_mask': (erode, 'outputspec.eroded_mask')\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "erode_mask_boldWM",
    "file": "CPAC/nuisance/nuisance.py",
    "line_number": 3009,
    "decorator_args": {
      "name": "erode_mask_boldWM",
      "switch": [
        [
          "nuisance_corrections",
          "2-nuisance_regression",
          "regressor_masks",
          "erode_wm",
          "run"
        ],
        [
          "registration_workflows",
          "functional_registration",
          "EPI_registration",
          "run"
        ]
      ],
      "inputs": [
        [
          [
            "space-bold_label-WM_desc-preproc_mask",
            "space-bold_label-WM_mask"
          ],
          "space-bold_desc-brain_mask"
        ]
      ],
      "outputs": [
        "space-bold_label-WM_desc-eroded_mask"
      ]
    },
    "docstring": null,
    "source_code": "def erode_mask_boldWM(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    erode = erode_mask(f'erode_WM_mask_{pipe_num}')\n    erode.inputs.inputspec.erode_mm = cfg.nuisance_corrections[\n        '2-nuisance_regression']['regressor_masks']['erode_wm'][\n        'wm_erosion_mm']\n    erode.inputs.inputspec.erode_prop = cfg.nuisance_corrections[\n        '2-nuisance_regression']['regressor_masks']['erode_wm'][\n        'wm_erosion_prop']\n\n    erode.inputs.inputspec.mask_erode_mm = cfg.nuisance_corrections[\n        '2-nuisance_regression']['regressor_masks']['erode_wm'][\n        'wm_mask_erosion_mm']\n\n    node, out = strat_pool.get_data(['space-bold_label-WM_desc-preproc_mask',\n                                     'space-bold_label-WM_mask'])\n    wf.connect(node, out, erode, 'inputspec.mask')\n\n    node, out = strat_pool.get_data('space-bold_desc-brain_mask')\n    wf.connect(node, out, erode, 'inputspec.brain_mask')\n\n    outputs = {\n        'space-bold_label-WM_desc-eroded_mask': (erode,\n                                                 'outputspec.eroded_mask')\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "qc_xcp",
    "file": "CPAC/qc/xcp.py",
    "line_number": 408,
    "decorator_args": {
      "name": "qc_xcp",
      "config": [
        "pipeline_setup",
        "output_directory",
        "quality_control"
      ],
      "switch": [
        "generate_xcpqc_files"
      ],
      "inputs": [
        [
          "subject",
          "scan",
          "bold",
          "desc-preproc_bold",
          "space-T1w_sbref",
          "space-T1w_desc-brain_mask",
          "max-displacement",
          "space-template_desc-preproc_bold",
          "space-bold_desc-brain_mask",
          [
            "T1w-brain-template-mask",
            "EPI-template-mask"
          ],
          [
            "space-template_desc-bold_mask",
            "space-EPItemplate_desc-bold_mask"
          ],
          "regressors",
          [
            "T1w-brain-template-funcreg",
            "EPI-brain-template-funcreg"
          ],
          [
            "desc-movementParametersUnfiltered_motion",
            "desc-movementParameters_motion"
          ],
          "dvars",
          "framewise-displacement-jenkinson"
        ]
      ],
      "outputs": "!UNSUPPORTED_TYPE:Dict!"
    },
    "docstring": null,
    "source_code": "def qc_xcp(wf, cfg, strat_pool, pipe_num, opt=None):\n    # pylint: disable=invalid-name, unused-argument\n    if cfg['nuisance_corrections', '2-nuisance_regression', 'run'\n           ] and not strat_pool.check_rpool('regressors'):\n        return wf, {}\n    bids_info = pe.Node(Function(input_names=['subject', 'scan', 'wf_name'],\n                                 output_names=['subject', 'session', 'task',\n                                               'run'],\n                                 imports=['from bids.layout import '\n                                          'parse_file_entities'],\n                                 function=get_bids_info, as_module=True),\n                        name=f'bids_info_{pipe_num}')\n    bids_info.inputs.wf_name = wf.name\n    qc_file = pe.Node(Function(input_names=['sub', 'ses', 'task', 'run',\n                                            'desc', 'bold2t1w_mask',\n                                            't1w_mask', 'bold2template_mask',\n                                            'template_mask', 'original_func',\n                                            'final_func', 'template',\n                                            'movement_parameters', 'dvars',\n                                            'censor_indices', 'regressors',\n                                            'framewise_displacement_jenkinson',\n                                            'dvars_after'],\n                               output_names=['qc_file'],\n                               function=generate_xcp_qc,\n                               as_module=True),\n                      name=f'qcxcp_{pipe_num}')\n    qc_file.inputs.desc = 'preproc'\n    qc_file.inputs.regressors = strat_pool.node_data(\n        'regressors').node.name.split('regressors_'\n    )[-1][::-1].split('_', 1)[-1][::-1]\n    bold_to_T1w_mask = pe.Node(interface=fsl.ImageMaths(),\n                               name=f'binarize_bold_to_T1w_mask_{pipe_num}',\n                               op_string='-bin ')\n    nodes = {key: strat_pool.node_data(key) for key in [\n        'bold', 'desc-preproc_bold', 'max-displacement',\n        'scan', 'space-bold_desc-brain_mask', 'space-T1w_desc-brain_mask',\n        'space-T1w_sbref', 'space-template_desc-preproc_bold',\n        'subject', *motion_params] if strat_pool.check_rpool(key)}\n    nodes['bold2template_mask'] = strat_pool.node_data([\n        'space-template_desc-bold_mask', 'space-EPItemplate_desc-bold_mask'])\n    nodes['template_mask'] = strat_pool.node_data(\n        ['T1w-brain-template-mask', 'EPI-template-mask'])\n    nodes['template'] = strat_pool.node_data(['T1w-brain-template-funcreg',\n                                              'EPI-brain-template-funcreg'])\n    resample_bold_mask_to_template = pe.Node(\n        afni.Resample(), name=f'resample_bold_mask_to_anat_res_{pipe_num}',\n        mem_gb=0, mem_x=(0.0115, 'in_file', 't'))\n    resample_bold_mask_to_template.inputs.outputtype = 'NIFTI_GZ'\n    wf = _connect_motion(wf, nodes, strat_pool, qc_file, pipe_num=pipe_num)\n    wf.connect([\n        (nodes['subject'].node, bids_info, [\n            (nodes['subject'].out, 'subject')]),\n        (nodes['scan'].node, bids_info, [(nodes['scan'].out, 'scan')]),\n        (nodes['space-T1w_sbref'].node, bold_to_T1w_mask, [\n            (nodes['space-T1w_sbref'].out, 'in_file')]),\n        (nodes['space-T1w_desc-brain_mask'].node, qc_file, [\n            (nodes['space-T1w_desc-brain_mask'].out, 't1w_mask')]),\n        (bold_to_T1w_mask, qc_file, [('out_file', 'bold2t1w_mask')]),\n        (nodes['template_mask'].node, qc_file, [\n            (nodes['template_mask'].out, 'template_mask')]),\n        (nodes['bold'].node, qc_file, [(nodes['bold'].out, 'original_func')]),\n        (nodes['space-template_desc-preproc_bold'].node, qc_file, [\n            (nodes['space-template_desc-preproc_bold'].out, 'final_func')]),\n        (nodes['template'].node, qc_file, [\n            (nodes['template'].out, 'template')]),\n        (nodes['template_mask'].node, resample_bold_mask_to_template, [\n             (nodes['template_mask'].out, 'master')]),\n        (nodes['bold2template_mask'].node, resample_bold_mask_to_template,\n            [(nodes['bold2template_mask'].out, 'in_file')]),\n        (resample_bold_mask_to_template, qc_file, [\n            ('out_file', 'bold2template_mask')]),\n        (bids_info, qc_file, [\n            ('subject', 'sub'),\n            ('session', 'ses'),\n            ('task', 'task'),\n            ('run', 'run')])])\n\n    return wf, {'space-template_desc-xcp_quality': (qc_file, 'qc_file')}"
  },
  {
    "name": "qc_snr_plot",
    "file": "CPAC/qc/pipeline.py",
    "line_number": 52,
    "decorator_args": {
      "name": "qc_snr_plot",
      "config": [
        "pipeline_setup",
        "output_directory",
        "quality_control"
      ],
      "switch": [
        "generate_quality_control_images"
      ],
      "inputs": [
        [
          "desc-preproc_bold",
          "space-bold_desc-brain_mask"
        ],
        "from-bold_to-T1w_mode-image_desc-linear_xfm",
        "desc-preproc_T1w",
        "space-T1w_sbref"
      ],
      "outputs": [
        "desc-boldSnrAxial_quality",
        "desc-boldSnrSagittal_quality",
        "desc-boldSnrHist_quality",
        "desc-boldSnr_quality"
      ]
    },
    "docstring": null,
    "source_code": "def qc_snr_plot(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    # make SNR plot\n    qc_workflow = create_qc_snr(f'qc_snr_{pipe_num}')\n\n    node, out = strat_pool.get_data(\"desc-preproc_bold\")\n    wf.connect(node, out, qc_workflow, 'inputspec.functional_preprocessed')\n\n    node, out = strat_pool.get_data(\"space-bold_desc-brain_mask\")\n    wf.connect(node, out, qc_workflow, 'inputspec.functional_brain_mask')\n\n    node, out = \\\n        strat_pool.get_data('from-bold_to-T1w_mode-image_desc-linear_xfm')\n    wf.connect(node, out,\n               qc_workflow, 'inputspec.functional_to_anat_linear_xfm')\n\n    node, out = strat_pool.get_data('desc-preproc_T1w')\n    wf.connect(node, out, qc_workflow, 'inputspec.anatomical_brain')\n\n    node, out = strat_pool.get_data('space-T1w_sbref')\n    wf.connect(node, out, qc_workflow, 'inputspec.mean_functional_in_anat')\n\n    outputs = {\n        'desc-boldSnrAxial_quality': (qc_workflow,\n                                      'outputspec.snr_axial_image'),\n        'desc-boldSnrSagittal_quality':\n            (qc_workflow, 'outputspec.snr_sagittal_image'),\n        'desc-boldSnrHist_quality': (\n            qc_workflow, 'outputspec.snr_histogram_image'),\n        'desc-boldSnr_quality': (qc_workflow, 'outputspec.snr_mean')\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "qc_motion_plot",
    "file": "CPAC/qc/pipeline.py",
    "line_number": 98,
    "decorator_args": {
      "name": "qc_motion_plot",
      "config": [
        "pipeline_setup",
        "output_directory",
        "quality_control"
      ],
      "switch": [
        "generate_quality_control_images"
      ],
      "inputs": [
        [
          "desc-movementParametersUnfiltered_motion",
          "desc-movementParameters_motion"
        ]
      ],
      "outputs": [
        "desc-movementParametersTrans_quality",
        "desc-movementParametersRot_quality"
      ]
    },
    "docstring": null,
    "source_code": "def qc_motion_plot(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    # make motion parameters plot\n    qc_workflow = create_qc_motion(f'qc_motion_{pipe_num}')\n\n    node, out = strat_pool.get_data([\n        \"desc-movementParametersUnfiltered_motion\",\n        \"desc-movementParameters_motion\"])\n    wf.connect(node, out, qc_workflow, 'inputspec.motion_parameters')\n\n    outputs = {\n        'desc-movementParametersTrans_quality': (\n            qc_workflow, 'outputspec.motion_translation_plot'),\n        'desc-movementParametersRot_quality': (\n            qc_workflow, 'outputspec.motion_rotation_plot')\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "qc_fd_plot",
    "file": "CPAC/qc/pipeline.py",
    "line_number": 125,
    "decorator_args": {
      "name": "qc_fd_plot",
      "config": [
        "pipeline_setup",
        "output_directory",
        "quality_control"
      ],
      "switch": [
        "generate_quality_control_images"
      ],
      "inputs": [
        "framewise-displacement-jenkinson"
      ],
      "outputs": [
        "desc-framewiseDisplacementJenkinsonPlot_quality"
      ]
    },
    "docstring": null,
    "source_code": "def qc_fd_plot(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    qc_workflow = create_qc_fd(f'qc_fd_{pipe_num}')\n\n    node, out = strat_pool.get_data('framewise-displacement-jenkinson')\n    wf.connect(node, out, qc_workflow, 'inputspec.fd')\n\n    outputs = {\n        'desc-framewiseDisplacementJenkinsonPlot_quality':\n            (qc_workflow, 'outputspec.fd_histogram_plot')\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "qc_brain_extraction",
    "file": "CPAC/qc/pipeline.py",
    "line_number": 147,
    "decorator_args": {
      "name": "qc_brain_extraction",
      "config": [
        "pipeline_setup",
        "output_directory",
        "quality_control"
      ],
      "switch": [
        "generate_quality_control_images"
      ],
      "inputs": [
        "desc-preproc_T1w",
        "desc-head_T1w"
      ],
      "outputs": [
        "desc-brain_desc-T1wAxial_quality",
        "desc-brain_desc-T1wSagittal_quality"
      ]
    },
    "docstring": null,
    "source_code": "def qc_brain_extraction(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    # make QC montages for Skull Stripping Visualization\n    qc_workflow = create_qc_skullstrip(\n        f'qc_skullstrip_{pipe_num}'\n    )\n\n    node, out = strat_pool.get_data('desc-preproc_T1w')\n    wf.connect(node, out, qc_workflow, 'inputspec.anatomical_brain')\n\n    node, out = strat_pool.get_data('desc-head_T1w')\n    wf.connect(node, out, qc_workflow, 'inputspec.anatomical_reorient')\n\n    outputs = {\n        'desc-brain_desc-T1wAxial_quality': (qc_workflow,\n                                             'outputspec.axial_image'),\n        'desc-brain_desc-T1wSagittal_quality':\n            (qc_workflow, 'outputspec.sagittal_image')\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "qc_T1w_standard",
    "file": "CPAC/qc/pipeline.py",
    "line_number": 180,
    "decorator_args": {
      "name": "qc_brain_extraction",
      "config": [
        "pipeline_setup",
        "output_directory",
        "quality_control"
      ],
      "switch": [
        "generate_quality_control_images"
      ],
      "inputs": [
        "space-template_desc-preproc_T1w",
        "T1w-brain-template"
      ],
      "outputs": [
        "space-template_desc-brain_desc-T1wAxial_quality",
        "space-template_desc-brain_desc-T1wSagittal_quality"
      ]
    },
    "docstring": null,
    "source_code": "def qc_T1w_standard(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    # make QC montages for mni normalized anatomical image\n    montage_mni_anat = create_montage(f'montage_mni_anat_{pipe_num}',\n                                      'red', 'mni_anat',\n                                      mapnode=False)\n\n    node, out = strat_pool.get_data('space-template_desc-preproc_T1w')\n    wf.connect(node, out, montage_mni_anat, 'inputspec.underlay')\n\n    anat_template_edge = pe.Node(Function(input_names=['in_file'],\n                                          output_names=['out_file'],\n                                          function=afni_Edge3,\n                                          as_module=True),\n                                 name=f'anat_template_edge_{pipe_num}')\n\n    node, out = strat_pool.get_data('T1w-brain-template')\n    wf.connect(node, out, anat_template_edge, 'in_file')\n\n    wf.connect(anat_template_edge, 'out_file',\n               montage_mni_anat, 'inputspec.overlay')\n\n    outputs = {\n        'space-template_desc-brain_desc-T1wAxial_quality':\n            (montage_mni_anat, 'outputspec.axial_png'),\n        'space-template_desc-brain_desc-T1wSagittal_quality':\n            (montage_mni_anat, 'outputspec.sagittal_png')\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "qc_segmentation",
    "file": "CPAC/qc/pipeline.py",
    "line_number": 226,
    "decorator_args": {
      "name": "qc_segmentation",
      "config": [
        "pipeline_setup",
        "output_directory",
        "quality_control"
      ],
      "switch": [
        "generate_quality_control_images"
      ],
      "inputs": [
        [
          "desc-preproc_T1w",
          [
            "label-CSF_desc-preproc_mask",
            "label-CSF_mask"
          ],
          [
            "label-WM_desc-preproc_mask",
            "label-WM_mask"
          ],
          [
            "label-GM_desc-preproc_mask",
            "label-GM_mask"
          ]
        ]
      ],
      "outputs": [
        "desc-dsegAxial_quality",
        "desc-dsegSagittal_quality"
      ]
    },
    "docstring": null,
    "source_code": "def qc_segmentation(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    # make QC montages for CSF WM GM\n    montage_csf_gm_wm = create_montage_gm_wm_csf(\n        f'montage_csf_gm_wm_{pipe_num}', 'montage_csf_gm_wm')\n\n    node, out = strat_pool.get_data('desc-preproc_T1w')\n    wf.connect(node, out, montage_csf_gm_wm, 'inputspec.underlay')\n\n    node, out = strat_pool.get_data(['label-CSF_desc-preproc_mask',\n                                     'label-CSF_mask'])\n    wf.connect(node, out, montage_csf_gm_wm, 'inputspec.overlay_csf')\n\n    node, out = strat_pool.get_data(['label-WM_desc-preproc_mask',\n                                     'label-WM_mask'])\n    wf.connect(node, out, montage_csf_gm_wm, 'inputspec.overlay_wm')\n\n    node, out = strat_pool.get_data(['label-GM_desc-preproc_mask',\n                                     'label-GM_mask'])\n    wf.connect(node, out, montage_csf_gm_wm, 'inputspec.overlay_gm')\n\n    outputs = {\n        'desc-dsegAxial_quality': (montage_csf_gm_wm, 'outputspec.axial_png'),\n        'desc-dsegSagittal_quality': (montage_csf_gm_wm,\n                                      'outputspec.sagittal_png')\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "qc_epi_segmentation",
    "file": "CPAC/qc/pipeline.py",
    "line_number": 270,
    "decorator_args": {
      "name": "qc_epi_segmentation",
      "config": [
        "pipeline_setup",
        "output_directory",
        "quality_control"
      ],
      "switch": [
        "generate_quality_control_images"
      ],
      "inputs": [
        [
          "desc-preproc_bold",
          [
            "space-bold_label-CSF_desc-preproc_mask",
            "space-bold_label-CSF_mask"
          ],
          [
            "space-bold_label-WM_desc-preproc_mask",
            "space-bold_label-WM_mask"
          ],
          [
            "space-bold_label-GM_desc-preproc_mask",
            "space-bold_label-GM_mask"
          ]
        ]
      ],
      "outputs": [
        "epi-desc-dsegAxial_quality",
        "epi-desc-dsegSagittal_quality"
      ]
    },
    "docstring": null,
    "source_code": "def qc_epi_segmentation(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    # make QC montages for CSF WM GM\n    montage_csf_gm_wm = create_montage_gm_wm_csf(\n        f'montage_csf_gm_wm_{pipe_num}', 'montage_csf_gm_wm')\n\n    node, out = strat_pool.get_data('desc-preproc_bold')\n    wf.connect(node, out, montage_csf_gm_wm, 'inputspec.underlay')\n\n    node, out = strat_pool.get_data(['space-bold_label-CSF_desc-preproc_mask',\n                                     'space-bold_label-CSF_mask'])\n    wf.connect(node, out, montage_csf_gm_wm, 'inputspec.overlay_csf')\n\n    node, out = strat_pool.get_data(['space-bold_label-WM_desc-preproc_mask',\n                                     'space-bold_label-WM_mask'])\n    wf.connect(node, out, montage_csf_gm_wm, 'inputspec.overlay_wm')\n\n    node, out = strat_pool.get_data(['space-bold_label-GM_desc-preproc_mask',\n                                     'space-bold_label-GM_mask'])\n    wf.connect(node, out, montage_csf_gm_wm, 'inputspec.overlay_gm')\n\n    outputs = {\n        'epi-desc-dsegAxial_quality': (montage_csf_gm_wm,\n                                       'outputspec.axial_png'),\n        'epi-desc-dsegSagittal_quality': (montage_csf_gm_wm,\n                                          'outputspec.sagittal_png')\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "qc_carpet_plot",
    "file": "CPAC/qc/pipeline.py",
    "line_number": 313,
    "decorator_args": {
      "name": "qc_carpet_plot",
      "config": [
        "pipeline_setup",
        "output_directory",
        "quality_control"
      ],
      "switch": [
        "generate_quality_control_images"
      ],
      "inputs": [
        [
          "space-template_desc-preproc_bold",
          "space-template_sbref"
        ],
        "GM-path",
        "WM-path",
        "CSF-path"
      ],
      "outputs": [
        "space-template_desc-preprocBoldCarpet_quality"
      ]
    },
    "docstring": null,
    "source_code": "def qc_carpet_plot(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    # make QC Carpet plot\n    carpet_seg = create_qc_carpet(f'carpet_seg_{pipe_num}', 'carpet_seg')\n\n    connection, resource = \\\n        strat_pool.get_data([\"space-template_desc-preproc_bold\"],\n                            report_fetched=True)\n    node, out = connection\n    wf.connect(node, out, carpet_seg, 'inputspec.functional_to_standard')\n\n    node, out = strat_pool.get_data(\"space-template_sbref\")\n    wf.connect(node, out, carpet_seg, 'inputspec.mean_functional_to_standard')\n\n    node, out = strat_pool.get_data(\"GM-path\")\n    wf.connect(node, out, carpet_seg, 'inputspec.anatomical_gm_mask')\n\n    node, out = strat_pool.get_data(\"WM-path\")\n    wf.connect(node, out, carpet_seg, 'inputspec.anatomical_wm_mask')\n\n    node, out = strat_pool.get_data(\"CSF-path\")\n    wf.connect(node, out, carpet_seg, 'inputspec.anatomical_csf_mask')\n\n    outputs = {'space-template_desc-preprocBoldCarpet_quality': (\n        carpet_seg, 'outputspec.carpet_plot')}\n\n    return (wf, outputs)"
  },
  {
    "name": "qc_coregistration",
    "file": "CPAC/qc/pipeline.py",
    "line_number": 349,
    "decorator_args": {
      "name": "qc_coregistration",
      "config": [
        "pipeline_setup",
        "output_directory",
        "quality_control"
      ],
      "switch": [
        "generate_quality_control_images"
      ],
      "inputs": [
        [
          "desc-preproc_T1w",
          "space-T1w_sbref"
        ]
      ],
      "outputs": [
        "space-T1w_desc-boldAxial_quality",
        "space-T1w_desc-boldSagittal_quality"
      ]
    },
    "docstring": null,
    "source_code": "def qc_coregistration(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    # make QC montage for Mean Functional in T1 with T1 edge\n    anat_edge = pe.Node(Function(input_names=['in_file'],\n                                 output_names=['out_file'],\n                                 function=afni_Edge3,\n                                 as_module=True),\n                        name=f'anat_edge_{pipe_num}')\n\n    node, out = strat_pool.get_data('desc-preproc_T1w')\n    wf.connect(node, out, anat_edge, 'in_file')\n\n    montage_anat = create_montage(f'montage_anat_{pipe_num}', 'red',\n                                  't1_edge_on_mean_func_in_t1', \n                                  mapnode=False)\n\n    wf.connect(anat_edge, 'out_file', montage_anat, 'inputspec.overlay')\n\n    node, out = strat_pool.get_data('space-T1w_sbref')\n    wf.connect(node, out, montage_anat, 'inputspec.underlay')\n\n    outputs = {\n        'space-T1w_desc-boldAxial_quality':\n            (montage_anat, 'outputspec.axial_png'),\n        'space-T1w_desc-boldSagittal_quality':\n            (montage_anat, 'outputspec.sagittal_png')\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "qc_bold_registration",
    "file": "CPAC/qc/pipeline.py",
    "line_number": 397,
    "decorator_args": {
      "name": "qc_bold_registration",
      "switch": [
        [
          "pipeline_setup",
          "output_directory",
          "quality_control",
          "generate_quality_control_images"
        ],
        [
          "registration_workflows",
          "anatomical_registration",
          "run"
        ]
      ],
      "inputs": [
        "space-template_sbref",
        "T1w-brain-template-funcreg"
      ],
      "outputs": [
        "space-template_desc-boldAxial_quality",
        "space-template_desc-boldSagittal_quality"
      ]
    },
    "docstring": null,
    "source_code": "def qc_bold_registration(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    # make QC montage for Mean Functional in MNI with MNI edge\n    montage_mfi = create_montage(f'montage_mfi_{pipe_num}', 'red',\n                                 'MNI_edge_on_mean_func_mni',\n                                 mapnode=False)\n\n    node, out = strat_pool.get_data('space-template_sbref')\n    wf.connect(node, out,  montage_mfi, 'inputspec.underlay')\n\n    func_template_edge = pe.Node(Function(input_names=['in_file'],\n                                          output_names=['out_file'],\n                                          function=afni_Edge3,\n                                          as_module=True),\n                                 name=f'func_template_edge_{pipe_num}')\n\n    node, out = strat_pool.get_data(\"T1w-brain-template-funcreg\")\n    wf.connect(node, out, func_template_edge, 'in_file')\n\n    wf.connect(func_template_edge, 'out_file',\n               montage_mfi, 'inputspec.overlay')\n\n    outputs = {\n        'space-template_desc-boldAxial_quality':\n            (montage_mfi, 'outputspec.axial_png'),\n        'space-template_desc-boldSagittal_quality':\n            (montage_mfi, 'outputspec.sagittal_png')\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "qc_bold_EPI_registration",
    "file": "CPAC/qc/pipeline.py",
    "line_number": 454,
    "decorator_args": {
      "name": "qc_bold_EPI_registration",
      "switch": [
        [
          "pipeline_setup",
          "output_directory",
          "quality_control",
          "generate_quality_control_images"
        ],
        [
          "registration_workflows",
          "functional_registration",
          "func_registration_to_template",
          "run_EPI"
        ]
      ],
      "inputs": [
        [
          "space-template_sbref",
          "from-bold_to-EPItemplate_mode-image_xfm"
        ],
        "EPI-template-funcreg"
      ],
      "outputs": [
        "space-template_desc-mean_desc-boldAxial_quality",
        "space-template_desc-mean_desc-boldSagittal_quality"
      ]
    },
    "docstring": null,
    "source_code": "def qc_bold_EPI_registration(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    # make QC montage for Mean Functional in MNI with MNI edge\n    montage_mfi = create_montage(f'montage_mfi_{pipe_num}', 'red',\n                                 'EPI_MNI_edge_on_mean_func_mni',\n                                 mapnode=False)\n\n    node, out = strat_pool.get_data('space-template_sbref')\n    wf.connect(node, out,  montage_mfi, 'inputspec.underlay')\n\n    func_template_edge = pe.Node(Function(input_names=['in_file'],\n                                          output_names=['out_file'],\n                                          function=afni_Edge3,\n                                          as_module=True),\n                                 name=f'EPI_func_template_edge_{pipe_num}')\n\n    node, out = strat_pool.get_data(\"EPI-template-funcreg\")\n    wf.connect(node, out, func_template_edge, 'in_file')\n\n    wf.connect(func_template_edge, 'out_file',\n               montage_mfi, 'inputspec.overlay')\n\n    outputs = {\n        'space-template_desc-boldAxial_quality':\n            (montage_mfi, 'outputspec.axial_png'),\n        'space-template_desc-boldSagittal_quality':\n            (montage_mfi, 'outputspec.sagittal_png')\n    }\n\n    return (wf, outputs)"
  },
  {
    "name": "surface_postproc",
    "file": "CPAC/surface/surf_preproc.py",
    "line_number": 577,
    "decorator_args": {
      "name": "surface_postproc",
      "config": [
        "surface_analysis",
        "post_freesurfer"
      ],
      "switch": [
        "run"
      ],
      "inputs": [
        [
          "freesurfer-subject-dir",
          [
            "pipeline-fs_desc-restore_T1w",
            "desc-preproc_T1w",
            "desc-reorient_T1w",
            "T1w",
            "space-longitudinal_desc-reorient_T1w"
          ],
          [
            "space-template_desc-head_T1w",
            "space-template_desc-brain_T1w",
            "space-template_desc-T1w_mask"
          ],
          [
            "from-T1w_to-template_mode-image_xfm",
            "from-T1w_to-template_mode-image_desc-linear_xfm"
          ],
          [
            "from-template_to-T1w_mode-image_xfm",
            "from-template_to-T1w_mode-image_desc-linear_xfm"
          ],
          [
            "space-template_desc-brain_bold",
            "space-template_desc-preproc_bold"
          ],
          [
            "space-template_desc-scout_bold",
            "space-template_desc-cleaned_bold",
            "space-template_desc-brain_bold",
            "space-template_desc-motion_bold",
            "space-template_bold"
          ]
        ]
      ],
      "outputs": [
        "space-fsLR_den-32k_bold",
        "atlas-DesikanKilliany_space-fsLR_den-32k",
        "atlas-Destrieux_space-fsLR_den-32k",
        "atlas-DesikanKilliany_space-fsLR_den-164k",
        "atlas-Destrieux_space-fsLR_den-164k",
        "space-fsLR_den-32k_bold-dtseries",
        "AtlasSubcortical-s2",
        "goodvoxels",
        "ribbon-only",
        "hemi-L_space-fsLR_den-32k_desc-atlasroi_bold",
        "hemi-R_space-fsLR_den-32k_desc-atlasroi_bold",
        "hemi-L_space-fsLR_den-32k_desc-atlasroi_mask",
        "hemi-R_space-fsLR_den-32k_desc-atlasroi_mask",
        "hemi-L_space-native_bold",
        "hemi-R_space-native_bold",
        "space-fsLR_den-32k_wb-spec",
        "space-native_wb-spec",
        "hemi-L_space-fsLR_den-32k_desc-FS_arealdistortion",
        "hemi-R_space-fsLR_den-32k_desc-FS_arealdistortion",
        "space-fsLR_den-32k_desc-FS_arealdistortion",
        "hemi-L_space-fsLR_den-32k_desc-MSMSulc_arealdistortion",
        "hemi-R_space-fsLR_den-32k_desc-MSMSulc_arealdistortion",
        "space-fsLR_den-32k_desc-MSMSulc_arealdistortion",
        "hemi-L_space-fsLR_den-32k_desc-FS_edgedistortion",
        "hemi-R_space-fsLR_den-32k_desc-FS_edgedistortion",
        "space-fsLR_den-32k_desc-FS_edgedistortion",
        "hemi-L_space-fsLR_den-32k_desc-MSMSulc_edgedistortion",
        "hemi-R_space-fsLR_den-32k_desc-MSMSulc_edgedistortion",
        "space-fsLR_den-32k_desc-MSMSulc_edgedistortion",
        "hemi-L_space-fsLR_den-32k_curv",
        "hemi-R_space-fsLR_den-32k_curv",
        "space-fsLR_den-32k_curv",
        "hemi-L_space-fsLR_den-32k_flat",
        "hemi-R_space-fsLR_den-32k_flat",
        "hemi-L_space-fsLR_den-32k_inflated",
        "hemi-R_space-fsLR_den-32k_inflated",
        "hemi-L_space-fsLR_den-32k_veryinflated",
        "hemi-R_space-fsLR_den-32k_veryinflated",
        "hemi-L_space-native_inflated",
        "hemi-R_space-native_inflated",
        "hemi-L_space-native_veryinflated",
        "hemi-R_space-native_veryinflated",
        "hemi-L_space-fsLR_den-164k_midthickness",
        "hemi-R_space-fsLR_den-164k_midthickness",
        "hemi-L_space-fsLR_den-32k_midthickness",
        "hemi-R_space-fsLR_den-32k_midthickness",
        "hemi-L_space-native_midthickness",
        "hemi-R_space-native_midthickness",
        "hemi-L_space-fsLR_den-32k_pial",
        "hemi-R_space-fsLR_den-32k_pial",
        "hemi-L_space-native_den-32k_pial",
        "hemi-R_space-native_den-32k_pial",
        "hemi-L_space-fsLR_den-32k_sphere",
        "hemi-R_space-fsLR_den-32k_sphere",
        "hemi-L_space-native_desc-MSMSulc_sphere",
        "hemi-R_space-native_desc-MSMSulc_sphere",
        "hemi-L_space-native_sphere",
        "hemi-R_space-native_sphere",
        "hemi-L_space-native_desc-reg_sphere",
        "hemi-R_space-native_desc-reg_sphere",
        "hemi-L_space-native_desc-reg-reg_sphere",
        "hemi-R_space-native_desc-reg-reg_sphere",
        "hemi-L_space-native_desc-rot_sphere",
        "hemi-R_space-native_desc-rot_sphere",
        "hemi-L_space-fsLR_den-32k_desc-FS_strainJ",
        "hemi-R_space-fsLR_den-32k_desc-FS_strainJ",
        "space-fsLR_den-32k_desc-FS_strainJ",
        "hemi-L_space-fsLR_den-32k_desc-MSMSulc_strainJ",
        "hemi-R_space-fsLR_den-32k_desc-MSMSulc_strainJ",
        "space-fsLR_den-32k_desc-MSMSulc_strainJ",
        "hemi-L_space-fsLR_den-32k_desc-FS_strainR",
        "hemi-R_space-fsLR_den-32k_desc-FS_strainR",
        "space-fsLR_den-32k_desc-FS_strainR",
        "hemi-L_space-fsLR_den-32k_desc-MSMSulc_strainR",
        "hemi-R_space-fsLR_den-32k_desc-MSMSulc_strainR",
        "space-fsLR_den-32k_desc-MSMSulc_strainR",
        "hemi-L_space-fsLR_den-32k_sulc",
        "hemi-R_space-fsLR_den-32k_sulc",
        "space-fsLR_den-32k_sulc",
        "hemi-L_space-fsLR_den-32k_thickness",
        "hemi-R_space-fsLR_den-32k_thickness",
        "space-fsLR_den-32k_thickness",
        "hemi-L_space-fsLR_den-164k_white",
        "hemi-R_space-fsLR_den-164k_white",
        "hemi-L_space-fsLR_den-32k_white",
        "hemi-R_space-fsLR_den-32k_white",
        "hemi-L_space-native_white",
        "hemi-R_space-native_white"
      ]
    },
    "docstring": null,
    "source_code": "def surface_postproc(wf, cfg, strat_pool, pipe_num, opt=None):\n\n    surf = pe.Node(util.Function(input_names=['post_freesurfer_folder',\n                                              'freesurfer_folder',\n                                              'subject',\n                                              't1w_restore_image',\n                                              'atlas_space_t1w_image',\n                                              'atlas_transform',\n                                              'inverse_atlas_transform',\n                                              'atlas_space_bold',\n                                              'scout_bold',\n                                              'surf_atlas_dir',\n                                              'gray_ordinates_dir',\n                                              'gray_ordinates_res',\n                                              'high_res_mesh',\n                                              'low_res_mesh',\n                                              'subcortical_gray_labels',\n                                              'freesurfer_labels',\n                                              'fmri_res',\n                                              'smooth_fwhm'],\n                                 output_names=['dtseries',\n                                               'desikan_killiany_164',\n                                               'destrieux_164',\n                                               'desikan_killiany_32',\n                                               'destrieux_32',\n                                               'subcortical_atlas',\n                                               'good_voxels',\n                                               'ribbon_only',\n                                               'atlas_roi_func_L', \n                                               'atlas_roi_func_R', \n                                               'atlas_roi_shape_L', \n                                               'atlas_roi_shape_R', \n                                               'native_L', \n                                               'native_R', \n                                               'spec_LR_32k',\n                                               'spec_native', \n                                               'areal_distortion_FS_L', \n                                               'areal_distortion_FS_R', \n                                               'areal_distortion_FS_dscalar', \n                                               'areal_distortion_MSMSulc_L', \n                                               'areal_distortion_MSMSulc_R', \n                                               'areal_distortion_MSMSulc_dscalar',\n                                               'edge_distortion_FS_L',\n                                               'edge_distortion_FS_R', \n                                               'edge_distortion_FS_dscalar', \n                                               'edge_distortion_MSMSulc_L', \n                                               'edge_distortion_MSMSulc_R', \n                                               'edge_distortion_MSMSulc_dscalar',\n                                               'curvature_L', \n                                               'curvature_R', \n                                               'curvature_dscalar', \n                                               'flat_L', \n                                               'flat_R',\n                                               '32k_inflated_L', \n                                               '32k_inflated_R', \n                                               '32k_very_inflated_L',\n                                               '32k_very_inflated_R', \n                                               'inflated_L', \n                                               'inflated_R', \n                                               'very_inflated_L', \n                                               'very_inflated_R',\n                                               'midthickness_L_164',\n                                               'midthickness_L_32', \n                                               'midthickness_L_native', \n                                               'midthickness_R_164', \n                                               'midthickness_R_32',\n                                               'midthickness_R_native',\n                                               'pial_L_32', \n                                               'pial_L_native', \n                                               'pial_R_32', \n                                               'pial_R_native',\n                                               'sphere_32k_fs_LR_L', \n                                               'sphere_32k_fs_LR_R', \n                                               'sphere_MSMSulc_L', \n                                               'sphere_MSMSulc_R', \n                                               'sphere_native_L', \n                                               'sphere_native_R', \n                                               'sphere_reg_L', \n                                               'sphere_reg_R', \n                                               'sphere_reg_reg_LR_L', \n                                               'sphere_reg_reg_LR_R', \n                                               'sphere_rot_L', \n                                               'sphere_rot_R',\n                                               'StrainJ_FS_L',\n                                               'StrainJ_FS_R', \n                                               'StrainJ_FS_dscalar', \n                                               'StrainJ_MSMSulc_L', \n                                               'StrainJ_MSMSulc_R', \n                                               'StrainJ_MSMSulc_dscalar', \n                                               'StrainR_FS_L', \n                                               'StrainR_FS_R', \n                                               'StrainR_FS_dscalar', \n                                               'StrainR_MSMSulc_L', \n                                               'StrainR_MSMSulc_R', \n                                               'StrainR_MSMSulc_dscalar', \n                                               'sulc_L', \n                                               'sulc_R', \n                                               'sulc_dscalar',\n                                               'thickness_L', \n                                               'thickness_R', \n                                               'thickness_dscalar', \n                                               'white_L_164', \n                                               'white_L_32', \n                                               'white_L_native', \n                                               'white_R_164', \n                                               'white_R_32', \n                                               'white_R_native'\n                                            ],\n                                 function=run_surface),\n                   name=f'post_freesurfer_{pipe_num}')\n\n    surf.inputs.subject = cfg['subject_id']\n\n    surf.inputs.post_freesurfer_folder = os.path.join(cfg.pipeline_setup['working_directory']['path'],\n        'cpac_' + cfg['subject_id'],\n        f'post_freesurfer_{pipe_num}')\n\n    surf.inputs.surf_atlas_dir = cfg.surface_analysis['post_freesurfer']['surf_atlas_dir']\n    surf.inputs.gray_ordinates_dir = cfg.surface_analysis['post_freesurfer']['gray_ordinates_dir']\n    surf.inputs.subcortical_gray_labels = cfg.surface_analysis['post_freesurfer']['subcortical_gray_labels']\n    surf.inputs.freesurfer_labels = cfg.surface_analysis['post_freesurfer']['freesurfer_labels']\n\n    # convert integers to strings as subprocess requires string inputs\n    surf.inputs.gray_ordinates_res = str(cfg.surface_analysis['post_freesurfer']['gray_ordinates_res'])\n    surf.inputs.high_res_mesh = str(cfg.surface_analysis['post_freesurfer']['high_res_mesh'])\n    surf.inputs.low_res_mesh = str(cfg.surface_analysis['post_freesurfer']['low_res_mesh'])\n    surf.inputs.fmri_res = str(cfg.surface_analysis['post_freesurfer']['fmri_res'])\n    surf.inputs.smooth_fwhm = str(cfg.surface_analysis['post_freesurfer']['smooth_fwhm'])\n\n    restore = [\"pipeline-fs_desc-restore_T1w\", \"desc-preproc_T1w\", \"desc-reorient_T1w\", \"T1w\",\n                  \"space-longitudinal_desc-reorient_T1w\"]\n    space_temp = [\"space-template_desc-head_T1w\", \"space-template_desc-brain_T1w\", \"space-template_desc-T1w_mask\"]\n    atlas_xfm = [\"from-T1w_to-template_mode-image_xfm\", \"from-T1w_to-template_mode-image_desc-linear_xfm\"]\n    atlas_xfm_inv = [\"from-template_to-T1w_mode-image_xfm\", \"from-template_to-T1w_mode-image_desc-linear_xfm\"]\n    atlas_space_bold = [\"space-template_desc-brain_bold\", \"space-template_desc-preproc_bold\"]\n    scout_bold = [\"space-template_desc-scout_bold\", \"space-template_desc-cleaned_bold\", \"space-template_desc-brain_bold\",\n                  \"space-template_desc-preproc_bold\", \"space-template_desc-motion_bold\", \"space-template_bold\"]\n\n    node, out = strat_pool.get_data('freesurfer-subject-dir')\n    wf.connect(node, out, surf, 'freesurfer_folder')\n\n\n    node, out = strat_pool.get_data(restore) \n    wf.connect(node, out, surf, 't1w_restore_image')\n    \n    \n    node, out = strat_pool.get_data(space_temp) \n    wf.connect(node, out, surf, 'atlas_space_t1w_image')\n\n    node, out = strat_pool.get_data(atlas_xfm) \n    wf.connect(node, out, surf, 'atlas_transform')\n\n    node, out = strat_pool.get_data(atlas_xfm_inv) \n    wf.connect(node, out, surf, 'inverse_atlas_transform')\n\n    node, out = strat_pool.get_data(atlas_space_bold) \n    wf.connect(node, out, surf, 'atlas_space_bold')\n\n    node, out = strat_pool.get_data(scout_bold)\n    wf.connect(node, out, surf, 'scout_bold')\n\n    outputs = {\n        'space-fsLR_den-32k_bold': (surf, 'dtseries'),\n        'atlas-DesikanKilliany_space-fsLR_den-32k': (surf,\n                                                            'desikan_'\n                                                            'killiany_32'),\n        'atlas-Destrieux_space-fsLR_den-32k': (surf, 'destrieux_32'),\n        'atlas-DesikanKilliany_space-fsLR_den-164k': (surf,\n                                                             'desikan_'\n                                                             'killiany_164'),\n        'atlas-Destrieux_space-fsLR_den-164k': (surf, 'destrieux_164'),\n        'AtlasSubcortical-s2': (surf, 'subcortical_atlas'), \n        'goodvoxels': (surf, 'good_voxels'),\n        'ribbon-only': (surf, 'ribbon_only'),\n        'hemi-L_space-fsLR_den-32k_desc-atlasroi_bold': (surf, \n                                    'atlas_roi_func_'\n                                    'L'),\n        'hemi-R_space-fsLR_den-32k_desc-atlasroi_bold': (surf, \n                                    'atlas_roi_func_'\n                                    'R'),\n        'hemi-L_space-fsLR_den-32k_desc-atlasroi_mask': (surf, \n                                    'atlas_roi_shape_'\n                                    'L'),\n        'hemi-R_space-fsLR_den-32k_desc-atlasroi_mask': (surf, \n                                    'atlas_roi_shape_'\n                                    'R'),                            \n        'hemi-L_space-native_bold': (surf, 'native_' 'L'),\n        'hemi-R_space-native_bold': (surf, 'native_' 'R'),\n        'space-fsLR_den-32k_wb-spec': (surf, 'spec_' 'LR_32k'), \n        'space-native_wb-spec': (surf, 'spec_' 'native'),\n        'hemi-L_space-fsLR_den-32k_desc-FS_arealdistortion': (surf, 'areal_distortion_'\n                                                                        'FS_'\n                                                                        'L'),\n        'hemi-R_space-fsLR_den-32k_desc-FS_arealdistortion': (surf, 'areal_distortion_'\n                                                                        'FS_'\n                                                                        'R'),\n        'space-fsLR_den-32k_desc-FS_arealdistortion': (surf, 'areal_distortion_'\n                                                                        'FS_'\n                                                                        'dscalar'),\n        'hemi-L_space-fsLR_den-32k_desc-MSMSulc_arealdistortion': (surf, 'areal_distortion_'\n                                                                        'MSMSulc_'\n                                                                        'L'),\n        'hemi-R_space-fsLR_den-32k_desc-MSMSulc_arealdistortion': (surf, 'areal_distortion_'\n                                                                        'MSMSulc_'\n                                                                        'R'),\n        'space-fsLR_den-32k_desc-MSMSulc_arealdistortion': (surf, 'areal_distortion_'\n                                                                        'MSMSulc_'\n                                                                        'dscalar'),\n        'hemi-L_space-fsLR_den-32k_desc-FS_edgedistortion': (surf, 'edge_distortion_'\n                                                                        'FS_'\n                                                                        'L'),\n        'hemi-R_space-fsLR_den-32k_desc-FS_edgedistortion': (surf, 'edge_distortion_'\n                                                                        'FS_'\n                                                                        'R'),\n        'space-fsLR_den-32k_desc-FS_edgedistortion': (surf, 'edge_distortion_'\n                                                                        'FS_'\n                                                                        'dscalar'),\n        'hemi-L_space-fsLR_den-32k_desc-MSMSulc_edgedistortion': (surf, 'edge_distortion_'\n                                                                        'MSMSulc_'\n                                                                        'L'),\n        'hemi-R_space-fsLR_den-32k_desc-MSMSulc_edgedistortion': (surf, 'edge_distortion_'\n                                                                        'MSMSulc_'\n                                                                        'R'),\n        'space-fsLR_den-32k_desc-MSMSulc_edgedistortion': (surf, 'edge_distortion_'\n                                                                        'MSMSulc_'\n                                                                        'dscalar'),\n        'hemi-L_space-fsLR_den-32k_curv': (surf, 'curvature_' 'L'),\n        'hemi-R_space-fsLR_den-32k_curv': (surf, 'curvature_' 'R'),\n        'space-fsLR_den-32k_curv': (surf, 'curvature_' 'dscalar'),\n        'hemi-L_space-fsLR_den-32k_flat': (surf, 'flat_L'),\n        'hemi-R_space-fsLR_den-32k_flat': (surf, 'flat_R'),\n        'hemi-L_space-fsLR_den-32k_inflated': (surf, '32k_inflated_L'),\n        'hemi-R_space-fsLR_den-32k_inflated': (surf, '32k_inflated_R'),\n        'hemi-L_space-fsLR_den-32k_veryinflated': (surf, '32k_very_inflated_L'),\n        'hemi-R_space-fsLR_den-32k_veryinflated': (surf, '32k_very_inflated_R'),\n        'hemi-L_space-native_inflated': (surf, 'inflated_L'),\n        'hemi-R_space-native_inflated': (surf, 'inflated_R'),\n        'hemi-L_space-native_veryinflated': (surf, 'very_inflated_L'),\n        'hemi-R_space-native_veryinflated': (surf, 'very_inflated_R'),\n        'hemi-L_space-fsLR_den-164k_midthickness': (surf, 'midthickness_L_164'),\n        'hemi-L_space-fsLR_den-32k_midthickness': (surf, 'midthickness_L_32'),\n        'hemi-L_space-native_midthickness': (surf, 'midthickness_L_native'),\n        'hemi-R_space-fsLR_den-164k_midthickness': (surf, 'midthickness_R_164'),\n        'hemi-R_space-fsLR_den-32k_midthickness': (surf, 'midthickness_R_32'),\n        'hemi-R_space-native_midthickness': (surf, 'midthickness_R_native'),\n        'hemi-L_space-fsLR_den-32k_pial': (surf, 'pial_L_32'),\n        'hemi-L_space-native_den-32k_pial': (surf, 'pial_L_native'),\n        'hemi-R_space-fsLR_den-32k_pial': (surf, 'pial_R_32'),\n        'hemi-R_space-native_den-32k_pial': (surf, 'pial_R_native'),\n        'hemi-L_space-fsLR_den-32k_sphere': (surf, 'sphere_32k_fs_LR_L'),\n        'hemi-R_space-fsLR_den-32k_sphere': (surf, 'sphere_32k_fs_LR_R'),                            \n        'hemi-L_space-native_desc-MSMSulc_sphere': (surf, 'sphere_MSMSulc_L'),\n        'hemi-R_space-native_desc-MSMSulc_sphere': (surf, 'sphere_MSMSulc_R'),\n        'hemi-L_space-native_sphere': (surf, 'sphere_native_L'),\n        'hemi-R_space-native_sphere': (surf, 'sphere_native_R'),\n        'hemi-L_space-native_desc-reg_sphere': (surf, 'sphere_reg_L'),\n        'hemi-R_space-native_desc-reg_sphere': (surf, 'sphere_reg_R'),\n        'hemi-L_space-native_desc-reg-reg_sphere': (surf, 'sphere_reg_reg_LR_L'),\n        'hemi-R_space-native_desc-reg-reg_sphere': (surf, 'sphere_reg_reg_LR_R'),\n        'hemi-L_space-native_desc-rot_sphere': (surf, 'sphere_rot_L'),\n        'hemi-R_space-native_desc-rot_sphere': (surf, 'sphere_rot_R'),\n        'hemi-L_space-fsLR_den-32k_desc-FS_strainJ': (surf, 'StrainJ_FS_L'),\n        'hemi-R_space-fsLR_den-32k_desc-FS_strainJ': (surf, 'StrainJ_FS_R'),\n        'space-fsLR_den-32k_desc-FS_strainJ': (surf, 'StrainJ_FS_dscalar'),\n        'hemi-L_space-fsLR_den-32k_desc-MSMSulc_strainJ': (surf, 'StrainJ_MSMSulc_L'),\n        'hemi-R_space-fsLR_den-32k_desc-MSMSulc_strainJ': (surf, 'StrainJ_MSMSulc_R'),\n        'space-fsLR_den-32k_desc-FS_strainJ': (surf, 'StrainJ_MSMSulc_dscalar'),\n        'hemi-L_space-fsLR_den-32k_desc-FS_strainR': (surf, 'StrainR_FS_L'),\n        'hemi-R_space-fsLR_den-32k_desc-FS_strainR': (surf, 'StrainR_FS_R'),\n        'space-fsLR_den-32k_desc-FS_strainR': (surf, 'StrainR_FS_dscalar'),\n        'hemi-L_space-fsLR_den-32k_desc-MSMSulc_strainR': (surf, 'StrainR_MSMSulc_L'),\n        'hemi-R_space-fsLR_den-32k_desc-MSMSulc_strainR': (surf, 'StrainR_MSMSulc_R'),\n        'space-fsLR_den-32k_desc-MSMSulc_strainR': (surf, 'StrainR_MSMSulc_dscalar'),\n        'hemi-L_space-fsLR_den-32k_sulc': (surf, 'sulc_L'),\n        'hemi-R_space-fsLR_den-32k_sulc': (surf, 'sulc_R'),\n        'space-fsLR_den-32k_sulc': (surf, 'sulc_dscalar'),                                   \n        'hemi-L_space-fsLR_den-32k_thickness': (surf, 'thickness_L'),\n        'hemi-R_space-fsLR_den-32k_thickness': (surf, 'thickness_R'),\n        'space-fsLR_den-32k_thickness': (surf, 'thickness_dscalar'),                                   \n        'hemi-L_space-fsLR_den-164k_white': (surf, 'white_L_164'),\n        'hemi-L_space-fsLR_den-32k_white': (surf, 'white_L_32'),\n        'hemi-L_space-native_white': (surf, 'white_L_native'),\n        'hemi-R_space-fsLR_den-164k_white': (surf, 'white_R_164'),\n        'hemi-R_space-fsLR_den-32k_white': (surf, 'white_R_32'),\n        'hemi-R_space-native_white': (surf, 'white_R_native')\n    }\n\n    return wf, outputs"
  },
  {
    "name": "surface_falff",
    "file": "CPAC/surface/surf_preproc.py",
    "line_number": 875,
    "decorator_args": {
      "name": "surface_falff",
      "config": [
        "surface_analysis",
        "amplitude_low_frequency_fluctuation"
      ],
      "switch": [
        "run"
      ],
      "inputs": [
        "space-fsLR_den-32k_bold"
      ],
      "outputs": [
        "space-fsLR_den-32k_bold_surf_falff"
      ]
    },
    "docstring": null,
    "source_code": "def surface_falff(wf, cfg, strat_pool, pipe_num, opt):\n\n    falff = pe.Node(util.Function(input_names=['subject','dtseries'], \n                                output_names=['surf_falff'],\n                                function=run_surf_falff),\n                   name=f'surf_falff_{pipe_num}')\n    \n    falff.inputs.subject = cfg['subject_id']\n    node, out = strat_pool.get_data('space-fsLR_den-32k_bold') \n    wf.connect(node, out, falff, 'dtseries')\n    \n    outputs = {\n        'space-fsLR_den-32k_bold_surf_falff': (falff,'surf_falff')}\n    return wf, outputs"
  },
  {
    "name": "surface_alff",
    "file": "CPAC/surface/surf_preproc.py",
    "line_number": 900,
    "decorator_args": {
      "name": "surface_alff",
      "config": [
        "surface_analysis",
        "amplitude_low_frequency_fluctuation"
      ],
      "switch": [
        "run"
      ],
      "inputs": [
        "space-fsLR_den-32k_bold"
      ],
      "outputs": [
        "space-fsLR_den-32k_bold_surf_alff"
      ]
    },
    "docstring": null,
    "source_code": "def surface_alff(wf, cfg, strat_pool, pipe_num, opt):\n\n    alff = pe.Node(util.Function(input_names=['subject', 'dtseries'], \n                             output_names=['surf_alff'],\n                               function=run_surf_alff),\n                 name=f'surf_alff_{pipe_num}')\n    \n    alff.inputs.subject = cfg['subject_id']\n    node, out = strat_pool.get_data('space-fsLR_den-32k_bold') \n    wf.connect(node, out, alff, 'dtseries')\n    outputs = {\n        'space-fsLR_den-32k_bold_surf_alff': (alff, 'surf_alff')}\n    return wf, outputs"
  },
  {
    "name": "surface_reho",
    "file": "CPAC/surface/surf_preproc.py",
    "line_number": 928,
    "decorator_args": {
      "name": "surface_reho",
      "config": [
        "surface_analysis",
        "regional_homogeneity"
      ],
      "switch": [
        "run"
      ],
      "inputs": [
        "space-fsLR_den-32k_bold",
        "hemi-L_space-fsLR_den-32k_midthickness",
        "hemi-L_space-fsLR_den-32k_desc-atlasroi_mask",
        "hemi-R_space-fsLR_den-32k_midthickness",
        "hemi-R_space-fsLR_den-32k_desc-atlasroi_mask"
      ],
      "outputs": [
        "space-fsLR_den-32k_bold_surf-L_reho",
        "space-fsLR_den-32k_bold_surf-R_reho"
      ]
    },
    "docstring": null,
    "source_code": "def surface_reho(wf, cfg, strat_pool, pipe_num, opt):\n\n    L_cortex_file = pe.Node(util.Function(input_names=['subject', 'dtseries', 'structure', 'cortex_filename'], \n                                output_names=['L_cortex_file'],\n                                function=run_get_cortex),\n                  name=f'L_surf_cortex_{pipe_num}')\n    \n    L_cortex_file.inputs.subject = cfg['subject_id']\n    L_cortex_file.inputs.structure = \"CORTEX_LEFT\"\n    L_cortex_file.inputs.cortex_filename = \"L_cortex.func.gii\"\n    node, out = strat_pool.get_data('space-fsLR_den-32k_bold') \n    wf.connect(node, out, L_cortex_file, 'dtseries')\n\n    R_cortex_file = pe.Node(util.Function(input_names=['subject', 'dtseries', 'structure', 'cortex_filename'], \n                                output_names=['R_cortex_file'],\n                                function=run_get_cortex),\n                  name=f'R_surf_cortex_{pipe_num}')\n\n    R_cortex_file.inputs.subject = cfg['subject_id']\n    R_cortex_file.inputs.structure = \"CORTEX_RIGHT\"\n    R_cortex_file.inputs.cortex_filename = \"R_cortex.func.gii\"\n    wf.connect(node, out,R_cortex_file, 'dtseries')\n\n\n    mean_timeseries = pe.Node(util.Function(input_names=['subject', 'dtseries'], \n                                output_names=['mean_timeseries'],\n                                function=run_mean_timeseries),\n                  name=f'mean_timeseries_{pipe_num}')\n\n    mean_timeseries.inputs.subject = cfg['subject_id']\n    wf.connect(node, out, mean_timeseries, 'dtseries')\n\n    L_reho = pe.Node(util.Function(input_names=['subject', 'dtseries', 'mask' , 'cortex_file', 'surface_file', 'mean_timeseries','reho_filename', 'structure_name'], \n                                output_names=['L_reho'],\n                                function=run_surf_reho),\n                    name=f'L_surf_reho_{pipe_num}')\n    \n    L_reho.inputs.subject = cfg['subject_id']\n    wf.connect(L_cortex_file, 'L_cortex_file', L_reho, 'cortex_file')\n    node, out = strat_pool.get_data('hemi-L_space-fsLR_den-32k_midthickness')\n    wf.connect(node, out, L_reho, 'surface_file')\n    \n    node, out = strat_pool.get_data('hemi-L_space-fsLR_den-32k_desc-atlasroi_mask')\n    wf.connect(node, out, L_reho, 'mask')\n    wf.connect(mean_timeseries, 'mean_timeseries', L_reho, 'mean_timeseries') \n    L_reho.inputs.reho_filename = \"L_surf_reho.dscalar.nii\"\n    L_reho.inputs.structure_name = \"CIFTI_STRUCTURE_CORTEX_LEFT\"\n    node, out = strat_pool.get_data('space-fsLR_den-32k_bold')\n    wf.connect(node, out, L_reho, 'dtseries')\n\n    R_reho = pe.Node(util.Function(input_names=['subject','dtseries', 'mask' , 'cortex_file', 'surface_file', 'mean_timeseries', 'reho_filename', 'structure_name'], \n                                output_names=['R_reho'],\n                                function=run_surf_reho),\n                    name=f'R_surf_reho_{pipe_num}')\n    \n    R_reho.inputs.subject = cfg['subject_id']\n    wf.connect(R_cortex_file, 'R_cortex_file', R_reho, 'cortex_file')\n    node, out = strat_pool.get_data('hemi-R_space-fsLR_den-32k_midthickness')\n    wf.connect(node, out, R_reho, 'surface_file')\n    R_reho.inputs.structure_name = \"CIFTI_STRUCTURE_CORTEX_RIGHT\"\n    node, out = strat_pool.get_data('hemi-R_space-fsLR_den-32k_desc-atlasroi_mask')\n    wf.connect(node, out, R_reho, 'mask')\n    wf.connect(mean_timeseries, 'mean_timeseries', R_reho, 'mean_timeseries') \n    R_reho.inputs.reho_filename = \"R_surf_reho.dscalar.nii\"\n    node, out = strat_pool.get_data('space-fsLR_den-32k_bold')\n    wf.connect(node, out, R_reho, 'dtseries')\n\n    outputs = {\n        'space-fsLR_den-32k_bold_surf-L_reho': (L_reho,'L_reho'),\n        'space-fsLR_den-32k_bold_surf-R_reho': (R_reho,'R_reho')}\n\n    return wf, outputs"
  },
  {
    "name": "surface_connectivity_matrix",
    "file": "CPAC/surface/surf_preproc.py",
    "line_number": 1009,
    "decorator_args": {
      "name": "surface_connectivity_matrix",
      "config": [
        "surface_analysis",
        "surface_connectivity"
      ],
      "switch": [
        "run"
      ],
      "inputs": [
        "space-fsLR_den-32k_bold"
      ],
      "outputs": [
        "space-fsLR_den-32k_bold_surf-correlation_matrix"
      ]
    },
    "docstring": null,
    "source_code": "def surface_connectivity_matrix(wf, cfg, strat_pool, pipe_num, opt):\n\n     \n    connectivity_parcellation = pe.Node(util.Function(input_names=['subject', 'dtseries', 'surf_atlaslabel'], \n                                output_names=['parcellation_file'],\n                                function=run_ciftiparcellate),\n                            name=f'connectivity_parcellation_{pipe_num}')\n\n    connectivity_parcellation.inputs.subject = cfg['subject_id'] \n    node, out = strat_pool.get_data('space-fsLR_den-32k_bold')        \n    wf.connect(node, out, connectivity_parcellation, 'dtseries') \n    connectivity_parcellation.inputs.surf_atlaslabel = cfg.surface_analysis['surface_connectivity']['surface_parcellation_template']\n\n    correlation_matrix = pe.Node(util.Function(input_names=['subject','ptseries'], \n                                output_names=['correlation_matrix'],\n                                function=run_cifticorrelation),\n                            name=f'correlation_matrix_{pipe_num}')\n                \n    correlation_matrix.inputs.subject = cfg['subject_id'] \n    wf.connect(connectivity_parcellation, 'parcellation_file', correlation_matrix, 'ptseries') \n    \n    outputs = {\n        'space-fsLR_den-32k_bold_surf-correlation_matrix': (correlation_matrix,'correlation_matrix')}\n\n    return wf, outputs"
  }
]